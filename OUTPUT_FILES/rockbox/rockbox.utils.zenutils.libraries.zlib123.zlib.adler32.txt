 adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2004 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
  @(#) $Id$  largest prime smaller than 65536  NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1  use NO_DIVIDE if your processor does not do division in hardware  =========================================================================  split Adler-32 into component sums  in case user likes doing a byte at a time, keep it fast  initial Adler-32 value (deferred check for len == 1 speed)  in case short lengths are provided, keep it somewhat fast  only added so many BASE's  do length NMAX blocks -- requires just one modulo operation  NMAX is divisible by 16  16 sums unrolled  do remaining bytes (less than NMAX, still just one modulo)  avoid modulos if none remaining  return recombined sums  =========================================================================  the derivation of this formula is left as an exercise for the reader  adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2004 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
  @(#) $Id$  largest prime smaller than 65536  NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1  use NO_DIVIDE if your processor does not do division in hardware  =========================================================================  split Adler-32 into component sums  in case user likes doing a byte at a time, keep it fast  initial Adler-32 value (deferred check for len == 1 speed)  in case short lengths are provided, keep it somewhat fast  only added so many BASE's  do length NMAX blocks -- requires just one modulo operation  NMAX is divisible by 16  16 sums unrolled  do remaining bytes (less than NMAX, still just one modulo)  avoid modulos if none remaining  return recombined sums  =========================================================================  the derivation of this formula is left as an exercise for the reader  adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2004 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
  @(#) $Id$  largest prime smaller than 65536  NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1  use NO_DIVIDE if your processor does not do division in hardware  =========================================================================  split Adler-32 into component sums  in case user likes doing a byte at a time, keep it fast  initial Adler-32 value (deferred check for len == 1 speed)  in case short lengths are provided, keep it somewhat fast  only added so many BASE's  do length NMAX blocks -- requires just one modulo operation  NMAX is divisible by 16  16 sums unrolled  do remaining bytes (less than NMAX, still just one modulo)  avoid modulos if none remaining  return recombined sums  =========================================================================  the derivation of this formula is left as an exercise for the reader 