
 * Copyright (c) 2011, Kustaa Nyholm / SpareTimeLabs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list 
 * of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice, this 
 * list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 *  
 * Neither the name of the Kustaa Nyholm or SpareTimeLabs nor the names of its 
 * contributors may be used to endorse or promote products derived from this software 
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
  initial value these cached values are used to detect changes in termios structure and speed up things by avoiding unnecessary updates FIXME here convert from Windows error code to 'posix' error code interruption cannot cancel wait FIXME what would be appropriate error code here / 'hEvent' might never have been 'read' so read it to this var firststatic private class FDSetImpl extends FDSet {	static final int FD_SET_SIZE = 256; // Windows supports max 255 serial ports so this is enough	static final int NFBBITS = 32;	int[] bits = new int[(FD_SET_SIZE + NFBBITS - 1) / NFBBITS];} Windows supports max 255 serial ports so this is enough Error code for Interrupted = EINTR default to 8 extra stop bit parity adds an other bit start bit + stop bit limit reads to internal buffer size VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = MAXDWORD;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = vtime;touts.ReadTotalTimeoutMultiplier = 0; NOTE to behave like unix we should probably wait until there is something available and then try to do a read as many bytes as are available bytes at that point in time.  As this is coded now, this will attempt to read as many bytes as requested and this may end up spending vtime in the read when a unix would return less bytes but as soon as they become available.  VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = vtime;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; Hmmm, can this ever happen, why we have that here I exptect this is never going to happen, if it does copy from buffer to Memory  port.m_WrN[0];
	 * (non-Javadoc) Basically this is wrong, as tcsetattr is supposed to set
	 * only those things it can support and tcgetattr is the used to see that
	 * what actually happened. In this instance tcsetattr never fails and
	 * tcgetattr always returns the last settings even though it possible (even
	 * likely) that tcsetattr was not able to carry out all settings, as there
	 * is no 1:1 mapping between Windows Comm API and posix/termios API.
	 * 
	 * @see jtermios.JTermios.JTermiosInterface#tcgetattr(int, jtermios.Termios)
	  FIXME this needs serious code review from people who know this stuff... rxtx does: if ( s_termios->c_iflag & ISTRIP ) dcb.fBinary = FALSE; but Winapi doc says fBinary always true Following have no corresponding functionality in unix termios fOutxDsrFlow = 0x00000008; fDtrControl = 0x00000030; fDsrSensitivity = 0x00000040; fErrorChar = 0x00000400; fNull = 0x00000800; fAbortOnError = 0x00004000; fDummy2 = 0xFFFF8000; Don't touch these, windows seems to use: XonLim 2048 XoffLim 512 and who am I to argue with thosedcb.XonLim = 0;dcb.XoffLim = 128; In theory these could change but they only get updated if the baudrate/char size changes so this could be a time bomb  In practice in PJC these are never changed so updating on the first pass is enough rxtx has some thing like if ( EV_BREAK|EV_CTS|EV_DSR|EV_ERR|EV_RING | ( EV_RLSD & EV_RXFLAG ) ) dcb.EvtChar = '\n'; else dcb.EvtChar = '\0'; But those are all defines so there is something fishy there? There are really no write timeouts in classic unix termios FIXME test that we can still interrupt the tread VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received long T0 = System.currentTimeMillis(); check if there is data to be read, as WaitCommEvent does check for only *new* data that and thus might wait indefinitely if select() is called twice without first reading away all data actually it seems that overlapped WaitCommEvent never returns true so we never get here FIXME if the port dies on us what happens FIXME Under Windows sometimes the error code 87 (ERROR_INVALID_PARAMETER) is returned. it has not been not investigated why but this appears to work int res = WaitForSingleObject(wobj[0], tout); work around the fact that sometimes we miss events it was the cancel sema4 so just return  long T1 = System.currentTimeMillis(); System.err.println("select() " + (T1 - T0)); This is a bit pointless function as Windows baudrate constants are just the baudrates so basically this is a no-op, it returns what it gets Note this assumes that the Bxxxx constants in JTermios have the default values ie the values are the baudrates. should never happen pipe() not implemented on Windows backend
 * Copyright (c) 2011, Kustaa Nyholm / SpareTimeLabs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list 
 * of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice, this 
 * list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 *  
 * Neither the name of the Kustaa Nyholm or SpareTimeLabs nor the names of its 
 * contributors may be used to endorse or promote products derived from this software 
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
  initial value these cached values are used to detect changes in termios structure and speed up things by avoiding unnecessary updates FIXME here convert from Windows error code to 'posix' error code interruption cannot cancel wait FIXME what would be appropriate error code here / 'hEvent' might never have been 'read' so read it to this var firststatic private class FDSetImpl extends FDSet {	static final int FD_SET_SIZE = 256; // Windows supports max 255 serial ports so this is enough	static final int NFBBITS = 32;	int[] bits = new int[(FD_SET_SIZE + NFBBITS - 1) / NFBBITS];} Windows supports max 255 serial ports so this is enough Error code for Interrupted = EINTR default to 8 extra stop bit parity adds an other bit start bit + stop bit limit reads to internal buffer size VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = MAXDWORD;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = vtime;touts.ReadTotalTimeoutMultiplier = 0; NOTE to behave like unix we should probably wait until there is something available and then try to do a read as many bytes as are available bytes at that point in time.  As this is coded now, this will attempt to read as many bytes as requested and this may end up spending vtime in the read when a unix would return less bytes but as soon as they become available.  VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = vtime;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; Hmmm, can this ever happen, why we have that here I exptect this is never going to happen, if it does copy from buffer to Memory  port.m_WrN[0];
	 * (non-Javadoc) Basically this is wrong, as tcsetattr is supposed to set
	 * only those things it can support and tcgetattr is the used to see that
	 * what actually happened. In this instance tcsetattr never fails and
	 * tcgetattr always returns the last settings even though it possible (even
	 * likely) that tcsetattr was not able to carry out all settings, as there
	 * is no 1:1 mapping between Windows Comm API and posix/termios API.
	 * 
	 * @see jtermios.JTermios.JTermiosInterface#tcgetattr(int, jtermios.Termios)
	  FIXME this needs serious code review from people who know this stuff... rxtx does: if ( s_termios->c_iflag & ISTRIP ) dcb.fBinary = FALSE; but Winapi doc says fBinary always true Following have no corresponding functionality in unix termios fOutxDsrFlow = 0x00000008; fDtrControl = 0x00000030; fDsrSensitivity = 0x00000040; fErrorChar = 0x00000400; fNull = 0x00000800; fAbortOnError = 0x00004000; fDummy2 = 0xFFFF8000; Don't touch these, windows seems to use: XonLim 2048 XoffLim 512 and who am I to argue with thosedcb.XonLim = 0;dcb.XoffLim = 128; In theory these could change but they only get updated if the baudrate/char size changes so this could be a time bomb  In practice in PJC these are never changed so updating on the first pass is enough rxtx has some thing like if ( EV_BREAK|EV_CTS|EV_DSR|EV_ERR|EV_RING | ( EV_RLSD & EV_RXFLAG ) ) dcb.EvtChar = '\n'; else dcb.EvtChar = '\0'; But those are all defines so there is something fishy there? There are really no write timeouts in classic unix termios FIXME test that we can still interrupt the tread VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received long T0 = System.currentTimeMillis(); check if there is data to be read, as WaitCommEvent does check for only *new* data that and thus might wait indefinitely if select() is called twice without first reading away all data actually it seems that overlapped WaitCommEvent never returns true so we never get here FIXME if the port dies on us what happens FIXME Under Windows sometimes the error code 87 (ERROR_INVALID_PARAMETER) is returned. it has not been not investigated why but this appears to work int res = WaitForSingleObject(wobj[0], tout); work around the fact that sometimes we miss events it was the cancel sema4 so just return  long T1 = System.currentTimeMillis(); System.err.println("select() " + (T1 - T0)); This is a bit pointless function as Windows baudrate constants are just the baudrates so basically this is a no-op, it returns what it gets Note this assumes that the Bxxxx constants in JTermios have the default values ie the values are the baudrates. should never happen pipe() not implemented on Windows backend
 * Copyright (c) 2011, Kustaa Nyholm / SpareTimeLabs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list 
 * of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice, this 
 * list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 *  
 * Neither the name of the Kustaa Nyholm or SpareTimeLabs nor the names of its 
 * contributors may be used to endorse or promote products derived from this software 
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
  initial value these cached values are used to detect changes in termios structure and speed up things by avoiding unnecessary updates FIXME here convert from Windows error code to 'posix' error code interruption cannot cancel wait FIXME what would be appropriate error code here / 'hEvent' might never have been 'read' so read it to this var firststatic private class FDSetImpl extends FDSet {	static final int FD_SET_SIZE = 256; // Windows supports max 255 serial ports so this is enough	static final int NFBBITS = 32;	int[] bits = new int[(FD_SET_SIZE + NFBBITS - 1) / NFBBITS];} Windows supports max 255 serial ports so this is enough Error code for Interrupted = EINTR default to 8 extra stop bit parity adds an other bit start bit + stop bit limit reads to internal buffer size VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = MAXDWORD;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = vtime;touts.ReadTotalTimeoutMultiplier = 0; NOTE to behave like unix we should probably wait until there is something available and then try to do a read as many bytes as are available bytes at that point in time.  As this is coded now, this will attempt to read as many bytes as requested and this may end up spending vtime in the read when a unix would return less bytes but as soon as they become available.  VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = vtime;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; Hmmm, can this ever happen, why we have that here I exptect this is never going to happen, if it does copy from buffer to Memory  port.m_WrN[0];
	 * (non-Javadoc) Basically this is wrong, as tcsetattr is supposed to set
	 * only those things it can support and tcgetattr is the used to see that
	 * what actually happened. In this instance tcsetattr never fails and
	 * tcgetattr always returns the last settings even though it possible (even
	 * likely) that tcsetattr was not able to carry out all settings, as there
	 * is no 1:1 mapping between Windows Comm API and posix/termios API.
	 * 
	 * @see jtermios.JTermios.JTermiosInterface#tcgetattr(int, jtermios.Termios)
	  FIXME this needs serious code review from people who know this stuff... rxtx does: if ( s_termios->c_iflag & ISTRIP ) dcb.fBinary = FALSE; but Winapi doc says fBinary always true Following have no corresponding functionality in unix termios fOutxDsrFlow = 0x00000008; fDtrControl = 0x00000030; fDsrSensitivity = 0x00000040; fErrorChar = 0x00000400; fNull = 0x00000800; fAbortOnError = 0x00004000; fDummy2 = 0xFFFF8000; Don't touch these, windows seems to use: XonLim 2048 XoffLim 512 and who am I to argue with thosedcb.XonLim = 0;dcb.XoffLim = 128; In theory these could change but they only get updated if the baudrate/char size changes so this could be a time bomb  In practice in PJC these are never changed so updating on the first pass is enough rxtx has some thing like if ( EV_BREAK|EV_CTS|EV_DSR|EV_ERR|EV_RING | ( EV_RLSD & EV_RXFLAG ) ) dcb.EvtChar = '\n'; else dcb.EvtChar = '\0'; But those are all defines so there is something fishy there? There are really no write timeouts in classic unix termios FIXME test that we can still interrupt the tread VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received long T0 = System.currentTimeMillis(); check if there is data to be read, as WaitCommEvent does check for only *new* data that and thus might wait indefinitely if select() is called twice without first reading away all data actually it seems that overlapped WaitCommEvent never returns true so we never get here FIXME if the port dies on us what happens FIXME Under Windows sometimes the error code 87 (ERROR_INVALID_PARAMETER) is returned. it has not been not investigated why but this appears to work int res = WaitForSingleObject(wobj[0], tout); work around the fact that sometimes we miss events it was the cancel sema4 so just return  long T1 = System.currentTimeMillis(); System.err.println("select() " + (T1 - T0)); This is a bit pointless function as Windows baudrate constants are just the baudrates so basically this is a no-op, it returns what it gets Note this assumes that the Bxxxx constants in JTermios have the default values ie the values are the baudrates. should never happen pipe() not implemented on Windows backend
 * Copyright (c) 2011, Kustaa Nyholm / SpareTimeLabs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list 
 * of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright notice, this 
 * list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 *  
 * Neither the name of the Kustaa Nyholm or SpareTimeLabs nor the names of its 
 * contributors may be used to endorse or promote products derived from this software 
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
  initial value these cached values are used to detect changes in termios structure and speed up things by avoiding unnecessary updates FIXME here convert from Windows error code to 'posix' error code interruption cannot cancel wait FIXME what would be appropriate error code here / 'hEvent' might never have been 'read' so read it to this var firststatic private class FDSetImpl extends FDSet {	static final int FD_SET_SIZE = 256; // Windows supports max 255 serial ports so this is enough	static final int NFBBITS = 32;	int[] bits = new int[(FD_SET_SIZE + NFBBITS - 1) / NFBBITS];} Windows supports max 255 serial ports so this is enough Error code for Interrupted = EINTR default to 8 extra stop bit parity adds an other bit start bit + stop bit limit reads to internal buffer size VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = MAXDWORD;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = vtime;touts.ReadTotalTimeoutMultiplier = 0; NOTE to behave like unix we should probably wait until there is something available and then try to do a read as many bytes as are available bytes at that point in time.  As this is coded now, this will attempt to read as many bytes as requested and this may end up spending vtime in the read when a unix would return less bytes but as soon as they become available.  VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = vtime;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received For reference below commented out is how timeouts are set for this vtime/vmin combotouts.ReadIntervalTimeout = 0;touts.ReadTotalTimeoutConstant = 0;touts.ReadTotalTimeoutMultiplier = 0; Hmmm, can this ever happen, why we have that here I exptect this is never going to happen, if it does copy from buffer to Memory  port.m_WrN[0];
	 * (non-Javadoc) Basically this is wrong, as tcsetattr is supposed to set
	 * only those things it can support and tcgetattr is the used to see that
	 * what actually happened. In this instance tcsetattr never fails and
	 * tcgetattr always returns the last settings even though it possible (even
	 * likely) that tcsetattr was not able to carry out all settings, as there
	 * is no 1:1 mapping between Windows Comm API and posix/termios API.
	 * 
	 * @see jtermios.JTermios.JTermiosInterface#tcgetattr(int, jtermios.Termios)
	  FIXME this needs serious code review from people who know this stuff... rxtx does: if ( s_termios->c_iflag & ISTRIP ) dcb.fBinary = FALSE; but Winapi doc says fBinary always true Following have no corresponding functionality in unix termios fOutxDsrFlow = 0x00000008; fDtrControl = 0x00000030; fDsrSensitivity = 0x00000040; fErrorChar = 0x00000400; fNull = 0x00000800; fAbortOnError = 0x00004000; fDummy2 = 0xFFFF8000; Don't touch these, windows seems to use: XonLim 2048 XoffLim 512 and who am I to argue with thosedcb.XonLim = 0;dcb.XoffLim = 128; In theory these could change but they only get updated if the baudrate/char size changes so this could be a time bomb  In practice in PJC these are never changed so updating on the first pass is enough rxtx has some thing like if ( EV_BREAK|EV_CTS|EV_DSR|EV_ERR|EV_RING | ( EV_RLSD & EV_RXFLAG ) ) dcb.EvtChar = '\n'; else dcb.EvtChar = '\0'; But those are all defines so there is something fishy there? There are really no write timeouts in classic unix termios FIXME test that we can still interrupt the tread VMIN = 0 and VTIME = 0 => totally non blocking,if data is available, return it, ie this is poll operation VMIN = 0 and VTIME > 0 => timed read, return as soon as data is available, VTIME = total time VMIN > 0 and VTIME > 0 => blocks until VMIN chars has arrived or  between chars expired,  note that this will block if nothing arrives VMIN > 0 and VTIME = 0 => blocks until VMIN characters have been received long T0 = System.currentTimeMillis(); check if there is data to be read, as WaitCommEvent does check for only *new* data that and thus might wait indefinitely if select() is called twice without first reading away all data actually it seems that overlapped WaitCommEvent never returns true so we never get here FIXME if the port dies on us what happens FIXME Under Windows sometimes the error code 87 (ERROR_INVALID_PARAMETER) is returned. it has not been not investigated why but this appears to work int res = WaitForSingleObject(wobj[0], tout); work around the fact that sometimes we miss events it was the cancel sema4 so just return  long T1 = System.currentTimeMillis(); System.err.println("select() " + (T1 - T0)); This is a bit pointless function as Windows baudrate constants are just the baudrates so basically this is a no-op, it returns what it gets Note this assumes that the Bxxxx constants in JTermios have the default values ie the values are the baudrates. should never happen pipe() not implemented on Windows backend