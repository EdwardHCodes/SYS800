*******************************************************************
 *                                                                  *
 * THIS FILE IS PART OF THE OggVorbis 'TREMOR' CODEC SOURCE CODE.   *
 *                                                                  *
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
 *                                                                  *
 * THE OggVorbis 'TREMOR' SOURCE CODE IS (C) COPYRIGHT 1994-2003    *
 * BY THE Xiph.Org FOUNDATION http://www.xiph.org/                  *
 *                                                                  *
 ********************************************************************

 function: stdio-based convenience library for opening/seeking/decoding
 last mod: $Id$

 ******************************************************************* A 'chained bitstream' is a Vorbis bitstream that contains more than
   one logical bitstream arranged end to end (the only form of Ogg
   multiplexing allowed in a Vorbis bitstream; grouping [parallel
   multiplexing] is not allowed in Vorbis)  A Vorbis file can be played beginning to end (streamed) without
   worrying ahead of time about chaining (see decoder_example.c).  If
   we have the whole file, however, and want random access
   (seeking/scrubbing) or desire to know the total length/time of a
   file, we need to account for the possibility of chaining.  We can handle things a number of ways; we can determine the entire
   bitstream structure right off the bat, or find pieces on demand.
   This example determines and caches structure for the entire
   bitstream, but builds a virtual decoder on the fly when moving
   between links in the chain.  There are also different ways to implement seeking.  Enough
   information exists in an Ogg bitstream to seek to
   sample-granularity positions in the output.  Or, one can seek by
   picking some portion of the stream roughly in the desired area if
   we only want coarse navigation through the stream. ************************************************************************
 * Many, many internal helpers.  The intention is not to be confusing;
 * rampant duplication and monolithic function implementation would be
 * harder to understand anyway.  The high level functions are last.  Begin
 * grokking near the end of the file  read a little more data from the file/pipe into the ogg_sync framer  save a tiny smidge of verbosity to make the code more readable  shouldn't happen unless someone writes a broken callback  The read/seek functions track absolute position within the stream  from the head of the stream, get the next page.  boundary specifies
   if the function is allowed to fetch more data from the stream (and
   how much) or only use internally buffered data.

   boundary: -1) unbounded search
              0) read no additional data; use cached only
              n) search for a new page beginning for n bytes

   return:   <0) did not find a page (OV_FALSE, OV_EOF, OV_EREAD)
              n) found a page at absolute offset n  skipped n bytes  send more paramedics  got a page.  Return the offset at the page beginning,
           advance the internal offset past the page end  This is a nasty hack to work around the huge allocations we get from
   huge comment packets, usually due to embedded album art  We might be pretending to have filled in more of the buffer than there is
     actual space, in this case the body storage must be expanded before we
     start writing to it  find the latest page beginning before the current stream cursor
   position. Much dirtier than the above as Ogg doesn't have any
   backward search linkage.  no 'readp' as it will certainly have to
   read.  returns offset or OV_EREAD, OV_FAULT  In a fully compliant, non-multiplexed stream, we'll still be
     holding the last page.  In multiplexed (or noncompliant streams),
     we will probably have to re-read the last page we saw  this shouldn't be possible  returns nonzero if found  performs the same search as _get_prev_page, but prefers pages of
   the specified serial number. If a page of the specified serialno is
   spotted during the seek-back-and-read-forward, it will return the
   info of last page of the matching serial number instead of the very
   last page.  If no page of the specified serialno is seen, it will
   return the info of last page and alter *serialno.   we fell off the end of the link, which means we seeked
             back too far and shouldn't have been looking in that link
             to begin with.  If we found the preferred serial number,
             forget that we saw it.  we're not interested in the page... just the serialno and granpos.  uses the local ogg_stream storage in vf; this is important for
   non-streaming input sources   vorbis_comment_init(vc);  extract the serialnos of all BOS pages + the first set of vorbis
     headers we see in the link  a dupe serialnumber in an initial header packet set == invalid stream  we don't have a vorbis stream in this link yet, so begin
         prospective stream setup. We need a stream to get packets  vorbis header; continue setup  get next page  if this page also belongs to our vorbis stream, submit it and break  discard comment packet  get a page loop  get a packet loop  if this page belongs to the correct stream, go parse it  if we never see the final vorbis headers before the link
           ends, abort  otherwise, keep looking   vorbis_comment_clear(vc);  Starting from current cursor position, get initial PCM offset of
   next page.  Consumes the page in the process without decoding
   audio, however this is only called during stream parsing upon
   seekable open.  should not be possible unless the file is truncated/mangled  count blocksizes of all frames in the page  ignore holes  pcm offset of last packet on the first audio page  less than zero?  This is a stream with samples trimmed off
     the beginning, a normal occurrence; set the offset to zero  finds each bitstream link one at a time using a bisection search
   (has to begin by knowing the offset of the lb's initial page).
   Recurses for each link so it can alloc the link storage after
   finding them all, then unroll and fill the cache at the same time  invariants:
     we have the headers and serialnos for the link beginning at 'begin'
     we have the offset and granpos of the last page in the file (potentially
       not a page we care about)
   Is the last page in our list of current serialnumbers?  last page is in the starting serialno list, so we've bisected
       down to (or just started with) a single link.  Now we need to
       find the last vorbis page belonging to the first vorbis stream
       for this link.     vf->vc=_ogg_realloc(vf->vc,vf->links*sizeof(*vf->vc));    vorbis_comment vc;  the below guards against garbage seperating the last and
       first pages of two links.  Bisection point found  for the time being, fetch end PCM offset the simple way  this will consume a page, however the next bistection always
       starts with a raw seek     vf->vc[m+1]=vc;  we're partially open and have a first link header state in
     storage in vf  fetch initial PCM offset  we can seek, so set out learning all about this file  If seek_func is implemented, tell_func must also be implemented  Get the offset of the last page of the physical bitstream, or, if
     we're lucky the last vorbis page of this link as most OggVorbis
     files will contain a single logical bitstream  now determine bitstream structure recursively  clear out the current logical bitstream decoder  fetch and process a packet.  Handles the case where we're at a
   bitstream boundary and dumps the decoding machine.  If the decoding
   machine is unloaded, it loads it.  It also keeps pcm_offset up to
   date (seek and read both use this.  seek uses a special hack with
   readp).

   return: <0) error, OV_HOLE (lost packet) or OV_EOF
            0) need more data (only if readp==0)
            1) got a packet
 handle one packet.  Try to fetch it from current stream state  extract packets from page  process a packet if we can.  If the machine isn't loaded,
       neither is a page  hole in the data.  got a packet.  process it  lazy check for lazy
                                                    header handling.  The
                                                    header packets aren't
                                                    audio, so if/when we
                                                    submit them,
                                                    vorbis_synthesis will
                                                    reject them  suck in the synthesis data and track bitrate  for proper use of libvorbis within libvorbisfile,
                 oldsamples will always be zero.  update the pcm offset.  this packet has a pcm_offset on it (the last packet
                 completed on a page carries the offset) After processing
                 (above), we know the pcm position of the *last* sample
                 ready to be returned. Find the offset of the *first*

                 As an aside, this trick is inaccurate if we begin
                 reading anew right at the last page; the end-of-stream
                 granulepos declares the last frame in the stream, and the
                 last packet of the last page may be a partial frame.
                 So, we need a previous granulepos from an in-sequence page
                 to have a reference point.  Thus the !op_ptr->e_o_s clause
                 above  actually, this
                                               shouldn't be possible
                                               here unless the stream
                                               is very broken  the loop is not strictly necessary, but there's no sense in
           doing the extra checks of the larger loop for the common
           case in a multiplexed bistream where the page is simply
           part of a different logical bitstream; keep reading until
           we get one with the correct serialno  eof. leave unitialized  bitrate tracking; add the header's bytes here, the body bytes
           are done by packet above  two possibilities:
               1) our decoding just traversed a bitstream boundary
               2) another stream is multiplexed into this logical section  boundary case                 vorbis_comment_clear(vf->vc);  possibility #2  Do we need to load a new machine before submitting the page?  This is different in the seekable and non-seekable cases.

       In the seekable case, we already have all the header
       information loaded and cached; we just initialize the machine
       with it and continue on our merry way.

       In the non-seekable (streaming) case, we'll only be at a
       boundary if we just left the previous logical bitstream and
       we're now nominally at the header of the next bitstream
     match the serialno to bitstream section.  We use this rather than
             offset positions to avoid problems near logical bitstream
             boundaries  not the desired Vorbis
                                           bitstream section; keep
                                           trying  we're streaming  fetch the three header packets, build the info struct  the buffered page is the data we want, and we're ready for it;
       add it to the stream state  init the framing state  perhaps some data was previously read into a buffer for testing
     against other stream types.  Allow initialization from this
     previously read data (especially as we may be reading from a
     non-seekable stream)  can we seek? Stevens suggests the seek test was portable  No seeking yet; Set up a 'single' (current) logical bitstream
     entry for partial open   vf->vc=_ogg_calloc(vf->links,sizeof(*vf->vc));  fill in the serialno later  Fetch all BOS pages, store the vorbis header and all seen serial
     numbers, load subsequent vorbis setup headers  serial number list for first link needs to be held somewhere
       for second stage of seekable stream open; this saves having to
       seek/reread first link's serialnumber data then.  clear out the OggVorbis_File struct         vorbis_comment_clear(vf->vc+i);       _ogg_free(vf->vc);  inspects the OggVorbis file and finds/documents all the logical
   bitstreams contained in it.  Tries to be tolerant of logical
   bitstream sections that are truncated/woogie.

   return: -1) error
            0) OK
 this seems to be the closest we get to an init function, let's init emac
     here. rounding is disabled because of MULT31_SHIFT15, which will be
     inaccurate with rounding in its current incarnation  returns: total PCM length (samples) of content if i==-1 PCM length
            (samples) of that logical bitstream for i==0 to n
            OV_EINVAL if the stream is not seekable (we can't know the
            length) or only partially open 
 returns: total milliseconds of content if i==-1
            milliseconds in that logical bitstream for i==0 to n
            OV_EINVAL if the stream is not seekable (we can't know the
            length) or only partially open 
 seek to an offset relative to the *compressed* data. This also
   scans packets to update the PCM cursor. It will cross a logical
   bitstream boundary, but only if it can't get any packets out of the
   tail of the bitstream we seek to (so no surprises).

   returns zero on success, nonzero on failure  don't dump machine if we can't seek  is the seek position outside our current link [if any]?  clear out stream state  don't yet clear out decoding machine (if it's initialized), in
     the case we're in the same link.  Restart the decode lapping, and
     let _fetch_and_process_packet deal with a potential bitstream
     boundary  must set serialno  we need to make sure the pcm_offset is set, but we don't want to
     advance the raw cursor past good packets just to get to the first
     with a granulepos.  That's not equivalent behavior to beginning
     decoding as immediately after the seek position as possible.

     So, a hack.  We use two stream states; a local scratch state and
     the shared vf->os stream state.  We use the local state to
     scan, and the shared state as a buffer for later decode.

     Unfortuantely, on the last page we still advance to last packet
     because the granulepos on the last page is not necessarily on a
     packet boundary, and we need to make sure the granpos is
     correct.
   get the memory ready  eliminate the spurious OV_HOLE
                                   return from not necessarily
                                   starting from the beginning  snarf/scan a packet if we can  We can't get a guaranteed correct pcm position out of the
                 last page in a stream because it might have a 'short'
                 granpos, which can only be detected in the presence of a
                 preceding page.  However, if the last page is also the first
                 page, the granpos rules of a first page take precedence.  Not
                 only that, but for first==last, the EOS page must be treated
                 as if its a normal first page for the stream to open/play.  huh?  Bogus stream with packets but no granulepos  has our decoding just traversed a bitstream boundary?  two possibilities:
             1) our decoding just traversed a bitstream boundary
             2) another stream is multiplexed into this logical section?  we traversed  clear out stream state  else, do nothing; next loop will scoop another page  not the desired Vorbis
                                         bitstream section; keep
                                         trying  dump the machine so we're in a known state  rescales the number x from the range of [0,from] to [0,to]
   x is in the range [0,from]
   from, to are in the range [1, 1<<62-1]  Page granularity seek (faster than sample granularity because we
   don't do the last bit of decode to find a specific sample).

   Seek to the last [granule marked] page preceding the specified pos
   location, such that decoding past the returned point will quickly
   arrive at the requested position.  which bitstream section does this pcm offset occur in?  search within the logical bitstream for the page with the highest
     pcm_pos preceding (or equal to) pos.  There is a danger here;
     missing pages or incorrect frame number information in the
     bitstream could make our task impossible.  Account for that (it
     would be an error condition)  new search algorithm by HB (Nicholas Vinen)  take a (pretty decent) guess.  found it  raw offset of packet with granulepos  raw offset of next page  *not* begin + 1  found it  we're pretty close - we'd be stuck in  an endless loop otherwise.  found our page. seek to it, update pcm offset. Easier case than
       raw_seek, don't keep packets preceding granulepos.  seek  Different link; dump entire decode machine  pull out all but last packet; the one with granulepos  !!! the packet finishing this page originated on a
             preceding page. Keep fetching previous pages until we
             get one with a granulepos or without the 'continued' flag
             set.  Then just use raw_seek for simplicity.  verify result  dump machine so we're in a known state  seek to a sample offset relative to the decompressed pcm stream
   returns zero on success, nonzero on failure  discard leading packets we don't need for the lapping of the
     position we want; don't decode them  non audio packet  remove the packet from packet queue and track its granulepos  set up a vb with
                                                   only tracking, no
                                                   pcm_decode  end of logical stream case is hard, especially with exact
         length positioning.  always believe the stream markers  suck in a new page  discard samples until we reach the desired position. Crossing a
     logical bitstream boundary with abandon is OK.  eof  seek to a playback time relative to the decompressed pcm stream
   returns zero on success, nonzero on failure  translate time to PCM position and call ov_pcm_seek  which bitstream section does this time offset occur in?  enough information to convert time offset to pcm offset  tell the current stream offset cursor.  Note that seek followed by
   tell will likely not give the set offset due to caching  return time offset (milliseconds) of next PCM sample to be read  which bitstream section does this time offset occur in?   link:   -1) return the vorbis_info struct for the bitstream section
                currently being decoded
           0-n) to request information for a specific bitstream section

    In the case of a non-seekable bitstream, any call returns the
    current bitstream.  NULL in the case that the machine is not
    initialized  input values: pcm_channels) a float vector per channel of output
                length) the sample length being read by the app

   return values: <0) error/hole in data (OV_HOLE), partial open (OV_EINVAL)
                   0) EOF
                  n) number of samples of PCM actually returned.  The
                  below works on a packet-by-packet basis, so the
                  return length is not related to the 'length' passed
                  in, just guaranteed to fit.

           *section) set to the logical bitstream number  suck in another packet *******************************************************************
 *                                                                  *
 * THIS FILE IS PART OF THE OggVorbis 'TREMOR' CODEC SOURCE CODE.   *
 *                                                                  *
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
 *                                                                  *
 * THE OggVorbis 'TREMOR' SOURCE CODE IS (C) COPYRIGHT 1994-2003    *
 * BY THE Xiph.Org FOUNDATION http://www.xiph.org/                  *
 *                                                                  *
 ********************************************************************

 function: stdio-based convenience library for opening/seeking/decoding
 last mod: $Id$

 ******************************************************************* A 'chained bitstream' is a Vorbis bitstream that contains more than
   one logical bitstream arranged end to end (the only form of Ogg
   multiplexing allowed in a Vorbis bitstream; grouping [parallel
   multiplexing] is not allowed in Vorbis)  A Vorbis file can be played beginning to end (streamed) without
   worrying ahead of time about chaining (see decoder_example.c).  If
   we have the whole file, however, and want random access
   (seeking/scrubbing) or desire to know the total length/time of a
   file, we need to account for the possibility of chaining.  We can handle things a number of ways; we can determine the entire
   bitstream structure right off the bat, or find pieces on demand.
   This example determines and caches structure for the entire
   bitstream, but builds a virtual decoder on the fly when moving
   between links in the chain.  There are also different ways to implement seeking.  Enough
   information exists in an Ogg bitstream to seek to
   sample-granularity positions in the output.  Or, one can seek by
   picking some portion of the stream roughly in the desired area if
   we only want coarse navigation through the stream. ************************************************************************
 * Many, many internal helpers.  The intention is not to be confusing;
 * rampant duplication and monolithic function implementation would be
 * harder to understand anyway.  The high level functions are last.  Begin
 * grokking near the end of the file  read a little more data from the file/pipe into the ogg_sync framer  save a tiny smidge of verbosity to make the code more readable  shouldn't happen unless someone writes a broken callback  The read/seek functions track absolute position within the stream  from the head of the stream, get the next page.  boundary specifies
   if the function is allowed to fetch more data from the stream (and
   how much) or only use internally buffered data.

   boundary: -1) unbounded search
              0) read no additional data; use cached only
              n) search for a new page beginning for n bytes

   return:   <0) did not find a page (OV_FALSE, OV_EOF, OV_EREAD)
              n) found a page at absolute offset n  skipped n bytes  send more paramedics  got a page.  Return the offset at the page beginning,
           advance the internal offset past the page end  This is a nasty hack to work around the huge allocations we get from
   huge comment packets, usually due to embedded album art  We might be pretending to have filled in more of the buffer than there is
     actual space, in this case the body storage must be expanded before we
     start writing to it  find the latest page beginning before the current stream cursor
   position. Much dirtier than the above as Ogg doesn't have any
   backward search linkage.  no 'readp' as it will certainly have to
   read.  returns offset or OV_EREAD, OV_FAULT  In a fully compliant, non-multiplexed stream, we'll still be
     holding the last page.  In multiplexed (or noncompliant streams),
     we will probably have to re-read the last page we saw  this shouldn't be possible  returns nonzero if found  performs the same search as _get_prev_page, but prefers pages of
   the specified serial number. If a page of the specified serialno is
   spotted during the seek-back-and-read-forward, it will return the
   info of last page of the matching serial number instead of the very
   last page.  If no page of the specified serialno is seen, it will
   return the info of last page and alter *serialno.   we fell off the end of the link, which means we seeked
             back too far and shouldn't have been looking in that link
             to begin with.  If we found the preferred serial number,
             forget that we saw it.  we're not interested in the page... just the serialno and granpos.  uses the local ogg_stream storage in vf; this is important for
   non-streaming input sources   vorbis_comment_init(vc);  extract the serialnos of all BOS pages + the first set of vorbis
     headers we see in the link  a dupe serialnumber in an initial header packet set == invalid stream  we don't have a vorbis stream in this link yet, so begin
         prospective stream setup. We need a stream to get packets  vorbis header; continue setup  get next page  if this page also belongs to our vorbis stream, submit it and break  discard comment packet  get a page loop  get a packet loop  if this page belongs to the correct stream, go parse it  if we never see the final vorbis headers before the link
           ends, abort  otherwise, keep looking   vorbis_comment_clear(vc);  Starting from current cursor position, get initial PCM offset of
   next page.  Consumes the page in the process without decoding
   audio, however this is only called during stream parsing upon
   seekable open.  should not be possible unless the file is truncated/mangled  count blocksizes of all frames in the page  ignore holes  pcm offset of last packet on the first audio page  less than zero?  This is a stream with samples trimmed off
     the beginning, a normal occurrence; set the offset to zero  finds each bitstream link one at a time using a bisection search
   (has to begin by knowing the offset of the lb's initial page).
   Recurses for each link so it can alloc the link storage after
   finding them all, then unroll and fill the cache at the same time  invariants:
     we have the headers and serialnos for the link beginning at 'begin'
     we have the offset and granpos of the last page in the file (potentially
       not a page we care about)
   Is the last page in our list of current serialnumbers?  last page is in the starting serialno list, so we've bisected
       down to (or just started with) a single link.  Now we need to
       find the last vorbis page belonging to the first vorbis stream
       for this link.     vf->vc=_ogg_realloc(vf->vc,vf->links*sizeof(*vf->vc));    vorbis_comment vc;  the below guards against garbage seperating the last and
       first pages of two links.  Bisection point found  for the time being, fetch end PCM offset the simple way  this will consume a page, however the next bistection always
       starts with a raw seek     vf->vc[m+1]=vc;  we're partially open and have a first link header state in
     storage in vf  fetch initial PCM offset  we can seek, so set out learning all about this file  If seek_func is implemented, tell_func must also be implemented  Get the offset of the last page of the physical bitstream, or, if
     we're lucky the last vorbis page of this link as most OggVorbis
     files will contain a single logical bitstream  now determine bitstream structure recursively  clear out the current logical bitstream decoder  fetch and process a packet.  Handles the case where we're at a
   bitstream boundary and dumps the decoding machine.  If the decoding
   machine is unloaded, it loads it.  It also keeps pcm_offset up to
   date (seek and read both use this.  seek uses a special hack with
   readp).

   return: <0) error, OV_HOLE (lost packet) or OV_EOF
            0) need more data (only if readp==0)
            1) got a packet
 handle one packet.  Try to fetch it from current stream state  extract packets from page  process a packet if we can.  If the machine isn't loaded,
       neither is a page  hole in the data.  got a packet.  process it  lazy check for lazy
                                                    header handling.  The
                                                    header packets aren't
                                                    audio, so if/when we
                                                    submit them,
                                                    vorbis_synthesis will
                                                    reject them  suck in the synthesis data and track bitrate  for proper use of libvorbis within libvorbisfile,
                 oldsamples will always be zero.  update the pcm offset.  this packet has a pcm_offset on it (the last packet
                 completed on a page carries the offset) After processing
                 (above), we know the pcm position of the *last* sample
                 ready to be returned. Find the offset of the *first*

                 As an aside, this trick is inaccurate if we begin
                 reading anew right at the last page; the end-of-stream
                 granulepos declares the last frame in the stream, and the
                 last packet of the last page may be a partial frame.
                 So, we need a previous granulepos from an in-sequence page
                 to have a reference point.  Thus the !op_ptr->e_o_s clause
                 above  actually, this
                                               shouldn't be possible
                                               here unless the stream
                                               is very broken  the loop is not strictly necessary, but there's no sense in
           doing the extra checks of the larger loop for the common
           case in a multiplexed bistream where the page is simply
           part of a different logical bitstream; keep reading until
           we get one with the correct serialno  eof. leave unitialized  bitrate tracking; add the header's bytes here, the body bytes
           are done by packet above  two possibilities:
               1) our decoding just traversed a bitstream boundary
               2) another stream is multiplexed into this logical section  boundary case                 vorbis_comment_clear(vf->vc);  possibility #2  Do we need to load a new machine before submitting the page?  This is different in the seekable and non-seekable cases.

       In the seekable case, we already have all the header
       information loaded and cached; we just initialize the machine
       with it and continue on our merry way.

       In the non-seekable (streaming) case, we'll only be at a
       boundary if we just left the previous logical bitstream and
       we're now nominally at the header of the next bitstream
     match the serialno to bitstream section.  We use this rather than
             offset positions to avoid problems near logical bitstream
             boundaries  not the desired Vorbis
                                           bitstream section; keep
                                           trying  we're streaming  fetch the three header packets, build the info struct  the buffered page is the data we want, and we're ready for it;
       add it to the stream state  init the framing state  perhaps some data was previously read into a buffer for testing
     against other stream types.  Allow initialization from this
     previously read data (especially as we may be reading from a
     non-seekable stream)  can we seek? Stevens suggests the seek test was portable  No seeking yet; Set up a 'single' (current) logical bitstream
     entry for partial open   vf->vc=_ogg_calloc(vf->links,sizeof(*vf->vc));  fill in the serialno later  Fetch all BOS pages, store the vorbis header and all seen serial
     numbers, load subsequent vorbis setup headers  serial number list for first link needs to be held somewhere
       for second stage of seekable stream open; this saves having to
       seek/reread first link's serialnumber data then.  clear out the OggVorbis_File struct         vorbis_comment_clear(vf->vc+i);       _ogg_free(vf->vc);  inspects the OggVorbis file and finds/documents all the logical
   bitstreams contained in it.  Tries to be tolerant of logical
   bitstream sections that are truncated/woogie.

   return: -1) error
            0) OK
 this seems to be the closest we get to an init function, let's init emac
     here. rounding is disabled because of MULT31_SHIFT15, which will be
     inaccurate with rounding in its current incarnation  returns: total PCM length (samples) of content if i==-1 PCM length
            (samples) of that logical bitstream for i==0 to n
            OV_EINVAL if the stream is not seekable (we can't know the
            length) or only partially open 
 returns: total milliseconds of content if i==-1
            milliseconds in that logical bitstream for i==0 to n
            OV_EINVAL if the stream is not seekable (we can't know the
            length) or only partially open 
 seek to an offset relative to the *compressed* data. This also
   scans packets to update the PCM cursor. It will cross a logical
   bitstream boundary, but only if it can't get any packets out of the
   tail of the bitstream we seek to (so no surprises).

   returns zero on success, nonzero on failure  don't dump machine if we can't seek  is the seek position outside our current link [if any]?  clear out stream state  don't yet clear out decoding machine (if it's initialized), in
     the case we're in the same link.  Restart the decode lapping, and
     let _fetch_and_process_packet deal with a potential bitstream
     boundary  must set serialno  we need to make sure the pcm_offset is set, but we don't want to
     advance the raw cursor past good packets just to get to the first
     with a granulepos.  That's not equivalent behavior to beginning
     decoding as immediately after the seek position as possible.

     So, a hack.  We use two stream states; a local scratch state and
     the shared vf->os stream state.  We use the local state to
     scan, and the shared state as a buffer for later decode.

     Unfortuantely, on the last page we still advance to last packet
     because the granulepos on the last page is not necessarily on a
     packet boundary, and we need to make sure the granpos is
     correct.
   get the memory ready  eliminate the spurious OV_HOLE
                                   return from not necessarily
                                   starting from the beginning  snarf/scan a packet if we can  We can't get a guaranteed correct pcm position out of the
                 last page in a stream because it might have a 'short'
                 granpos, which can only be detected in the presence of a
                 preceding page.  However, if the last page is also the first
                 page, the granpos rules of a first page take precedence.  Not
                 only that, but for first==last, the EOS page must be treated
                 as if its a normal first page for the stream to open/play.  huh?  Bogus stream with packets but no granulepos  has our decoding just traversed a bitstream boundary?  two possibilities:
             1) our decoding just traversed a bitstream boundary
             2) another stream is multiplexed into this logical section?  we traversed  clear out stream state  else, do nothing; next loop will scoop another page  not the desired Vorbis
                                         bitstream section; keep
                                         trying  dump the machine so we're in a known state  rescales the number x from the range of [0,from] to [0,to]
   x is in the range [0,from]
   from, to are in the range [1, 1<<62-1]  Page granularity seek (faster than sample granularity because we
   don't do the last bit of decode to find a specific sample).

   Seek to the last [granule marked] page preceding the specified pos
   location, such that decoding past the returned point will quickly
   arrive at the requested position.  which bitstream section does this pcm offset occur in?  search within the logical bitstream for the page with the highest
     pcm_pos preceding (or equal to) pos.  There is a danger here;
     missing pages or incorrect frame number information in the
     bitstream could make our task impossible.  Account for that (it
     would be an error condition)  new search algorithm by HB (Nicholas Vinen)  take a (pretty decent) guess.  found it  raw offset of packet with granulepos  raw offset of next page  *not* begin + 1  found it  we're pretty close - we'd be stuck in  an endless loop otherwise.  found our page. seek to it, update pcm offset. Easier case than
       raw_seek, don't keep packets preceding granulepos.  seek  Different link; dump entire decode machine  pull out all but last packet; the one with granulepos  !!! the packet finishing this page originated on a
             preceding page. Keep fetching previous pages until we
             get one with a granulepos or without the 'continued' flag
             set.  Then just use raw_seek for simplicity.  verify result  dump machine so we're in a known state  seek to a sample offset relative to the decompressed pcm stream
   returns zero on success, nonzero on failure  discard leading packets we don't need for the lapping of the
     position we want; don't decode them  non audio packet  remove the packet from packet queue and track its granulepos  set up a vb with
                                                   only tracking, no
                                                   pcm_decode  end of logical stream case is hard, especially with exact
         length positioning.  always believe the stream markers  suck in a new page  discard samples until we reach the desired position. Crossing a
     logical bitstream boundary with abandon is OK.  eof  seek to a playback time relative to the decompressed pcm stream
   returns zero on success, nonzero on failure  translate time to PCM position and call ov_pcm_seek  which bitstream section does this time offset occur in?  enough information to convert time offset to pcm offset  tell the current stream offset cursor.  Note that seek followed by
   tell will likely not give the set offset due to caching  return time offset (milliseconds) of next PCM sample to be read  which bitstream section does this time offset occur in?   link:   -1) return the vorbis_info struct for the bitstream section
                currently being decoded
           0-n) to request information for a specific bitstream section

    In the case of a non-seekable bitstream, any call returns the
    current bitstream.  NULL in the case that the machine is not
    initialized  input values: pcm_channels) a float vector per channel of output
                length) the sample length being read by the app

   return values: <0) error/hole in data (OV_HOLE), partial open (OV_EINVAL)
                   0) EOF
                  n) number of samples of PCM actually returned.  The
                  below works on a packet-by-packet basis, so the
                  return length is not related to the 'length' passed
                  in, just guaranteed to fit.

           *section) set to the logical bitstream number  suck in another packet *******************************************************************
 *                                                                  *
 * THIS FILE IS PART OF THE OggVorbis 'TREMOR' CODEC SOURCE CODE.   *
 *                                                                  *
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
 *                                                                  *
 * THE OggVorbis 'TREMOR' SOURCE CODE IS (C) COPYRIGHT 1994-2003    *
 * BY THE Xiph.Org FOUNDATION http://www.xiph.org/                  *
 *                                                                  *
 ********************************************************************

 function: stdio-based convenience library for opening/seeking/decoding
 last mod: $Id$

 ******************************************************************* A 'chained bitstream' is a Vorbis bitstream that contains more than
   one logical bitstream arranged end to end (the only form of Ogg
   multiplexing allowed in a Vorbis bitstream; grouping [parallel
   multiplexing] is not allowed in Vorbis)  A Vorbis file can be played beginning to end (streamed) without
   worrying ahead of time about chaining (see decoder_example.c).  If
   we have the whole file, however, and want random access
   (seeking/scrubbing) or desire to know the total length/time of a
   file, we need to account for the possibility of chaining.  We can handle things a number of ways; we can determine the entire
   bitstream structure right off the bat, or find pieces on demand.
   This example determines and caches structure for the entire
   bitstream, but builds a virtual decoder on the fly when moving
   between links in the chain.  There are also different ways to implement seeking.  Enough
   information exists in an Ogg bitstream to seek to
   sample-granularity positions in the output.  Or, one can seek by
   picking some portion of the stream roughly in the desired area if
   we only want coarse navigation through the stream. ************************************************************************
 * Many, many internal helpers.  The intention is not to be confusing;
 * rampant duplication and monolithic function implementation would be
 * harder to understand anyway.  The high level functions are last.  Begin
 * grokking near the end of the file  read a little more data from the file/pipe into the ogg_sync framer  save a tiny smidge of verbosity to make the code more readable  shouldn't happen unless someone writes a broken callback  The read/seek functions track absolute position within the stream  from the head of the stream, get the next page.  boundary specifies
   if the function is allowed to fetch more data from the stream (and
   how much) or only use internally buffered data.

   boundary: -1) unbounded search
              0) read no additional data; use cached only
              n) search for a new page beginning for n bytes

   return:   <0) did not find a page (OV_FALSE, OV_EOF, OV_EREAD)
              n) found a page at absolute offset n  skipped n bytes  send more paramedics  got a page.  Return the offset at the page beginning,
           advance the internal offset past the page end  This is a nasty hack to work around the huge allocations we get from
   huge comment packets, usually due to embedded album art  We might be pretending to have filled in more of the buffer than there is
     actual space, in this case the body storage must be expanded before we
     start writing to it  find the latest page beginning before the current stream cursor
   position. Much dirtier than the above as Ogg doesn't have any
   backward search linkage.  no 'readp' as it will certainly have to
   read.  returns offset or OV_EREAD, OV_FAULT  In a fully compliant, non-multiplexed stream, we'll still be
     holding the last page.  In multiplexed (or noncompliant streams),
     we will probably have to re-read the last page we saw  this shouldn't be possible  returns nonzero if found  performs the same search as _get_prev_page, but prefers pages of
   the specified serial number. If a page of the specified serialno is
   spotted during the seek-back-and-read-forward, it will return the
   info of last page of the matching serial number instead of the very
   last page.  If no page of the specified serialno is seen, it will
   return the info of last page and alter *serialno.   we fell off the end of the link, which means we seeked
             back too far and shouldn't have been looking in that link
             to begin with.  If we found the preferred serial number,
             forget that we saw it.  we're not interested in the page... just the serialno and granpos.  uses the local ogg_stream storage in vf; this is important for
   non-streaming input sources   vorbis_comment_init(vc);  extract the serialnos of all BOS pages + the first set of vorbis
     headers we see in the link  a dupe serialnumber in an initial header packet set == invalid stream  we don't have a vorbis stream in this link yet, so begin
         prospective stream setup. We need a stream to get packets  vorbis header; continue setup  get next page  if this page also belongs to our vorbis stream, submit it and break  discard comment packet  get a page loop  get a packet loop  if this page belongs to the correct stream, go parse it  if we never see the final vorbis headers before the link
           ends, abort  otherwise, keep looking   vorbis_comment_clear(vc);  Starting from current cursor position, get initial PCM offset of
   next page.  Consumes the page in the process without decoding
   audio, however this is only called during stream parsing upon
   seekable open.  should not be possible unless the file is truncated/mangled  count blocksizes of all frames in the page  ignore holes  pcm offset of last packet on the first audio page  less than zero?  This is a stream with samples trimmed off
     the beginning, a normal occurrence; set the offset to zero  finds each bitstream link one at a time using a bisection search
   (has to begin by knowing the offset of the lb's initial page).
   Recurses for each link so it can alloc the link storage after
   finding them all, then unroll and fill the cache at the same time  invariants:
     we have the headers and serialnos for the link beginning at 'begin'
     we have the offset and granpos of the last page in the file (potentially
       not a page we care about)
   Is the last page in our list of current serialnumbers?  last page is in the starting serialno list, so we've bisected
       down to (or just started with) a single link.  Now we need to
       find the last vorbis page belonging to the first vorbis stream
       for this link.     vf->vc=_ogg_realloc(vf->vc,vf->links*sizeof(*vf->vc));    vorbis_comment vc;  the below guards against garbage seperating the last and
       first pages of two links.  Bisection point found  for the time being, fetch end PCM offset the simple way  this will consume a page, however the next bistection always
       starts with a raw seek     vf->vc[m+1]=vc;  we're partially open and have a first link header state in
     storage in vf  fetch initial PCM offset  we can seek, so set out learning all about this file  If seek_func is implemented, tell_func must also be implemented  Get the offset of the last page of the physical bitstream, or, if
     we're lucky the last vorbis page of this link as most OggVorbis
     files will contain a single logical bitstream  now determine bitstream structure recursively  clear out the current logical bitstream decoder  fetch and process a packet.  Handles the case where we're at a
   bitstream boundary and dumps the decoding machine.  If the decoding
   machine is unloaded, it loads it.  It also keeps pcm_offset up to
   date (seek and read both use this.  seek uses a special hack with
   readp).

   return: <0) error, OV_HOLE (lost packet) or OV_EOF
            0) need more data (only if readp==0)
            1) got a packet
 handle one packet.  Try to fetch it from current stream state  extract packets from page  process a packet if we can.  If the machine isn't loaded,
       neither is a page  hole in the data.  got a packet.  process it  lazy check for lazy
                                                    header handling.  The
                                                    header packets aren't
                                                    audio, so if/when we
                                                    submit them,
                                                    vorbis_synthesis will
                                                    reject them  suck in the synthesis data and track bitrate  for proper use of libvorbis within libvorbisfile,
                 oldsamples will always be zero.  update the pcm offset.  this packet has a pcm_offset on it (the last packet
                 completed on a page carries the offset) After processing
                 (above), we know the pcm position of the *last* sample
                 ready to be returned. Find the offset of the *first*

                 As an aside, this trick is inaccurate if we begin
                 reading anew right at the last page; the end-of-stream
                 granulepos declares the last frame in the stream, and the
                 last packet of the last page may be a partial frame.
                 So, we need a previous granulepos from an in-sequence page
                 to have a reference point.  Thus the !op_ptr->e_o_s clause
                 above  actually, this
                                               shouldn't be possible
                                               here unless the stream
                                               is very broken  the loop is not strictly necessary, but there's no sense in
           doing the extra checks of the larger loop for the common
           case in a multiplexed bistream where the page is simply
           part of a different logical bitstream; keep reading until
           we get one with the correct serialno  eof. leave unitialized  bitrate tracking; add the header's bytes here, the body bytes
           are done by packet above  two possibilities:
               1) our decoding just traversed a bitstream boundary
               2) another stream is multiplexed into this logical section  boundary case                 vorbis_comment_clear(vf->vc);  possibility #2  Do we need to load a new machine before submitting the page?  This is different in the seekable and non-seekable cases.

       In the seekable case, we already have all the header
       information loaded and cached; we just initialize the machine
       with it and continue on our merry way.

       In the non-seekable (streaming) case, we'll only be at a
       boundary if we just left the previous logical bitstream and
       we're now nominally at the header of the next bitstream
     match the serialno to bitstream section.  We use this rather than
             offset positions to avoid problems near logical bitstream
             boundaries  not the desired Vorbis
                                           bitstream section; keep
                                           trying  we're streaming  fetch the three header packets, build the info struct  the buffered page is the data we want, and we're ready for it;
       add it to the stream state  init the framing state  perhaps some data was previously read into a buffer for testing
     against other stream types.  Allow initialization from this
     previously read data (especially as we may be reading from a
     non-seekable stream)  can we seek? Stevens suggests the seek test was portable  No seeking yet; Set up a 'single' (current) logical bitstream
     entry for partial open   vf->vc=_ogg_calloc(vf->links,sizeof(*vf->vc));  fill in the serialno later  Fetch all BOS pages, store the vorbis header and all seen serial
     numbers, load subsequent vorbis setup headers  serial number list for first link needs to be held somewhere
       for second stage of seekable stream open; this saves having to
       seek/reread first link's serialnumber data then.  clear out the OggVorbis_File struct         vorbis_comment_clear(vf->vc+i);       _ogg_free(vf->vc);  inspects the OggVorbis file and finds/documents all the logical
   bitstreams contained in it.  Tries to be tolerant of logical
   bitstream sections that are truncated/woogie.

   return: -1) error
            0) OK
 this seems to be the closest we get to an init function, let's init emac
     here. rounding is disabled because of MULT31_SHIFT15, which will be
     inaccurate with rounding in its current incarnation  returns: total PCM length (samples) of content if i==-1 PCM length
            (samples) of that logical bitstream for i==0 to n
            OV_EINVAL if the stream is not seekable (we can't know the
            length) or only partially open 
 returns: total milliseconds of content if i==-1
            milliseconds in that logical bitstream for i==0 to n
            OV_EINVAL if the stream is not seekable (we can't know the
            length) or only partially open 
 seek to an offset relative to the *compressed* data. This also
   scans packets to update the PCM cursor. It will cross a logical
   bitstream boundary, but only if it can't get any packets out of the
   tail of the bitstream we seek to (so no surprises).

   returns zero on success, nonzero on failure  don't dump machine if we can't seek  is the seek position outside our current link [if any]?  clear out stream state  don't yet clear out decoding machine (if it's initialized), in
     the case we're in the same link.  Restart the decode lapping, and
     let _fetch_and_process_packet deal with a potential bitstream
     boundary  must set serialno  we need to make sure the pcm_offset is set, but we don't want to
     advance the raw cursor past good packets just to get to the first
     with a granulepos.  That's not equivalent behavior to beginning
     decoding as immediately after the seek position as possible.

     So, a hack.  We use two stream states; a local scratch state and
     the shared vf->os stream state.  We use the local state to
     scan, and the shared state as a buffer for later decode.

     Unfortuantely, on the last page we still advance to last packet
     because the granulepos on the last page is not necessarily on a
     packet boundary, and we need to make sure the granpos is
     correct.
   get the memory ready  eliminate the spurious OV_HOLE
                                   return from not necessarily
                                   starting from the beginning  snarf/scan a packet if we can  We can't get a guaranteed correct pcm position out of the
                 last page in a stream because it might have a 'short'
                 granpos, which can only be detected in the presence of a
                 preceding page.  However, if the last page is also the first
                 page, the granpos rules of a first page take precedence.  Not
                 only that, but for first==last, the EOS page must be treated
                 as if its a normal first page for the stream to open/play.  huh?  Bogus stream with packets but no granulepos  has our decoding just traversed a bitstream boundary?  two possibilities:
             1) our decoding just traversed a bitstream boundary
             2) another stream is multiplexed into this logical section?  we traversed  clear out stream state  else, do nothing; next loop will scoop another page  not the desired Vorbis
                                         bitstream section; keep
                                         trying  dump the machine so we're in a known state  rescales the number x from the range of [0,from] to [0,to]
   x is in the range [0,from]
   from, to are in the range [1, 1<<62-1]  Page granularity seek (faster than sample granularity because we
   don't do the last bit of decode to find a specific sample).

   Seek to the last [granule marked] page preceding the specified pos
   location, such that decoding past the returned point will quickly
   arrive at the requested position.  which bitstream section does this pcm offset occur in?  search within the logical bitstream for the page with the highest
     pcm_pos preceding (or equal to) pos.  There is a danger here;
     missing pages or incorrect frame number information in the
     bitstream could make our task impossible.  Account for that (it
     would be an error condition)  new search algorithm by HB (Nicholas Vinen)  take a (pretty decent) guess.  found it  raw offset of packet with granulepos  raw offset of next page  *not* begin + 1  found it  we're pretty close - we'd be stuck in  an endless loop otherwise.  found our page. seek to it, update pcm offset. Easier case than
       raw_seek, don't keep packets preceding granulepos.  seek  Different link; dump entire decode machine  pull out all but last packet; the one with granulepos  !!! the packet finishing this page originated on a
             preceding page. Keep fetching previous pages until we
             get one with a granulepos or without the 'continued' flag
             set.  Then just use raw_seek for simplicity.  verify result  dump machine so we're in a known state  seek to a sample offset relative to the decompressed pcm stream
   returns zero on success, nonzero on failure  discard leading packets we don't need for the lapping of the
     position we want; don't decode them  non audio packet  remove the packet from packet queue and track its granulepos  set up a vb with
                                                   only tracking, no
                                                   pcm_decode  end of logical stream case is hard, especially with exact
         length positioning.  always believe the stream markers  suck in a new page  discard samples until we reach the desired position. Crossing a
     logical bitstream boundary with abandon is OK.  eof  seek to a playback time relative to the decompressed pcm stream
   returns zero on success, nonzero on failure  translate time to PCM position and call ov_pcm_seek  which bitstream section does this time offset occur in?  enough information to convert time offset to pcm offset  tell the current stream offset cursor.  Note that seek followed by
   tell will likely not give the set offset due to caching  return time offset (milliseconds) of next PCM sample to be read  which bitstream section does this time offset occur in?   link:   -1) return the vorbis_info struct for the bitstream section
                currently being decoded
           0-n) to request information for a specific bitstream section

    In the case of a non-seekable bitstream, any call returns the
    current bitstream.  NULL in the case that the machine is not
    initialized  input values: pcm_channels) a float vector per channel of output
                length) the sample length being read by the app

   return values: <0) error/hole in data (OV_HOLE), partial open (OV_EINVAL)
                   0) EOF
                  n) number of samples of PCM actually returned.  The
                  below works on a packet-by-packet basis, so the
                  return length is not related to the 'length' passed
                  in, just guaranteed to fit.

           *section) set to the logical bitstream number  suck in another packet 