
    TiMidity -- Experimental MIDI to WAVE converter
    Copyright (C) 1995 Tuukka Toivonen <toivonen@clinet.fi>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the Perl Artistic License, available in COPYING.
  Earplugs recommended for maximum listening enjoyment  So it isn't interpolation. At least it's final. ************** resampling with fixed increment **************** Play sample until end, then free the voice.  In case we're coming out of a bidir loop  Precalc how many times we should go through the loop.
     NOTE: Assumes that incr > 0 and that ofs <= le  PRECALC_LOOPS  PRECALC_LOOPS  Update offset  Play sample until end-of-loop, skip back and continue.  NOTE: Assumes that ll > incr and that incr > 0.  Precalc how many times we should go through the loop  Hopefully the loop is longer than an increment.  Update offset  Play normally until inside the loop region  NOTE: Assumes that incr > 0, which is NOT always the case
	 when doing bidirectional looping.  I have yet to see a case
	 where both ofs <= ls AND incr < 0, however.  Then do the bidirectional looping  Precalc how many times we should go through the loop  fold the overshoot back in  PRECALC_LOOPS  Play normally until inside the loop region  Then do the bidirectional looping  fold the overshoot back in  PRECALC_LOOPS  Update offset ********************** vibrato versions ************************** We only need to compute one half of the vibrato sine cycle  Need to compute this sample increment.  Need to update sweep  Adjust depth  If the sweep's over, we can store the newly computed sample_increment  need to preserve the loop direction  Play sample until end, then free the voice.  This has never been tested  In case we're coming out of a bidir loop  Update offset  Play sample until end-of-loop, skip back and continue.  Hopefully the loop is longer than an increment  Precalc how many times to go through the loop, taking
	 the vibrato control ratio into account this time.  PRECALC_LOOPS  Hopefully the loop is longer than an increment.  PRECALC_LOOPS  Update offset  Play normally until inside the loop region  Then do the bidirectional looping  Precalc how many times we should go through the loop  fold the overshoot back in  PRECALC_LOOPS  Play normally until inside the loop region  Then do the bidirectional looping  fold the overshoot back in  PRECALC_LOOPS  Update offset  Pre-resampled data -- just update the offset and check if
         we're out of data.  Kind of silly to use
						 FRACTION_BITS here...  Note finished. Free the voice.  Let the caller know how much data we had left  Need to resample. Use the proper function.  Since we're pre-processing and this doesn't have to be done in
     real-time, we go ahead and do the full sliding cubic interpolation. 
    TiMidity -- Experimental MIDI to WAVE converter
    Copyright (C) 1995 Tuukka Toivonen <toivonen@clinet.fi>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the Perl Artistic License, available in COPYING.
  Earplugs recommended for maximum listening enjoyment  So it isn't interpolation. At least it's final. ************** resampling with fixed increment **************** Play sample until end, then free the voice.  In case we're coming out of a bidir loop  Precalc how many times we should go through the loop.
     NOTE: Assumes that incr > 0 and that ofs <= le  PRECALC_LOOPS  PRECALC_LOOPS  Update offset  Play sample until end-of-loop, skip back and continue.  NOTE: Assumes that ll > incr and that incr > 0.  Precalc how many times we should go through the loop  Hopefully the loop is longer than an increment.  Update offset  Play normally until inside the loop region  NOTE: Assumes that incr > 0, which is NOT always the case
	 when doing bidirectional looping.  I have yet to see a case
	 where both ofs <= ls AND incr < 0, however.  Then do the bidirectional looping  Precalc how many times we should go through the loop  fold the overshoot back in  PRECALC_LOOPS  Play normally until inside the loop region  Then do the bidirectional looping  fold the overshoot back in  PRECALC_LOOPS  Update offset ********************** vibrato versions ************************** We only need to compute one half of the vibrato sine cycle  Need to compute this sample increment.  Need to update sweep  Adjust depth  If the sweep's over, we can store the newly computed sample_increment  need to preserve the loop direction  Play sample until end, then free the voice.  This has never been tested  In case we're coming out of a bidir loop  Update offset  Play sample until end-of-loop, skip back and continue.  Hopefully the loop is longer than an increment  Precalc how many times to go through the loop, taking
	 the vibrato control ratio into account this time.  PRECALC_LOOPS  Hopefully the loop is longer than an increment.  PRECALC_LOOPS  Update offset  Play normally until inside the loop region  Then do the bidirectional looping  Precalc how many times we should go through the loop  fold the overshoot back in  PRECALC_LOOPS  Play normally until inside the loop region  Then do the bidirectional looping  fold the overshoot back in  PRECALC_LOOPS  Update offset  Pre-resampled data -- just update the offset and check if
         we're out of data.  Kind of silly to use
						 FRACTION_BITS here...  Note finished. Free the voice.  Let the caller know how much data we had left  Need to resample. Use the proper function.  Since we're pre-processing and this doesn't have to be done in
     real-time, we go ahead and do the full sliding cubic interpolation. 
    TiMidity -- Experimental MIDI to WAVE converter
    Copyright (C) 1995 Tuukka Toivonen <toivonen@clinet.fi>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the Perl Artistic License, available in COPYING.
  Earplugs recommended for maximum listening enjoyment  So it isn't interpolation. At least it's final. ************** resampling with fixed increment **************** Play sample until end, then free the voice.  In case we're coming out of a bidir loop  Precalc how many times we should go through the loop.
     NOTE: Assumes that incr > 0 and that ofs <= le  PRECALC_LOOPS  PRECALC_LOOPS  Update offset  Play sample until end-of-loop, skip back and continue.  NOTE: Assumes that ll > incr and that incr > 0.  Precalc how many times we should go through the loop  Hopefully the loop is longer than an increment.  Update offset  Play normally until inside the loop region  NOTE: Assumes that incr > 0, which is NOT always the case
	 when doing bidirectional looping.  I have yet to see a case
	 where both ofs <= ls AND incr < 0, however.  Then do the bidirectional looping  Precalc how many times we should go through the loop  fold the overshoot back in  PRECALC_LOOPS  Play normally until inside the loop region  Then do the bidirectional looping  fold the overshoot back in  PRECALC_LOOPS  Update offset ********************** vibrato versions ************************** We only need to compute one half of the vibrato sine cycle  Need to compute this sample increment.  Need to update sweep  Adjust depth  If the sweep's over, we can store the newly computed sample_increment  need to preserve the loop direction  Play sample until end, then free the voice.  This has never been tested  In case we're coming out of a bidir loop  Update offset  Play sample until end-of-loop, skip back and continue.  Hopefully the loop is longer than an increment  Precalc how many times to go through the loop, taking
	 the vibrato control ratio into account this time.  PRECALC_LOOPS  Hopefully the loop is longer than an increment.  PRECALC_LOOPS  Update offset  Play normally until inside the loop region  Then do the bidirectional looping  Precalc how many times we should go through the loop  fold the overshoot back in  PRECALC_LOOPS  Play normally until inside the loop region  Then do the bidirectional looping  fold the overshoot back in  PRECALC_LOOPS  Update offset  Pre-resampled data -- just update the offset and check if
         we're out of data.  Kind of silly to use
						 FRACTION_BITS here...  Note finished. Free the voice.  Let the caller know how much data we had left  Need to resample. Use the proper function.  Since we're pre-processing and this doesn't have to be done in
     real-time, we go ahead and do the full sliding cubic interpolation. 