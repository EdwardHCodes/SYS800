 refer to ControlsFXControl for why this is necessary$NON-NLS-1$* Track if slider is vertical/horizontal and cause re layout  the bar between the two thumbs, can be dragged temp fields for mouse drag handling used as a temp value for low and high thumbs in skin coordinates It is important that the highest thumb is "below" the higher thumb in the Z-order Otherwise when both are at the max the mouse cannot be used to drag down the higher trapping the highest at the max extent TODO when all sliders are dragged to the lowest extent they cannot be recovered$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        EventHandler<KeyEvent> keyEventHandler = new EventHandler<KeyEvent>() {            @Override public void handle(KeyEvent event) {                if (KeyCode.TAB.equals(event.getCode())) {                    if (lowestThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowestThumb.setFocus(false);                            new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.PREVIOUS);                        } else {                            lowestThumb.setFocus(false);                            lowerThumb.setFocus(true);                        }                        event.consume();                    } else if(lowerThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowerThumb.setFocus(false);                            lowestThumb.setFocus(true);                        } else {                            lowerThumb.setFocus(false);                            higherThumb.setFocus(true);                        }                        event.consume();                    } else if (higherThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            higherThumb.setFocus(false);                            lowerThumb.setFocus(true);                        } else {                            higherThumb.setFocus(false);                            highestThumb.setFocus(true);                        }                        event.consume();                    } else if (highestThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            highestThumb.setFocus(false);                            higherThumb.setFocus(true);                        } else {                            highestThumb.setFocus(false);                                new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.NEXT);                        }                        event.consume();                    }                }            }        };        getSkinnable().addEventHandler(KeyEvent.KEY_PRESSED, keyEventHandler);   set up a callback on the behavior to indicate which thumb is currently  selected (via enum).$NON-NLS-1$        getChildren().clear();        getChildren().addAll(track);Nothing being done with the second param in sliderBehaviorSo, passing a dummy value$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        rangeBar.setOnMousePressed(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                rangeBar.requestFocus();                preDragPos = isHorizontal() ? e.getX() : -e.getY();            }        });                rangeBar.setOnMouseDragged(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                double delta = (isHorizontal() ? e.getX() : -e.getY()) - preDragPos;                ((MultiRangeSliderBehavior) getBehavior()).moveRange(delta);            }        });                 rangeBar.setOnMouseReleased(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                ((MultiRangeSliderBehavior) getBehavior()).confirmRange();            }        }); add 1 to the slider minor tick count since the axis draws one less minor ticks than the number given. TODO change slider API to Integer from Number            if (slider.getLabelFormatter() != null)                tickLine.setFormatTickLabel(slider.getLabelFormatter());            tickLine.dataChanged();$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$*
     *
     * @return the difference between max and min, but if they have the same
     * value, 1 is returned instead of 0 because otherwise the division where it
     * can be used will return Nan.
     *
     * Called when ever either min, max or lowValue changes, so lowthumb's layoutX, Y is recomputed.
       - thumbHeight/2  - thumbHeight/2*
     * Called when ever either min, max or highValue changes, so highthumb's layoutX, Y is recomputed.
      resize thumb to preferred size we are assuming the is common radius's for all corners on the track center slider in available height vertically layout track layout range bar layout tick line center slider in available width horizontally layout track layout range bar layout tick linereturn (padding.getLeft()) + Math.max(thumb.prefWidth(-1), track.prefWidth(-1)) + padding.getRight(); refer to ControlsFXControl for why this is necessary$NON-NLS-1$* Track if slider is vertical/horizontal and cause re layout  the bar between the two thumbs, can be dragged temp fields for mouse drag handling used as a temp value for low and high thumbs in skin coordinates It is important that the highest thumb is "below" the higher thumb in the Z-order Otherwise when both are at the max the mouse cannot be used to drag down the higher trapping the highest at the max extent TODO when all sliders are dragged to the lowest extent they cannot be recovered$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        EventHandler<KeyEvent> keyEventHandler = new EventHandler<KeyEvent>() {            @Override public void handle(KeyEvent event) {                if (KeyCode.TAB.equals(event.getCode())) {                    if (lowestThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowestThumb.setFocus(false);                            new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.PREVIOUS);                        } else {                            lowestThumb.setFocus(false);                            lowerThumb.setFocus(true);                        }                        event.consume();                    } else if(lowerThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowerThumb.setFocus(false);                            lowestThumb.setFocus(true);                        } else {                            lowerThumb.setFocus(false);                            higherThumb.setFocus(true);                        }                        event.consume();                    } else if (higherThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            higherThumb.setFocus(false);                            lowerThumb.setFocus(true);                        } else {                            higherThumb.setFocus(false);                            highestThumb.setFocus(true);                        }                        event.consume();                    } else if (highestThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            highestThumb.setFocus(false);                            higherThumb.setFocus(true);                        } else {                            highestThumb.setFocus(false);                                new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.NEXT);                        }                        event.consume();                    }                }            }        };        getSkinnable().addEventHandler(KeyEvent.KEY_PRESSED, keyEventHandler);   set up a callback on the behavior to indicate which thumb is currently  selected (via enum).$NON-NLS-1$        getChildren().clear();        getChildren().addAll(track);Nothing being done with the second param in sliderBehaviorSo, passing a dummy value$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        rangeBar.setOnMousePressed(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                rangeBar.requestFocus();                preDragPos = isHorizontal() ? e.getX() : -e.getY();            }        });                rangeBar.setOnMouseDragged(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                double delta = (isHorizontal() ? e.getX() : -e.getY()) - preDragPos;                ((MultiRangeSliderBehavior) getBehavior()).moveRange(delta);            }        });                 rangeBar.setOnMouseReleased(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                ((MultiRangeSliderBehavior) getBehavior()).confirmRange();            }        }); add 1 to the slider minor tick count since the axis draws one less minor ticks than the number given. TODO change slider API to Integer from Number            if (slider.getLabelFormatter() != null)                tickLine.setFormatTickLabel(slider.getLabelFormatter());            tickLine.dataChanged();$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$*
     *
     * @return the difference between max and min, but if they have the same
     * value, 1 is returned instead of 0 because otherwise the division where it
     * can be used will return Nan.
     *
     * Called when ever either min, max or lowValue changes, so lowthumb's layoutX, Y is recomputed.
       - thumbHeight/2  - thumbHeight/2*
     * Called when ever either min, max or highValue changes, so highthumb's layoutX, Y is recomputed.
      resize thumb to preferred size we are assuming the is common radius's for all corners on the track center slider in available height vertically layout track layout range bar layout tick line center slider in available width horizontally layout track layout range bar layout tick linereturn (padding.getLeft()) + Math.max(thumb.prefWidth(-1), track.prefWidth(-1)) + padding.getRight(); refer to ControlsFXControl for why this is necessary$NON-NLS-1$* Track if slider is vertical/horizontal and cause re layout  the bar between the two thumbs, can be dragged temp fields for mouse drag handling used as a temp value for low and high thumbs in skin coordinates It is important that the highest thumb is "below" the higher thumb in the Z-order Otherwise when both are at the max the mouse cannot be used to drag down the higher trapping the highest at the max extent TODO when all sliders are dragged to the lowest extent they cannot be recovered$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        EventHandler<KeyEvent> keyEventHandler = new EventHandler<KeyEvent>() {            @Override public void handle(KeyEvent event) {                if (KeyCode.TAB.equals(event.getCode())) {                    if (lowestThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowestThumb.setFocus(false);                            new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.PREVIOUS);                        } else {                            lowestThumb.setFocus(false);                            lowerThumb.setFocus(true);                        }                        event.consume();                    } else if(lowerThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowerThumb.setFocus(false);                            lowestThumb.setFocus(true);                        } else {                            lowerThumb.setFocus(false);                            higherThumb.setFocus(true);                        }                        event.consume();                    } else if (higherThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            higherThumb.setFocus(false);                            lowerThumb.setFocus(true);                        } else {                            higherThumb.setFocus(false);                            highestThumb.setFocus(true);                        }                        event.consume();                    } else if (highestThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            highestThumb.setFocus(false);                            higherThumb.setFocus(true);                        } else {                            highestThumb.setFocus(false);                                new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.NEXT);                        }                        event.consume();                    }                }            }        };        getSkinnable().addEventHandler(KeyEvent.KEY_PRESSED, keyEventHandler);   set up a callback on the behavior to indicate which thumb is currently  selected (via enum).$NON-NLS-1$        getChildren().clear();        getChildren().addAll(track);Nothing being done with the second param in sliderBehaviorSo, passing a dummy value$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        rangeBar.setOnMousePressed(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                rangeBar.requestFocus();                preDragPos = isHorizontal() ? e.getX() : -e.getY();            }        });                rangeBar.setOnMouseDragged(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                double delta = (isHorizontal() ? e.getX() : -e.getY()) - preDragPos;                ((MultiRangeSliderBehavior) getBehavior()).moveRange(delta);            }        });                 rangeBar.setOnMouseReleased(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                ((MultiRangeSliderBehavior) getBehavior()).confirmRange();            }        }); add 1 to the slider minor tick count since the axis draws one less minor ticks than the number given. TODO change slider API to Integer from Number            if (slider.getLabelFormatter() != null)                tickLine.setFormatTickLabel(slider.getLabelFormatter());            tickLine.dataChanged();$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$*
     *
     * @return the difference between max and min, but if they have the same
     * value, 1 is returned instead of 0 because otherwise the division where it
     * can be used will return Nan.
     *
     * Called when ever either min, max or lowValue changes, so lowthumb's layoutX, Y is recomputed.
       - thumbHeight/2  - thumbHeight/2*
     * Called when ever either min, max or highValue changes, so highthumb's layoutX, Y is recomputed.
      resize thumb to preferred size we are assuming the is common radius's for all corners on the track center slider in available height vertically layout track layout range bar layout tick line center slider in available width horizontally layout track layout range bar layout tick linereturn (padding.getLeft()) + Math.max(thumb.prefWidth(-1), track.prefWidth(-1)) + padding.getRight(); refer to ControlsFXControl for why this is necessary$NON-NLS-1$* Track if slider is vertical/horizontal and cause re layout  the bar between the two thumbs, can be dragged temp fields for mouse drag handling used as a temp value for low and high thumbs in skin coordinates It is important that the highest thumb is "below" the higher thumb in the Z-order Otherwise when both are at the max the mouse cannot be used to drag down the higher trapping the highest at the max extent TODO when all sliders are dragged to the lowest extent they cannot be recovered$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        EventHandler<KeyEvent> keyEventHandler = new EventHandler<KeyEvent>() {            @Override public void handle(KeyEvent event) {                if (KeyCode.TAB.equals(event.getCode())) {                    if (lowestThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowestThumb.setFocus(false);                            new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.PREVIOUS);                        } else {                            lowestThumb.setFocus(false);                            lowerThumb.setFocus(true);                        }                        event.consume();                    } else if(lowerThumb.isFocused()) {                        if (event.isShiftDown()) {                            lowerThumb.setFocus(false);                            lowestThumb.setFocus(true);                        } else {                            lowerThumb.setFocus(false);                            higherThumb.setFocus(true);                        }                        event.consume();                    } else if (higherThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            higherThumb.setFocus(false);                            lowerThumb.setFocus(true);                        } else {                            higherThumb.setFocus(false);                            highestThumb.setFocus(true);                        }                        event.consume();                    } else if (highestThumb.isFocused()) {                        // TODO is this right?                        if(event.isShiftDown()) {                            highestThumb.setFocus(false);                            higherThumb.setFocus(true);                        } else {                            highestThumb.setFocus(false);                                new ParentTraversalEngine(rangeSlider).select(rangeSlider, Direction.NEXT);                        }                        event.consume();                    }                }            }        };        getSkinnable().addEventHandler(KeyEvent.KEY_PRESSED, keyEventHandler);   set up a callback on the behavior to indicate which thumb is currently  selected (via enum).$NON-NLS-1$        getChildren().clear();        getChildren().addAll(track);Nothing being done with the second param in sliderBehaviorSo, passing a dummy value$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$        rangeBar.setOnMousePressed(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                rangeBar.requestFocus();                preDragPos = isHorizontal() ? e.getX() : -e.getY();            }        });                rangeBar.setOnMouseDragged(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                double delta = (isHorizontal() ? e.getX() : -e.getY()) - preDragPos;                ((MultiRangeSliderBehavior) getBehavior()).moveRange(delta);            }        });                 rangeBar.setOnMouseReleased(new EventHandler<MouseEvent>() {            @Override public void handle(MouseEvent e) {                ((MultiRangeSliderBehavior) getBehavior()).confirmRange();            }        }); add 1 to the slider minor tick count since the axis draws one less minor ticks than the number given. TODO change slider API to Integer from Number            if (slider.getLabelFormatter() != null)                tickLine.setFormatTickLabel(slider.getLabelFormatter());            tickLine.dataChanged();$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$$NON-NLS-1$ //$NON-NLS-2$*
     *
     * @return the difference between max and min, but if they have the same
     * value, 1 is returned instead of 0 because otherwise the division where it
     * can be used will return Nan.
     *
     * Called when ever either min, max or lowValue changes, so lowthumb's layoutX, Y is recomputed.
       - thumbHeight/2  - thumbHeight/2*
     * Called when ever either min, max or highValue changes, so highthumb's layoutX, Y is recomputed.
      resize thumb to preferred size we are assuming the is common radius's for all corners on the track center slider in available height vertically layout track layout range bar layout tick line center slider in available width horizontally layout track layout range bar layout tick linereturn (padding.getLeft()) + Math.max(thumb.prefWidth(-1), track.prefWidth(-1)) + padding.getRight();