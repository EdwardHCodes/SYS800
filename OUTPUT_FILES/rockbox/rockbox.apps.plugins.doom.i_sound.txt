 Emacs style mode select   -*- C++ -*-
 *-----------------------------------------------------------------------------
 *
 *
 *  PrBoom a Doom port merged with LxDoom and LSDLDoom
 *  based on BOOM, a modified and improved DOOM engine
 *  Copyright (C) 1999 by
 *  id Software, Chi Hoang, Lee Killough, Jim Flynn, Rand Phares, Ty Halderman
 *  Copyright (C) 1999-2000 by
 *  Jess Haas, Nicolas Kalkhof, Colin Phipps, Florian Schulze
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 *  02111-1307, USA.
 *
 * DESCRIPTION:
 *  System interface for sound.
 *
 *-----------------------------------------------------------------------------
  The number of internal mixing channels,  the samples calculated for each mixing step,  the size of the 16bit, 2 hardware channel (stereo)  mixing buffer, and the samplerate of the raw data. Needed for calling the actual sound output. It is 2 for 16bit, and 2 for two channels. 44100 22050 11025 44100 22050 11025 16bit The global mixing buffer.  Basically, samples from all active internal channels  are modifed and added, and stored in the buffer  that is submitted to the audio device. Don't place this in IRAM!
 * Sound playback uses DMA, and not all IRAM is DMA capable on coldfire.  SFX id of the playing sound effect. Used to catch duplicates (like chainsaw). The channel step amount... ... and a 0.16 bit remainder of last step. The channel data pointers, start and end. Time/gametic that the channel started playing,  used to determine oldest, which automatically  has lowest priority. In case number of active sounds exceeds  available channels. Hardware left and right channel volume lookup. Volume lookups. Pitch to stepping lookup. (Not setup properly right now) This function loads the sound data from the WAD lump for single sound. It is used to cache all the sounddata at startup. Get the sound data from the WAD, allocate lump  in zone memory. Now, there is a severe problem with the sound handling, in it is not  (yet/anymore) gamemode aware. That means, sounds from DOOM II will be  requested even with DOOM shareware. The sound list is wired into sounds.c, which sets the external variable. I do not do runtime patches to that variable. Instead, we will use a  default sound for replacement. Allocate from memory. Now copy and pad. Remove the cached lump. Return allocated data. cph
 * stopchan
 * Stops a sound
  This function adds a sound to the  list of currently active sounds,  which is maintained as a given number  (eight, usually) of internal channels. Returns a handle. We will handle the new SFX. Set pointer to raw data. Find padded length  Set pointer to end of raw data.  Skip header  Should be gametic, I presume. Preserve sound SFX id,  e.g. for avoiding duplicates of chainsaw. Set stepping MWM 2000-12-24: Calculates proportion of channel samplerate to global samplerate for mixing purposes. Patched to shift left *then* divide, to minimize roundoff errors as well as to use SAMPLERATE as defined above, not to assume 11025 Hz Separation, that is, orientation/stereo.  range is: 1 - 256 Per left/right channel.  x^2 seperation,  adjust volume properly. Sanity check, clamp volume. Get the proper lookup table piece  for this volume level??? SFX API Note: this was called by S_Init. However, whatever they did in the old DPMS based DOS version, this were simply dummies in the Linux version. See soundserver initdata(). Init internal lookups (raw data, mixing buffer, channels). This function sets up internal lookups used during  the mixing process. Okay, reset internal mixing channels to zero. This table provides step widths for pitch parameters.      steptablemid[i] = (int)(pow(1.2, ((double)i/(64.0*SAMPLERATE/11025)))*65536.0); Generates volume lookup tables  which also turn the unsigned samples  into signed samples. Identical to DOS. Basically, this should propagate  the menu/config file setting  to the state variable used in  the mixing. MUSIC API - dummy. Some code from DOS version. Internal state variable. Now set volume on output device. Whatever( snd_MusciVolume ); Retrieve the raw data lump index  for a given SFX name. Starting a sound means adding it  to the current list of active sounds  in the internal channels. As the SFX info struct contains  e.g. a pointer to the raw data,  it is ignored. As our sound handling does not handle  priority, it is ignored. Pitching (that is, increased speed of playback)  is set, but currently not used by mixing. Returns a handle (not used). This function loops all active (internal) sound  channels, retrieves a given number of samples  from the raw sound data, modifies it according  to the current (internal) channel parameters,  mixes the per channel samples into the given  mixing buffer, and clamping it to the allowed  range. This function currently supports only 16bit. Mix current sound data. Data, from raw sound, for right and left. Pointers in global mixbuffer, left, right, end. Step in mixbuffer, left and right, thus two. Mixing channel index. Left and right channel  are in global mixbuffer, alternating. Determine end, for left channel only  (right channel is implicit). Mix sounds into the mixing buffer. Loop over step*SAMPLECOUNT,  that is 512 values for two channels. Reset left/right value. Love thy L2 chache - made this a loop. Now more channels could be set at compile time  as well. Thus loop those  channels. Check channel, if active. Get the raw data from the channel. Add left and right part  for this channel (sound)  to the current data. Adjust volume accordingly. Increment index ??? MSB is next sample??? Limit to LSB??? Check whether we are done. Clamp to range. Left hardware channel. Has been char instead of short. if (dl > 127) *leftout = 127; else if (dl < -128) *leftout = -128; else *leftout = dl; Same for right hardware channel. Increment current pointers in mixbuffer. This would be used to write out the mixbuffer  during each game loop update. Updates sound buffer and audio device at runtime. It is called during Timer interrupt with SNDINTR. Mixing now done synchronous, and  only output be done asynchronous? Force sound update 44100 Initialize external data (all sounds) at start, keep static. Select playback  Alias? Example is the chaingun sound linked to pistol. Load data from WAD file. Previously loaded already? Now initialize mixbuffer with zero. Finished initialization. MUSIC API. Still no music done. Remains. Dummies. UNUSED. UNUSED. UNUSED. UNUSED. UNUSED. UNUSED. Is the song playing? UNUSED. Interrupt handler. Get the interrupt. Set duration in millisecs. Error is -1. Remove the interrupt. Set duration to zero. Emacs style mode select   -*- C++ -*-
 *-----------------------------------------------------------------------------
 *
 *
 *  PrBoom a Doom port merged with LxDoom and LSDLDoom
 *  based on BOOM, a modified and improved DOOM engine
 *  Copyright (C) 1999 by
 *  id Software, Chi Hoang, Lee Killough, Jim Flynn, Rand Phares, Ty Halderman
 *  Copyright (C) 1999-2000 by
 *  Jess Haas, Nicolas Kalkhof, Colin Phipps, Florian Schulze
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 *  02111-1307, USA.
 *
 * DESCRIPTION:
 *  System interface for sound.
 *
 *-----------------------------------------------------------------------------
  The number of internal mixing channels,  the samples calculated for each mixing step,  the size of the 16bit, 2 hardware channel (stereo)  mixing buffer, and the samplerate of the raw data. Needed for calling the actual sound output. It is 2 for 16bit, and 2 for two channels. 44100 22050 11025 44100 22050 11025 16bit The global mixing buffer.  Basically, samples from all active internal channels  are modifed and added, and stored in the buffer  that is submitted to the audio device. Don't place this in IRAM!
 * Sound playback uses DMA, and not all IRAM is DMA capable on coldfire.  SFX id of the playing sound effect. Used to catch duplicates (like chainsaw). The channel step amount... ... and a 0.16 bit remainder of last step. The channel data pointers, start and end. Time/gametic that the channel started playing,  used to determine oldest, which automatically  has lowest priority. In case number of active sounds exceeds  available channels. Hardware left and right channel volume lookup. Volume lookups. Pitch to stepping lookup. (Not setup properly right now) This function loads the sound data from the WAD lump for single sound. It is used to cache all the sounddata at startup. Get the sound data from the WAD, allocate lump  in zone memory. Now, there is a severe problem with the sound handling, in it is not  (yet/anymore) gamemode aware. That means, sounds from DOOM II will be  requested even with DOOM shareware. The sound list is wired into sounds.c, which sets the external variable. I do not do runtime patches to that variable. Instead, we will use a  default sound for replacement. Allocate from memory. Now copy and pad. Remove the cached lump. Return allocated data. cph
 * stopchan
 * Stops a sound
  This function adds a sound to the  list of currently active sounds,  which is maintained as a given number  (eight, usually) of internal channels. Returns a handle. We will handle the new SFX. Set pointer to raw data. Find padded length  Set pointer to end of raw data.  Skip header  Should be gametic, I presume. Preserve sound SFX id,  e.g. for avoiding duplicates of chainsaw. Set stepping MWM 2000-12-24: Calculates proportion of channel samplerate to global samplerate for mixing purposes. Patched to shift left *then* divide, to minimize roundoff errors as well as to use SAMPLERATE as defined above, not to assume 11025 Hz Separation, that is, orientation/stereo.  range is: 1 - 256 Per left/right channel.  x^2 seperation,  adjust volume properly. Sanity check, clamp volume. Get the proper lookup table piece  for this volume level??? SFX API Note: this was called by S_Init. However, whatever they did in the old DPMS based DOS version, this were simply dummies in the Linux version. See soundserver initdata(). Init internal lookups (raw data, mixing buffer, channels). This function sets up internal lookups used during  the mixing process. Okay, reset internal mixing channels to zero. This table provides step widths for pitch parameters.      steptablemid[i] = (int)(pow(1.2, ((double)i/(64.0*SAMPLERATE/11025)))*65536.0); Generates volume lookup tables  which also turn the unsigned samples  into signed samples. Identical to DOS. Basically, this should propagate  the menu/config file setting  to the state variable used in  the mixing. MUSIC API - dummy. Some code from DOS version. Internal state variable. Now set volume on output device. Whatever( snd_MusciVolume ); Retrieve the raw data lump index  for a given SFX name. Starting a sound means adding it  to the current list of active sounds  in the internal channels. As the SFX info struct contains  e.g. a pointer to the raw data,  it is ignored. As our sound handling does not handle  priority, it is ignored. Pitching (that is, increased speed of playback)  is set, but currently not used by mixing. Returns a handle (not used). This function loops all active (internal) sound  channels, retrieves a given number of samples  from the raw sound data, modifies it according  to the current (internal) channel parameters,  mixes the per channel samples into the given  mixing buffer, and clamping it to the allowed  range. This function currently supports only 16bit. Mix current sound data. Data, from raw sound, for right and left. Pointers in global mixbuffer, left, right, end. Step in mixbuffer, left and right, thus two. Mixing channel index. Left and right channel  are in global mixbuffer, alternating. Determine end, for left channel only  (right channel is implicit). Mix sounds into the mixing buffer. Loop over step*SAMPLECOUNT,  that is 512 values for two channels. Reset left/right value. Love thy L2 chache - made this a loop. Now more channels could be set at compile time  as well. Thus loop those  channels. Check channel, if active. Get the raw data from the channel. Add left and right part  for this channel (sound)  to the current data. Adjust volume accordingly. Increment index ??? MSB is next sample??? Limit to LSB??? Check whether we are done. Clamp to range. Left hardware channel. Has been char instead of short. if (dl > 127) *leftout = 127; else if (dl < -128) *leftout = -128; else *leftout = dl; Same for right hardware channel. Increment current pointers in mixbuffer. This would be used to write out the mixbuffer  during each game loop update. Updates sound buffer and audio device at runtime. It is called during Timer interrupt with SNDINTR. Mixing now done synchronous, and  only output be done asynchronous? Force sound update 44100 Initialize external data (all sounds) at start, keep static. Select playback  Alias? Example is the chaingun sound linked to pistol. Load data from WAD file. Previously loaded already? Now initialize mixbuffer with zero. Finished initialization. MUSIC API. Still no music done. Remains. Dummies. UNUSED. UNUSED. UNUSED. UNUSED. UNUSED. UNUSED. Is the song playing? UNUSED. Interrupt handler. Get the interrupt. Set duration in millisecs. Error is -1. Remove the interrupt. Set duration to zero. Emacs style mode select   -*- C++ -*-
 *-----------------------------------------------------------------------------
 *
 *
 *  PrBoom a Doom port merged with LxDoom and LSDLDoom
 *  based on BOOM, a modified and improved DOOM engine
 *  Copyright (C) 1999 by
 *  id Software, Chi Hoang, Lee Killough, Jim Flynn, Rand Phares, Ty Halderman
 *  Copyright (C) 1999-2000 by
 *  Jess Haas, Nicolas Kalkhof, Colin Phipps, Florian Schulze
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 *  02111-1307, USA.
 *
 * DESCRIPTION:
 *  System interface for sound.
 *
 *-----------------------------------------------------------------------------
  The number of internal mixing channels,  the samples calculated for each mixing step,  the size of the 16bit, 2 hardware channel (stereo)  mixing buffer, and the samplerate of the raw data. Needed for calling the actual sound output. It is 2 for 16bit, and 2 for two channels. 44100 22050 11025 44100 22050 11025 16bit The global mixing buffer.  Basically, samples from all active internal channels  are modifed and added, and stored in the buffer  that is submitted to the audio device. Don't place this in IRAM!
 * Sound playback uses DMA, and not all IRAM is DMA capable on coldfire.  SFX id of the playing sound effect. Used to catch duplicates (like chainsaw). The channel step amount... ... and a 0.16 bit remainder of last step. The channel data pointers, start and end. Time/gametic that the channel started playing,  used to determine oldest, which automatically  has lowest priority. In case number of active sounds exceeds  available channels. Hardware left and right channel volume lookup. Volume lookups. Pitch to stepping lookup. (Not setup properly right now) This function loads the sound data from the WAD lump for single sound. It is used to cache all the sounddata at startup. Get the sound data from the WAD, allocate lump  in zone memory. Now, there is a severe problem with the sound handling, in it is not  (yet/anymore) gamemode aware. That means, sounds from DOOM II will be  requested even with DOOM shareware. The sound list is wired into sounds.c, which sets the external variable. I do not do runtime patches to that variable. Instead, we will use a  default sound for replacement. Allocate from memory. Now copy and pad. Remove the cached lump. Return allocated data. cph
 * stopchan
 * Stops a sound
  This function adds a sound to the  list of currently active sounds,  which is maintained as a given number  (eight, usually) of internal channels. Returns a handle. We will handle the new SFX. Set pointer to raw data. Find padded length  Set pointer to end of raw data.  Skip header  Should be gametic, I presume. Preserve sound SFX id,  e.g. for avoiding duplicates of chainsaw. Set stepping MWM 2000-12-24: Calculates proportion of channel samplerate to global samplerate for mixing purposes. Patched to shift left *then* divide, to minimize roundoff errors as well as to use SAMPLERATE as defined above, not to assume 11025 Hz Separation, that is, orientation/stereo.  range is: 1 - 256 Per left/right channel.  x^2 seperation,  adjust volume properly. Sanity check, clamp volume. Get the proper lookup table piece  for this volume level??? SFX API Note: this was called by S_Init. However, whatever they did in the old DPMS based DOS version, this were simply dummies in the Linux version. See soundserver initdata(). Init internal lookups (raw data, mixing buffer, channels). This function sets up internal lookups used during  the mixing process. Okay, reset internal mixing channels to zero. This table provides step widths for pitch parameters.      steptablemid[i] = (int)(pow(1.2, ((double)i/(64.0*SAMPLERATE/11025)))*65536.0); Generates volume lookup tables  which also turn the unsigned samples  into signed samples. Identical to DOS. Basically, this should propagate  the menu/config file setting  to the state variable used in  the mixing. MUSIC API - dummy. Some code from DOS version. Internal state variable. Now set volume on output device. Whatever( snd_MusciVolume ); Retrieve the raw data lump index  for a given SFX name. Starting a sound means adding it  to the current list of active sounds  in the internal channels. As the SFX info struct contains  e.g. a pointer to the raw data,  it is ignored. As our sound handling does not handle  priority, it is ignored. Pitching (that is, increased speed of playback)  is set, but currently not used by mixing. Returns a handle (not used). This function loops all active (internal) sound  channels, retrieves a given number of samples  from the raw sound data, modifies it according  to the current (internal) channel parameters,  mixes the per channel samples into the given  mixing buffer, and clamping it to the allowed  range. This function currently supports only 16bit. Mix current sound data. Data, from raw sound, for right and left. Pointers in global mixbuffer, left, right, end. Step in mixbuffer, left and right, thus two. Mixing channel index. Left and right channel  are in global mixbuffer, alternating. Determine end, for left channel only  (right channel is implicit). Mix sounds into the mixing buffer. Loop over step*SAMPLECOUNT,  that is 512 values for two channels. Reset left/right value. Love thy L2 chache - made this a loop. Now more channels could be set at compile time  as well. Thus loop those  channels. Check channel, if active. Get the raw data from the channel. Add left and right part  for this channel (sound)  to the current data. Adjust volume accordingly. Increment index ??? MSB is next sample??? Limit to LSB??? Check whether we are done. Clamp to range. Left hardware channel. Has been char instead of short. if (dl > 127) *leftout = 127; else if (dl < -128) *leftout = -128; else *leftout = dl; Same for right hardware channel. Increment current pointers in mixbuffer. This would be used to write out the mixbuffer  during each game loop update. Updates sound buffer and audio device at runtime. It is called during Timer interrupt with SNDINTR. Mixing now done synchronous, and  only output be done asynchronous? Force sound update 44100 Initialize external data (all sounds) at start, keep static. Select playback  Alias? Example is the chaingun sound linked to pistol. Load data from WAD file. Previously loaded already? Now initialize mixbuffer with zero. Finished initialization. MUSIC API. Still no music done. Remains. Dummies. UNUSED. UNUSED. UNUSED. UNUSED. UNUSED. UNUSED. Is the song playing? UNUSED. Interrupt handler. Get the interrupt. Set duration in millisecs. Error is -1. Remove the interrupt. Set duration to zero.