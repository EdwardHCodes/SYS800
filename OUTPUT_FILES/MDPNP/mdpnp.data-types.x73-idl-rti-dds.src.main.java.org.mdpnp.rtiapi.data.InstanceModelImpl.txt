 TODO ordering issues if an instance becomes unalive while I'm catching up this listener TODO Fire removal of element at idx TODO fire element update of element at idx TODO fire element inserted at instances.size()-1 TODO time since epoch is a klugey way to get some likelihood of uniqueness TODO eventually this should @Override from a collection API TODO provide 'get' as part of a collection API    public D getElementAt(int index) {        InstanceHandle_t handle;        // Doesn't seem likely but I've seen it happen        synchronized(instances) {            if(index < instances.size()) {                handle = instances.get(index);            } else {                return null;            }        }                Sequence sa_seq = InstanceModelImpl.this.sa_seq1.get();        SampleInfoSeq info_seq = InstanceModelImpl.this.info_seq1.get();        R reader = this.reader;        try {            readInstance.invoke(reader, sa_seq, info_seq, ResourceLimitsQosPolicy.LENGTH_UNLIMITED, handle, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE);            D d = dataClass.newInstance();            d.copy_from(sa_seq.get(sa_seq.size()-1));            return d;        } catch (Exception e) {            if(!(e.getCause() instanceof RETCODE_NO_DATA)) {                log.error("read_instance", e);            }        } finally {            try {                returnLoan.invoke(reader, sa_seq, info_seq);            } catch (Exception e) {                log.error("return_loan", e);            }        }        return null;    } TODO ordering issues if an instance becomes unalive while I'm catching up this listener TODO Fire removal of element at idx TODO fire element update of element at idx TODO fire element inserted at instances.size()-1 TODO time since epoch is a klugey way to get some likelihood of uniqueness TODO eventually this should @Override from a collection API TODO provide 'get' as part of a collection API    public D getElementAt(int index) {        InstanceHandle_t handle;        // Doesn't seem likely but I've seen it happen        synchronized(instances) {            if(index < instances.size()) {                handle = instances.get(index);            } else {                return null;            }        }                Sequence sa_seq = InstanceModelImpl.this.sa_seq1.get();        SampleInfoSeq info_seq = InstanceModelImpl.this.info_seq1.get();        R reader = this.reader;        try {            readInstance.invoke(reader, sa_seq, info_seq, ResourceLimitsQosPolicy.LENGTH_UNLIMITED, handle, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE);            D d = dataClass.newInstance();            d.copy_from(sa_seq.get(sa_seq.size()-1));            return d;        } catch (Exception e) {            if(!(e.getCause() instanceof RETCODE_NO_DATA)) {                log.error("read_instance", e);            }        } finally {            try {                returnLoan.invoke(reader, sa_seq, info_seq);            } catch (Exception e) {                log.error("return_loan", e);            }        }        return null;    } TODO ordering issues if an instance becomes unalive while I'm catching up this listener TODO Fire removal of element at idx TODO fire element update of element at idx TODO fire element inserted at instances.size()-1 TODO time since epoch is a klugey way to get some likelihood of uniqueness TODO eventually this should @Override from a collection API TODO provide 'get' as part of a collection API    public D getElementAt(int index) {        InstanceHandle_t handle;        // Doesn't seem likely but I've seen it happen        synchronized(instances) {            if(index < instances.size()) {                handle = instances.get(index);            } else {                return null;            }        }                Sequence sa_seq = InstanceModelImpl.this.sa_seq1.get();        SampleInfoSeq info_seq = InstanceModelImpl.this.info_seq1.get();        R reader = this.reader;        try {            readInstance.invoke(reader, sa_seq, info_seq, ResourceLimitsQosPolicy.LENGTH_UNLIMITED, handle, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE);            D d = dataClass.newInstance();            d.copy_from(sa_seq.get(sa_seq.size()-1));            return d;        } catch (Exception e) {            if(!(e.getCause() instanceof RETCODE_NO_DATA)) {                log.error("read_instance", e);            }        } finally {            try {                returnLoan.invoke(reader, sa_seq, info_seq);            } catch (Exception e) {                log.error("return_loan", e);            }        }        return null;    } TODO ordering issues if an instance becomes unalive while I'm catching up this listener TODO Fire removal of element at idx TODO fire element update of element at idx TODO fire element inserted at instances.size()-1 TODO time since epoch is a klugey way to get some likelihood of uniqueness TODO eventually this should @Override from a collection API TODO provide 'get' as part of a collection API    public D getElementAt(int index) {        InstanceHandle_t handle;        // Doesn't seem likely but I've seen it happen        synchronized(instances) {            if(index < instances.size()) {                handle = instances.get(index);            } else {                return null;            }        }                Sequence sa_seq = InstanceModelImpl.this.sa_seq1.get();        SampleInfoSeq info_seq = InstanceModelImpl.this.info_seq1.get();        R reader = this.reader;        try {            readInstance.invoke(reader, sa_seq, info_seq, ResourceLimitsQosPolicy.LENGTH_UNLIMITED, handle, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE);            D d = dataClass.newInstance();            d.copy_from(sa_seq.get(sa_seq.size()-1));            return d;        } catch (Exception e) {            if(!(e.getCause() instanceof RETCODE_NO_DATA)) {                log.error("read_instance", e);            }        } finally {            try {                returnLoan.invoke(reader, sa_seq, info_seq);            } catch (Exception e) {                log.error("return_loan", e);            }        }        return null;    } TODO ordering issues if an instance becomes unalive while I'm catching up this listener TODO Fire removal of element at idx TODO fire element update of element at idx TODO fire element inserted at instances.size()-1 TODO time since epoch is a klugey way to get some likelihood of uniqueness TODO eventually this should @Override from a collection API TODO provide 'get' as part of a collection API    public D getElementAt(int index) {        InstanceHandle_t handle;        // Doesn't seem likely but I've seen it happen        synchronized(instances) {            if(index < instances.size()) {                handle = instances.get(index);            } else {                return null;            }        }                Sequence sa_seq = InstanceModelImpl.this.sa_seq1.get();        SampleInfoSeq info_seq = InstanceModelImpl.this.info_seq1.get();        R reader = this.reader;        try {            readInstance.invoke(reader, sa_seq, info_seq, ResourceLimitsQosPolicy.LENGTH_UNLIMITED, handle, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE);            D d = dataClass.newInstance();            d.copy_from(sa_seq.get(sa_seq.size()-1));            return d;        } catch (Exception e) {            if(!(e.getCause() instanceof RETCODE_NO_DATA)) {                log.error("read_instance", e);            }        } finally {            try {                returnLoan.invoke(reader, sa_seq, info_seq);            } catch (Exception e) {                log.error("return_loan", e);            }        }        return null;    } TODO ordering issues if an instance becomes unalive while I'm catching up this listener TODO Fire removal of element at idx TODO fire element update of element at idx TODO fire element inserted at instances.size()-1 TODO time since epoch is a klugey way to get some likelihood of uniqueness TODO eventually this should @Override from a collection API TODO provide 'get' as part of a collection API    public D getElementAt(int index) {        InstanceHandle_t handle;        // Doesn't seem likely but I've seen it happen        synchronized(instances) {            if(index < instances.size()) {                handle = instances.get(index);            } else {                return null;            }        }                Sequence sa_seq = InstanceModelImpl.this.sa_seq1.get();        SampleInfoSeq info_seq = InstanceModelImpl.this.info_seq1.get();        R reader = this.reader;        try {            readInstance.invoke(reader, sa_seq, info_seq, ResourceLimitsQosPolicy.LENGTH_UNLIMITED, handle, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE);            D d = dataClass.newInstance();            d.copy_from(sa_seq.get(sa_seq.size()-1));            return d;        } catch (Exception e) {            if(!(e.getCause() instanceof RETCODE_NO_DATA)) {                log.error("read_instance", e);            }        } finally {            try {                returnLoan.invoke(reader, sa_seq, info_seq);            } catch (Exception e) {                log.error("return_loan", e);            }        }        return null;    } TODO ordering issues if an instance becomes unalive while I'm catching up this listener TODO Fire removal of element at idx TODO fire element update of element at idx TODO fire element inserted at instances.size()-1 TODO time since epoch is a klugey way to get some likelihood of uniqueness TODO eventually this should @Override from a collection API TODO provide 'get' as part of a collection API    public D getElementAt(int index) {        InstanceHandle_t handle;        // Doesn't seem likely but I've seen it happen        synchronized(instances) {            if(index < instances.size()) {                handle = instances.get(index);            } else {                return null;            }        }                Sequence sa_seq = InstanceModelImpl.this.sa_seq1.get();        SampleInfoSeq info_seq = InstanceModelImpl.this.info_seq1.get();        R reader = this.reader;        try {            readInstance.invoke(reader, sa_seq, info_seq, ResourceLimitsQosPolicy.LENGTH_UNLIMITED, handle, SampleStateKind.ANY_SAMPLE_STATE, ViewStateKind.ANY_VIEW_STATE, InstanceStateKind.ANY_INSTANCE_STATE);            D d = dataClass.newInstance();            d.copy_from(sa_seq.get(sa_seq.size()-1));            return d;        } catch (Exception e) {            if(!(e.getCause() instanceof RETCODE_NO_DATA)) {                log.error("read_instance", e);            }        } finally {            try {                returnLoan.invoke(reader, sa_seq, info_seq);            } catch (Exception e) {                log.error("return_loan", e);            }        }        return null;    }