 Gb_Snd_Emu 0.1.4. http://www.slack.net/~ant/ Copyright (C) 2003-2008 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
details. You should have received a copy of the GNU Lesser General Public
License along with this module; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA  enables bug in early CGB units that causes problems in some games enables CGB-05 zombie behavior Units can only access within narrow time window while playing write_register CGB-05 behavior, very close to AGB behavior as well CGB-04&02 behavior, very close to MGB behavior as well CGB-05 behavior, very close to AGB behavior as well CGB-04&02 behavior, very close to MGB behavior as well TODO: really happens at next length clock TODO: really happens at next length clock sweep negate disabled after used avoids divide Synthesis Calc duty and phase AGB uses inverted duty Determine what will be generated Play inaudible frequencies as constant amplitude Generate wave Maintain phase when not playing will be masked below Output amplitude transitions Quickly runs LFSR for a large number of clocks. For use when noise is generating no sound. set to false to use only unoptimized loop in middle optimization used in several places: ((s & (1 << b)) << n) ^ ((s & (1 << b)) << (n + 1)) = (s & (1 << b)) * (3 << n) Convert from Fibonacci to Galois configuration, shifted left 1 bit Each iteration is equivalent to clocking LFSR 255 times Each iteration is equivalent to clocking LFSR 15 times (interesting similarity to single clocking below) Remaining singles Convert back to Fibonacci configuration won't fully replace upper 8 bits, so have to do the unoptimized way must run at least once Need to keep one extra bit of history Convert from Fibonacci to Galois configuration, shifted left 2 bits Each iteration is equivalent to clocking LFSR 7 times (interesting similarity to single clocking below) Remaining singles Convert back to Fibonacci configuration and repeat last 8 bits above significant 7 Determine what will be generated AGB negates final output Run timer and calculate time of next LFSR clock Generate wave Noise can be THE biggest time hog; adjust as necessary Maintain phase when not playing cache Output amplitude transitions Calc volume 2 bits on DMG/CGB, 3 on AGB Determine what will be generated Play inaudible frequencies as constant amplitude really depends on average of all samples in wave if delay is larger, constant amplitude won't start yet Generate wave wave size and bank pre-advance Maintain phase when not playing will be masked below cache Output amplitude transitions Extract nibble Scale by volume undo pre-advance and mask position Keep track of last byte read undo swapped banks Gb_Snd_Emu 0.1.4. http://www.slack.net/~ant/ Copyright (C) 2003-2008 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
details. You should have received a copy of the GNU Lesser General Public
License along with this module; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA  enables bug in early CGB units that causes problems in some games enables CGB-05 zombie behavior Units can only access within narrow time window while playing write_register CGB-05 behavior, very close to AGB behavior as well CGB-04&02 behavior, very close to MGB behavior as well CGB-05 behavior, very close to AGB behavior as well CGB-04&02 behavior, very close to MGB behavior as well TODO: really happens at next length clock TODO: really happens at next length clock sweep negate disabled after used avoids divide Synthesis Calc duty and phase AGB uses inverted duty Determine what will be generated Play inaudible frequencies as constant amplitude Generate wave Maintain phase when not playing will be masked below Output amplitude transitions Quickly runs LFSR for a large number of clocks. For use when noise is generating no sound. set to false to use only unoptimized loop in middle optimization used in several places: ((s & (1 << b)) << n) ^ ((s & (1 << b)) << (n + 1)) = (s & (1 << b)) * (3 << n) Convert from Fibonacci to Galois configuration, shifted left 1 bit Each iteration is equivalent to clocking LFSR 255 times Each iteration is equivalent to clocking LFSR 15 times (interesting similarity to single clocking below) Remaining singles Convert back to Fibonacci configuration won't fully replace upper 8 bits, so have to do the unoptimized way must run at least once Need to keep one extra bit of history Convert from Fibonacci to Galois configuration, shifted left 2 bits Each iteration is equivalent to clocking LFSR 7 times (interesting similarity to single clocking below) Remaining singles Convert back to Fibonacci configuration and repeat last 8 bits above significant 7 Determine what will be generated AGB negates final output Run timer and calculate time of next LFSR clock Generate wave Noise can be THE biggest time hog; adjust as necessary Maintain phase when not playing cache Output amplitude transitions Calc volume 2 bits on DMG/CGB, 3 on AGB Determine what will be generated Play inaudible frequencies as constant amplitude really depends on average of all samples in wave if delay is larger, constant amplitude won't start yet Generate wave wave size and bank pre-advance Maintain phase when not playing will be masked below cache Output amplitude transitions Extract nibble Scale by volume undo pre-advance and mask position Keep track of last byte read undo swapped banks Gb_Snd_Emu 0.1.4. http://www.slack.net/~ant/ Copyright (C) 2003-2008 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
details. You should have received a copy of the GNU Lesser General Public
License along with this module; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA  enables bug in early CGB units that causes problems in some games enables CGB-05 zombie behavior Units can only access within narrow time window while playing write_register CGB-05 behavior, very close to AGB behavior as well CGB-04&02 behavior, very close to MGB behavior as well CGB-05 behavior, very close to AGB behavior as well CGB-04&02 behavior, very close to MGB behavior as well TODO: really happens at next length clock TODO: really happens at next length clock sweep negate disabled after used avoids divide Synthesis Calc duty and phase AGB uses inverted duty Determine what will be generated Play inaudible frequencies as constant amplitude Generate wave Maintain phase when not playing will be masked below Output amplitude transitions Quickly runs LFSR for a large number of clocks. For use when noise is generating no sound. set to false to use only unoptimized loop in middle optimization used in several places: ((s & (1 << b)) << n) ^ ((s & (1 << b)) << (n + 1)) = (s & (1 << b)) * (3 << n) Convert from Fibonacci to Galois configuration, shifted left 1 bit Each iteration is equivalent to clocking LFSR 255 times Each iteration is equivalent to clocking LFSR 15 times (interesting similarity to single clocking below) Remaining singles Convert back to Fibonacci configuration won't fully replace upper 8 bits, so have to do the unoptimized way must run at least once Need to keep one extra bit of history Convert from Fibonacci to Galois configuration, shifted left 2 bits Each iteration is equivalent to clocking LFSR 7 times (interesting similarity to single clocking below) Remaining singles Convert back to Fibonacci configuration and repeat last 8 bits above significant 7 Determine what will be generated AGB negates final output Run timer and calculate time of next LFSR clock Generate wave Noise can be THE biggest time hog; adjust as necessary Maintain phase when not playing cache Output amplitude transitions Calc volume 2 bits on DMG/CGB, 3 on AGB Determine what will be generated Play inaudible frequencies as constant amplitude really depends on average of all samples in wave if delay is larger, constant amplitude won't start yet Generate wave wave size and bank pre-advance Maintain phase when not playing will be masked below cache Output amplitude transitions Extract nibble Scale by volume undo pre-advance and mask position Keep track of last byte read undo swapped banks