//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //      Distributed under the BSD Software License (see license.txt)      //////////////////////////////////////////////////////////////////////////// wputils.c This module provides a high-level interface for decoding WavPack 4.0 audio streams and files. WavPack data is read with a stream reading callback. No direct seeking is provided for, but it is possible to start decoding anywhere in a WavPack stream. In this case, WavPack will be able to provide the sample-accurate position when it synchs with the data and begins decoding./////////////////////////// local table storage /////////////////////////////////////////////////////// executable code //////////////////////////////// This function reads data from the specified stream in search of a valid WavPack 4.0 audio block. If this fails in 1 megabyte (or an invalid or unsupported WavPack block is encountered) then an appropriate message is copied to "error" and NULL is returned, otherwise a pointer to a WavpackContext structure is returned (which is used to call all other functions in this module). This can be initiated at the beginning of a WavPack file, or anywhere inside a WavPack file. To determine the exact position within the file use WavpackGetSampleIndex(). For demonstration purposes this uses a single static copy of the WavpackContext structure, so obviously it cannot be used for more than one file at a time. Also, this function will not handle "correction" files, plays only the first two channels of multi-channel files, and is limited in resolution in some large integer or floating point files (but always provides at least 24 bits of resolution). open the source file for reading and store the size This function obtains general information about an open file and returns a mask with the following bit values: MODE_LOSSLESS:  file is lossless (pure lossless only) MODE_HYBRID:  file is hybrid mode (lossy part only) MODE_FLOAT:  audio data is 32-bit ieee floating point MODE_HIGH:  file was created in "high" mode (information only) MODE_FAST:  file was created in "fast" mode (information only) Unpack the specified number of samples from the current file position. Note that "samples" here refers to "complete" samples, which would be 2 int32_t's for stereo files. The audio data is returned right-justified in 32-bit int32_t's in the endian mode native to the executing processor. So, if the original data was 16-bit, then the values returned would be +/-32k. Floating point data can also be returned if the source was floating point data (and this is normalized to +/-1.0). The actual number of samples unpacked is returned, which should be equal to the number requested unless the end of fle is encountered or an error occurs. Get total number of samples contained in the WavPack file, or -1 if unknown Get the current sample index position, or -1 if unknown Get the number of errors encountered so far return TRUE if any uncorrected lossy blocks were actually written or read Returns the sample rate of the specified WavPack file Returns the number of channels of the specified WavPack file. Note that this is the actual number of channels contained in the file, but this version can only decode the first two. Returns the actual number of valid bits per sample contained in the original file, which may or may not be a multiple of 8. Floating data always has 32 bits, integers may be from 1 to 32 bits each. When this value is not a multiple of 8, then the "extra" bits are located in the LSBs of the results. That is, values are right justified when unpacked into int32_t's, but are left justified in the number of bytes used by the original data. Returns the number of bytes used for each sample (1 to 4) in the original file. This is required information for the user of this module because the audio data is returned in the LOWER bytes of the int32_t buffer and must be left-shifted 8, 16, or 24 bits if normalized int32_t's are required. This function will return the actual number of channels decoded from the file (which may or may not be less than the actual number of channels, but will always be 1 or 2). Normally, this will be the front left and right channels of a multi-channel file. Read from current file position until a valid 32-byte WavPack 4.0 header is found and read into the specified pointer. The number of bytes skipped is returned. If no WavPack header is found within 1 meg, then a -1 is returned to indicate the error. No additional bytes are read past the header and it is returned in the processor's native endian mode. Seeking is not required. Open context for writing WavPack files. The returned context pointer is used in all following calls to the library. A return value of NULL indicates that memory could not be allocated for the context. Set configuration for writing WavPack files. This must be done before sending any actual samples, however it is okay to send wrapper or other metadata before calling this. The "config" structure contains the following required information: config->bytes_per_sample     see WavpackGetBytesPerSample() for info config->bits_per_sample      see WavpackGetBitsPerSample() for info config->num_channels         self evident config->sample_rate          self evident In addition, the following fields and flags may be set:  config->flags: -------------- o CONFIG_HYBRID_FLAG         select hybrid mode (must set bitrate) o CONFIG_JOINT_STEREO        select joint stereo (must set override also) o CONFIG_JOINT_OVERRIDE      override default joint stereo selection o CONFIG_HYBRID_SHAPE        select hybrid noise shaping (set override &                                                      shaping_weight != 0.0) o CONFIG_SHAPE_OVERRIDE      override default hybrid noise shaping                               (set CONFIG_HYBRID_SHAPE and shaping_weight) o CONFIG_FAST_FLAG           "fast" compression mode o CONFIG_HIGH_FLAG           "high" compression mode o CONFIG_BITRATE_KBPS        hybrid bitrate is kbps, not bits / sample config->bitrate              hybrid bitrate in either bits/sample or kbps config->shaping_weight       hybrid noise shaping coefficient override config->float_norm_exp       select floating-point data (127 for +/-1.0) If the number of samples to be written is known then it should be passed here. If the duration is not known then pass -1. In the case that the size is not known (or the writing is terminated early) then it is suggested that the application retrieve the first block written and let the library update the total samples indication. A function is provided to do this update and it should be done to the "correction" file also. If this cannot be done (because a pipe is being used, for instance) then a valid WavPack will still be created, but when applications want to access that file they will have to seek all the way to the end to determine the actual duration. Also, if a RIFF header has been included then it should be updated as well or the WavPack file will not be directly unpackable to a valid wav file (although it will still be usable by itself). A return of FALSE indicates an error. Add wrapper (currently RIFF only) to WavPack blocks. This should be called before sending any audio samples. If the exact contents of the RIFF header are not known because, for example, the file duration is uncertain or trailing chunks are possible, simply write a "dummy" header of the correct length. When all data has been written it will be possible to read the first block written and update the header directly. An example of this can be found in the Audition filter. Start a WavPack block to be stored in the specified buffer. This must be called before calling WavpackPackSamples(). Note that writing CANNOT wrap in the buffer; the entire output block must fit in the buffer. Pack the specified samples. Samples must be stored in int32_ts in the native endian format of the executing processor. The number of samples specified indicates composite samples (sometimes called "frames"). So, the actual number of data points would be this "sample_count" times the number of channels. The caller must decide how many samples to place in each WavPack block (1/2 second is common), but this function may be called as many times as desired to build the final block (and performs the actual compression during the call). A return of FALSE indicates an error. Finish the WavPack block being built, returning the total size of the block in bytes. Note that the possible conversion of the WavPack header to little-endian takes place here. Given the pointer to the first block written (to either a .wv or .wvc file), update the block with the actual number of samples written. This should be done if WavpackSetConfiguration() was called with an incorrect number of samples (or -1). It is the responsibility of the application to read and rewrite the block. An example of this can be found in the Audition filter. Given the pointer to the first block written to a WavPack file, this function returns the location of the stored RIFF header that was originally written with WavpackAddWrapper(). This would normally be used to update the wav header to indicate that a different number of samples was actually written or if additional RIFF chunks are written at the end of the file. It is the responsibility of the application to read and rewrite the block. An example of this can be found in the Audition filter.//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //      Distributed under the BSD Software License (see license.txt)      //////////////////////////////////////////////////////////////////////////// wputils.c This module provides a high-level interface for decoding WavPack 4.0 audio streams and files. WavPack data is read with a stream reading callback. No direct seeking is provided for, but it is possible to start decoding anywhere in a WavPack stream. In this case, WavPack will be able to provide the sample-accurate position when it synchs with the data and begins decoding./////////////////////////// local table storage /////////////////////////////////////////////////////// executable code //////////////////////////////// This function reads data from the specified stream in search of a valid WavPack 4.0 audio block. If this fails in 1 megabyte (or an invalid or unsupported WavPack block is encountered) then an appropriate message is copied to "error" and NULL is returned, otherwise a pointer to a WavpackContext structure is returned (which is used to call all other functions in this module). This can be initiated at the beginning of a WavPack file, or anywhere inside a WavPack file. To determine the exact position within the file use WavpackGetSampleIndex(). For demonstration purposes this uses a single static copy of the WavpackContext structure, so obviously it cannot be used for more than one file at a time. Also, this function will not handle "correction" files, plays only the first two channels of multi-channel files, and is limited in resolution in some large integer or floating point files (but always provides at least 24 bits of resolution). open the source file for reading and store the size This function obtains general information about an open file and returns a mask with the following bit values: MODE_LOSSLESS:  file is lossless (pure lossless only) MODE_HYBRID:  file is hybrid mode (lossy part only) MODE_FLOAT:  audio data is 32-bit ieee floating point MODE_HIGH:  file was created in "high" mode (information only) MODE_FAST:  file was created in "fast" mode (information only) Unpack the specified number of samples from the current file position. Note that "samples" here refers to "complete" samples, which would be 2 int32_t's for stereo files. The audio data is returned right-justified in 32-bit int32_t's in the endian mode native to the executing processor. So, if the original data was 16-bit, then the values returned would be +/-32k. Floating point data can also be returned if the source was floating point data (and this is normalized to +/-1.0). The actual number of samples unpacked is returned, which should be equal to the number requested unless the end of fle is encountered or an error occurs. Get total number of samples contained in the WavPack file, or -1 if unknown Get the current sample index position, or -1 if unknown Get the number of errors encountered so far return TRUE if any uncorrected lossy blocks were actually written or read Returns the sample rate of the specified WavPack file Returns the number of channels of the specified WavPack file. Note that this is the actual number of channels contained in the file, but this version can only decode the first two. Returns the actual number of valid bits per sample contained in the original file, which may or may not be a multiple of 8. Floating data always has 32 bits, integers may be from 1 to 32 bits each. When this value is not a multiple of 8, then the "extra" bits are located in the LSBs of the results. That is, values are right justified when unpacked into int32_t's, but are left justified in the number of bytes used by the original data. Returns the number of bytes used for each sample (1 to 4) in the original file. This is required information for the user of this module because the audio data is returned in the LOWER bytes of the int32_t buffer and must be left-shifted 8, 16, or 24 bits if normalized int32_t's are required. This function will return the actual number of channels decoded from the file (which may or may not be less than the actual number of channels, but will always be 1 or 2). Normally, this will be the front left and right channels of a multi-channel file. Read from current file position until a valid 32-byte WavPack 4.0 header is found and read into the specified pointer. The number of bytes skipped is returned. If no WavPack header is found within 1 meg, then a -1 is returned to indicate the error. No additional bytes are read past the header and it is returned in the processor's native endian mode. Seeking is not required. Open context for writing WavPack files. The returned context pointer is used in all following calls to the library. A return value of NULL indicates that memory could not be allocated for the context. Set configuration for writing WavPack files. This must be done before sending any actual samples, however it is okay to send wrapper or other metadata before calling this. The "config" structure contains the following required information: config->bytes_per_sample     see WavpackGetBytesPerSample() for info config->bits_per_sample      see WavpackGetBitsPerSample() for info config->num_channels         self evident config->sample_rate          self evident In addition, the following fields and flags may be set:  config->flags: -------------- o CONFIG_HYBRID_FLAG         select hybrid mode (must set bitrate) o CONFIG_JOINT_STEREO        select joint stereo (must set override also) o CONFIG_JOINT_OVERRIDE      override default joint stereo selection o CONFIG_HYBRID_SHAPE        select hybrid noise shaping (set override &                                                      shaping_weight != 0.0) o CONFIG_SHAPE_OVERRIDE      override default hybrid noise shaping                               (set CONFIG_HYBRID_SHAPE and shaping_weight) o CONFIG_FAST_FLAG           "fast" compression mode o CONFIG_HIGH_FLAG           "high" compression mode o CONFIG_BITRATE_KBPS        hybrid bitrate is kbps, not bits / sample config->bitrate              hybrid bitrate in either bits/sample or kbps config->shaping_weight       hybrid noise shaping coefficient override config->float_norm_exp       select floating-point data (127 for +/-1.0) If the number of samples to be written is known then it should be passed here. If the duration is not known then pass -1. In the case that the size is not known (or the writing is terminated early) then it is suggested that the application retrieve the first block written and let the library update the total samples indication. A function is provided to do this update and it should be done to the "correction" file also. If this cannot be done (because a pipe is being used, for instance) then a valid WavPack will still be created, but when applications want to access that file they will have to seek all the way to the end to determine the actual duration. Also, if a RIFF header has been included then it should be updated as well or the WavPack file will not be directly unpackable to a valid wav file (although it will still be usable by itself). A return of FALSE indicates an error. Add wrapper (currently RIFF only) to WavPack blocks. This should be called before sending any audio samples. If the exact contents of the RIFF header are not known because, for example, the file duration is uncertain or trailing chunks are possible, simply write a "dummy" header of the correct length. When all data has been written it will be possible to read the first block written and update the header directly. An example of this can be found in the Audition filter. Start a WavPack block to be stored in the specified buffer. This must be called before calling WavpackPackSamples(). Note that writing CANNOT wrap in the buffer; the entire output block must fit in the buffer. Pack the specified samples. Samples must be stored in int32_ts in the native endian format of the executing processor. The number of samples specified indicates composite samples (sometimes called "frames"). So, the actual number of data points would be this "sample_count" times the number of channels. The caller must decide how many samples to place in each WavPack block (1/2 second is common), but this function may be called as many times as desired to build the final block (and performs the actual compression during the call). A return of FALSE indicates an error. Finish the WavPack block being built, returning the total size of the block in bytes. Note that the possible conversion of the WavPack header to little-endian takes place here. Given the pointer to the first block written (to either a .wv or .wvc file), update the block with the actual number of samples written. This should be done if WavpackSetConfiguration() was called with an incorrect number of samples (or -1). It is the responsibility of the application to read and rewrite the block. An example of this can be found in the Audition filter. Given the pointer to the first block written to a WavPack file, this function returns the location of the stored RIFF header that was originally written with WavpackAddWrapper(). This would normally be used to update the wav header to indicate that a different number of samples was actually written or if additional RIFF chunks are written at the end of the file. It is the responsibility of the application to read and rewrite the block. An example of this can be found in the Audition filter.//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //      Distributed under the BSD Software License (see license.txt)      //////////////////////////////////////////////////////////////////////////// wputils.c This module provides a high-level interface for decoding WavPack 4.0 audio streams and files. WavPack data is read with a stream reading callback. No direct seeking is provided for, but it is possible to start decoding anywhere in a WavPack stream. In this case, WavPack will be able to provide the sample-accurate position when it synchs with the data and begins decoding./////////////////////////// local table storage /////////////////////////////////////////////////////// executable code //////////////////////////////// This function reads data from the specified stream in search of a valid WavPack 4.0 audio block. If this fails in 1 megabyte (or an invalid or unsupported WavPack block is encountered) then an appropriate message is copied to "error" and NULL is returned, otherwise a pointer to a WavpackContext structure is returned (which is used to call all other functions in this module). This can be initiated at the beginning of a WavPack file, or anywhere inside a WavPack file. To determine the exact position within the file use WavpackGetSampleIndex(). For demonstration purposes this uses a single static copy of the WavpackContext structure, so obviously it cannot be used for more than one file at a time. Also, this function will not handle "correction" files, plays only the first two channels of multi-channel files, and is limited in resolution in some large integer or floating point files (but always provides at least 24 bits of resolution). open the source file for reading and store the size This function obtains general information about an open file and returns a mask with the following bit values: MODE_LOSSLESS:  file is lossless (pure lossless only) MODE_HYBRID:  file is hybrid mode (lossy part only) MODE_FLOAT:  audio data is 32-bit ieee floating point MODE_HIGH:  file was created in "high" mode (information only) MODE_FAST:  file was created in "fast" mode (information only) Unpack the specified number of samples from the current file position. Note that "samples" here refers to "complete" samples, which would be 2 int32_t's for stereo files. The audio data is returned right-justified in 32-bit int32_t's in the endian mode native to the executing processor. So, if the original data was 16-bit, then the values returned would be +/-32k. Floating point data can also be returned if the source was floating point data (and this is normalized to +/-1.0). The actual number of samples unpacked is returned, which should be equal to the number requested unless the end of fle is encountered or an error occurs. Get total number of samples contained in the WavPack file, or -1 if unknown Get the current sample index position, or -1 if unknown Get the number of errors encountered so far return TRUE if any uncorrected lossy blocks were actually written or read Returns the sample rate of the specified WavPack file Returns the number of channels of the specified WavPack file. Note that this is the actual number of channels contained in the file, but this version can only decode the first two. Returns the actual number of valid bits per sample contained in the original file, which may or may not be a multiple of 8. Floating data always has 32 bits, integers may be from 1 to 32 bits each. When this value is not a multiple of 8, then the "extra" bits are located in the LSBs of the results. That is, values are right justified when unpacked into int32_t's, but are left justified in the number of bytes used by the original data. Returns the number of bytes used for each sample (1 to 4) in the original file. This is required information for the user of this module because the audio data is returned in the LOWER bytes of the int32_t buffer and must be left-shifted 8, 16, or 24 bits if normalized int32_t's are required. This function will return the actual number of channels decoded from the file (which may or may not be less than the actual number of channels, but will always be 1 or 2). Normally, this will be the front left and right channels of a multi-channel file. Read from current file position until a valid 32-byte WavPack 4.0 header is found and read into the specified pointer. The number of bytes skipped is returned. If no WavPack header is found within 1 meg, then a -1 is returned to indicate the error. No additional bytes are read past the header and it is returned in the processor's native endian mode. Seeking is not required. Open context for writing WavPack files. The returned context pointer is used in all following calls to the library. A return value of NULL indicates that memory could not be allocated for the context. Set configuration for writing WavPack files. This must be done before sending any actual samples, however it is okay to send wrapper or other metadata before calling this. The "config" structure contains the following required information: config->bytes_per_sample     see WavpackGetBytesPerSample() for info config->bits_per_sample      see WavpackGetBitsPerSample() for info config->num_channels         self evident config->sample_rate          self evident In addition, the following fields and flags may be set:  config->flags: -------------- o CONFIG_HYBRID_FLAG         select hybrid mode (must set bitrate) o CONFIG_JOINT_STEREO        select joint stereo (must set override also) o CONFIG_JOINT_OVERRIDE      override default joint stereo selection o CONFIG_HYBRID_SHAPE        select hybrid noise shaping (set override &                                                      shaping_weight != 0.0) o CONFIG_SHAPE_OVERRIDE      override default hybrid noise shaping                               (set CONFIG_HYBRID_SHAPE and shaping_weight) o CONFIG_FAST_FLAG           "fast" compression mode o CONFIG_HIGH_FLAG           "high" compression mode o CONFIG_BITRATE_KBPS        hybrid bitrate is kbps, not bits / sample config->bitrate              hybrid bitrate in either bits/sample or kbps config->shaping_weight       hybrid noise shaping coefficient override config->float_norm_exp       select floating-point data (127 for +/-1.0) If the number of samples to be written is known then it should be passed here. If the duration is not known then pass -1. In the case that the size is not known (or the writing is terminated early) then it is suggested that the application retrieve the first block written and let the library update the total samples indication. A function is provided to do this update and it should be done to the "correction" file also. If this cannot be done (because a pipe is being used, for instance) then a valid WavPack will still be created, but when applications want to access that file they will have to seek all the way to the end to determine the actual duration. Also, if a RIFF header has been included then it should be updated as well or the WavPack file will not be directly unpackable to a valid wav file (although it will still be usable by itself). A return of FALSE indicates an error. Add wrapper (currently RIFF only) to WavPack blocks. This should be called before sending any audio samples. If the exact contents of the RIFF header are not known because, for example, the file duration is uncertain or trailing chunks are possible, simply write a "dummy" header of the correct length. When all data has been written it will be possible to read the first block written and update the header directly. An example of this can be found in the Audition filter. Start a WavPack block to be stored in the specified buffer. This must be called before calling WavpackPackSamples(). Note that writing CANNOT wrap in the buffer; the entire output block must fit in the buffer. Pack the specified samples. Samples must be stored in int32_ts in the native endian format of the executing processor. The number of samples specified indicates composite samples (sometimes called "frames"). So, the actual number of data points would be this "sample_count" times the number of channels. The caller must decide how many samples to place in each WavPack block (1/2 second is common), but this function may be called as many times as desired to build the final block (and performs the actual compression during the call). A return of FALSE indicates an error. Finish the WavPack block being built, returning the total size of the block in bytes. Note that the possible conversion of the WavPack header to little-endian takes place here. Given the pointer to the first block written (to either a .wv or .wvc file), update the block with the actual number of samples written. This should be done if WavpackSetConfiguration() was called with an incorrect number of samples (or -1). It is the responsibility of the application to read and rewrite the block. An example of this can be found in the Audition filter. Given the pointer to the first block written to a WavPack file, this function returns the location of the stored RIFF header that was originally written with WavpackAddWrapper(). This would normally be used to update the wav header to indicate that a different number of samples was actually written or if additional RIFF chunks are written at the end of the file. It is the responsibility of the application to read and rewrite the block. An example of this can be found in the Audition filter.