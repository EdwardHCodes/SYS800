
** $Id: lstrlib.c,v 1.132.1.5 2010/05/14 15:34:19 roberto Exp $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
 macro to `unsign' a character  relative string position: negative means back from end  empty interval; return no values  overflow?  number of arguments 
** {======================================================
** PATTERN MATCHING
** =======================================================
 init of source string  end (`\0') of source string  total number of captures (finished or unfinished)  look for a `]'  skip escapes (e.g. `%]')  skip the `^'  matches any char  string ends out of balance  counts maximum expand for item  keeps trying to match with the maximum repetitions  else didn't match; reduce 1 repetition to try again  try with one more repetition  match failed?  undo capture  close capture  match failed?  undo capture  using goto's to optimize tail recursion  start capture  position capture?  end capture  balanced string?  else return match(ms, s, p+4);  frontier?  points to what is next  else return match(ms, s, ep);  capture results (%0-%9)?  else return match(ms, s, p+2)  case default  end of pattern  match succeeded  is the `$' the last char in pattern?  check end of string  it is a pattern item  points to what is next  optional  else return match(ms, s, ep+1);  0 or more repetitions  1 or more repetitions  0 or more repetitions (minimum)  else return match(ms, s+1, ep);  empty strings are everywhere  avoids a negative `l1'  to search for a `*s2' inside `s1'  1st char will be checked by `memchr'  `s2' cannot be found after that  1st char is already checked  correct `l1' and `s1' to try again  not found  ms->level == 0, too  add whole match  number of strings pushed  explicit request?  or no special characters?  do a plain search  start  end  not found  empty match? go at least one position  not found  skip ESC  add capture to accumulated result  nil or false?  keep original text  add result to accumulator  non empty match?  skip it  number of substitutions  }======================================================  maximum size of each formatted item (> len(format('%99.99f', -1e308)))  valid flags in a format specification 
** maximum size of each format specification (such as '%-099.99d')
** (+10 accounts for %99.99x plus margin of error)
 skip flags  skip width  (2 digits at most)  skip precision  (2 digits at most)  %%  format item  to store the format (`%...')  to store the formatted item  ROCKLUA NO FLOATING POINT  skip the 'addsize' at the end  no precision and string is too long to be formatted;
               keep original string  skip the `addsize' at the end  also treat cases `pnLlh'  create metatable for strings  dummy string  set string metatable  pop dummy string  string library...  ...is the __index metamethod  pop metatable 
** Open string library

** $Id: lstrlib.c,v 1.132.1.5 2010/05/14 15:34:19 roberto Exp $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
 macro to `unsign' a character  relative string position: negative means back from end  empty interval; return no values  overflow?  number of arguments 
** {======================================================
** PATTERN MATCHING
** =======================================================
 init of source string  end (`\0') of source string  total number of captures (finished or unfinished)  look for a `]'  skip escapes (e.g. `%]')  skip the `^'  matches any char  string ends out of balance  counts maximum expand for item  keeps trying to match with the maximum repetitions  else didn't match; reduce 1 repetition to try again  try with one more repetition  match failed?  undo capture  close capture  match failed?  undo capture  using goto's to optimize tail recursion  start capture  position capture?  end capture  balanced string?  else return match(ms, s, p+4);  frontier?  points to what is next  else return match(ms, s, ep);  capture results (%0-%9)?  else return match(ms, s, p+2)  case default  end of pattern  match succeeded  is the `$' the last char in pattern?  check end of string  it is a pattern item  points to what is next  optional  else return match(ms, s, ep+1);  0 or more repetitions  1 or more repetitions  0 or more repetitions (minimum)  else return match(ms, s+1, ep);  empty strings are everywhere  avoids a negative `l1'  to search for a `*s2' inside `s1'  1st char will be checked by `memchr'  `s2' cannot be found after that  1st char is already checked  correct `l1' and `s1' to try again  not found  ms->level == 0, too  add whole match  number of strings pushed  explicit request?  or no special characters?  do a plain search  start  end  not found  empty match? go at least one position  not found  skip ESC  add capture to accumulated result  nil or false?  keep original text  add result to accumulator  non empty match?  skip it  number of substitutions  }======================================================  maximum size of each formatted item (> len(format('%99.99f', -1e308)))  valid flags in a format specification 
** maximum size of each format specification (such as '%-099.99d')
** (+10 accounts for %99.99x plus margin of error)
 skip flags  skip width  (2 digits at most)  skip precision  (2 digits at most)  %%  format item  to store the format (`%...')  to store the formatted item  ROCKLUA NO FLOATING POINT  skip the 'addsize' at the end  no precision and string is too long to be formatted;
               keep original string  skip the `addsize' at the end  also treat cases `pnLlh'  create metatable for strings  dummy string  set string metatable  pop dummy string  string library...  ...is the __index metamethod  pop metatable 
** Open string library

** $Id: lstrlib.c,v 1.132.1.5 2010/05/14 15:34:19 roberto Exp $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
 macro to `unsign' a character  relative string position: negative means back from end  empty interval; return no values  overflow?  number of arguments 
** {======================================================
** PATTERN MATCHING
** =======================================================
 init of source string  end (`\0') of source string  total number of captures (finished or unfinished)  look for a `]'  skip escapes (e.g. `%]')  skip the `^'  matches any char  string ends out of balance  counts maximum expand for item  keeps trying to match with the maximum repetitions  else didn't match; reduce 1 repetition to try again  try with one more repetition  match failed?  undo capture  close capture  match failed?  undo capture  using goto's to optimize tail recursion  start capture  position capture?  end capture  balanced string?  else return match(ms, s, p+4);  frontier?  points to what is next  else return match(ms, s, ep);  capture results (%0-%9)?  else return match(ms, s, p+2)  case default  end of pattern  match succeeded  is the `$' the last char in pattern?  check end of string  it is a pattern item  points to what is next  optional  else return match(ms, s, ep+1);  0 or more repetitions  1 or more repetitions  0 or more repetitions (minimum)  else return match(ms, s+1, ep);  empty strings are everywhere  avoids a negative `l1'  to search for a `*s2' inside `s1'  1st char will be checked by `memchr'  `s2' cannot be found after that  1st char is already checked  correct `l1' and `s1' to try again  not found  ms->level == 0, too  add whole match  number of strings pushed  explicit request?  or no special characters?  do a plain search  start  end  not found  empty match? go at least one position  not found  skip ESC  add capture to accumulated result  nil or false?  keep original text  add result to accumulator  non empty match?  skip it  number of substitutions  }======================================================  maximum size of each formatted item (> len(format('%99.99f', -1e308)))  valid flags in a format specification 
** maximum size of each format specification (such as '%-099.99d')
** (+10 accounts for %99.99x plus margin of error)
 skip flags  skip width  (2 digits at most)  skip precision  (2 digits at most)  %%  format item  to store the format (`%...')  to store the formatted item  ROCKLUA NO FLOATING POINT  skip the 'addsize' at the end  no precision and string is too long to be formatted;
               keep original string  skip the `addsize' at the end  also treat cases `pnLlh'  create metatable for strings  dummy string  set string metatable  pop dummy string  string library...  ...is the __index metamethod  pop metatable 
** Open string library
