*
 * A simulated Blood Pressure Monitor, that starts out publishing BP measurements
 * using the same metrics as the physical device we are trying to emulate.  This is
 * to be used initially alongside the SimControllablePump that we also created to test
 * the behaviour of the closed loop control app.
 * 
 * @author simon
 *
 *
	 * An array of values to be used for the systolic samples.  These were taken by running the real device we are emulating
	 * and then reading the values back from the database.
	 * 
	 * TODO: Get all the values from new_floats_from_bp and see if that makes it smoother
	 * 
	 *
		 * Following block of code is for receiving objectives for the BP...
		 *
         * Following block of code is for receiving run/stop commands.
         We can reuse the same params that we already have, as they are only to match the device id. TODO Auto-generated method stub*
	 * pause or resume the production of data.
	 * @param running if true, then resume, else pause.
	 * @throws IOException
	 Completely fake com port property that is useful for distinguishing instances		final InstanceHolder<SampleArray> diaHolder=null;		final InstanceHolder<SampleArray> sysHolder=null;Instance(rosetta.MDC_FLOW_FLUID_PUMP.VALUE, "");We have access to "executor" - a scheduled executor service	 We use the global "running" variable to allow the pause/resume objective listener to controlif data is being emitted or not.*
 * A simulated Blood Pressure Monitor, that starts out publishing BP measurements
 * using the same metrics as the physical device we are trying to emulate.  This is
 * to be used initially alongside the SimControllablePump that we also created to test
 * the behaviour of the closed loop control app.
 * 
 * @author simon
 *
 *
	 * An array of values to be used for the systolic samples.  These were taken by running the real device we are emulating
	 * and then reading the values back from the database.
	 * 
	 * TODO: Get all the values from new_floats_from_bp and see if that makes it smoother
	 * 
	 *
		 * Following block of code is for receiving objectives for the BP...
		 *
         * Following block of code is for receiving run/stop commands.
         We can reuse the same params that we already have, as they are only to match the device id. TODO Auto-generated method stub*
	 * pause or resume the production of data.
	 * @param running if true, then resume, else pause.
	 * @throws IOException
	 Completely fake com port property that is useful for distinguishing instances		final InstanceHolder<SampleArray> diaHolder=null;		final InstanceHolder<SampleArray> sysHolder=null;Instance(rosetta.MDC_FLOW_FLUID_PUMP.VALUE, "");We have access to "executor" - a scheduled executor service	 We use the global "running" variable to allow the pause/resume objective listener to controlif data is being emitted or not.*
 * A simulated Blood Pressure Monitor, that starts out publishing BP measurements
 * using the same metrics as the physical device we are trying to emulate.  This is
 * to be used initially alongside the SimControllablePump that we also created to test
 * the behaviour of the closed loop control app.
 * 
 * @author simon
 *
 *
	 * An array of values to be used for the systolic samples.  These were taken by running the real device we are emulating
	 * and then reading the values back from the database.
	 * 
	 * TODO: Get all the values from new_floats_from_bp and see if that makes it smoother
	 * 
	 *
		 * Following block of code is for receiving objectives for the BP...
		 *
         * Following block of code is for receiving run/stop commands.
         We can reuse the same params that we already have, as they are only to match the device id. TODO Auto-generated method stub*
	 * pause or resume the production of data.
	 * @param running if true, then resume, else pause.
	 * @throws IOException
	 Completely fake com port property that is useful for distinguishing instances		final InstanceHolder<SampleArray> diaHolder=null;		final InstanceHolder<SampleArray> sysHolder=null;Instance(rosetta.MDC_FLOW_FLUID_PUMP.VALUE, "");We have access to "executor" - a scheduled executor service	 We use the global "running" variable to allow the pause/resume objective listener to controlif data is being emitted or not.*
 * A simulated Blood Pressure Monitor, that starts out publishing BP measurements
 * using the same metrics as the physical device we are trying to emulate.  This is
 * to be used initially alongside the SimControllablePump that we also created to test
 * the behaviour of the closed loop control app.
 * 
 * @author simon
 *
 *
	 * An array of values to be used for the systolic samples.  These were taken by running the real device we are emulating
	 * and then reading the values back from the database.
	 * 
	 * TODO: Get all the values from new_floats_from_bp and see if that makes it smoother
	 * 
	 *
		 * Following block of code is for receiving objectives for the BP...
		 *
         * Following block of code is for receiving run/stop commands.
         We can reuse the same params that we already have, as they are only to match the device id. TODO Auto-generated method stub*
	 * pause or resume the production of data.
	 * @param running if true, then resume, else pause.
	 * @throws IOException
	 Completely fake com port property that is useful for distinguishing instances		final InstanceHolder<SampleArray> diaHolder=null;		final InstanceHolder<SampleArray> sysHolder=null;Instance(rosetta.MDC_FLOW_FLUID_PUMP.VALUE, "");We have access to "executor" - a scheduled executor service	 We use the global "running" variable to allow the pause/resume objective listener to controlif data is being emitted or not.