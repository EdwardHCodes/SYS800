 Persistent configuration  use long for aligning  the current full file name  list of the mod files  The MP3 audio buffer which we will use as heap memory  amount of bytes left in audio_buffer 
* strncat wrapper
 Loop over the data in s1.   s now points to s1's trailing null character, now copy
    up to n bytes from s2 into s1 stopping if a null character
    is encountered in s2.
    It is not safe to use strncpy here since it copies EXACTLY n
    characters, NULL padding if necessary.  
* sprintf wrapper

* printf wrapper
 bool ok;  ok =  Device LCDs display newlines funny. ************************ File Access ************************** support function for qsort()  not used
static int compare(const void* p1, const void* p2)
{
    return rb->strcasecmp(*((char **)p1), *((char **)p2));
}
Read directory contents for scrolling.  Remove path and leave only the name. Set Selected File.  remove 'erased' file names from list. ****************************************************************************
* Playback
printf("Buffer miss!");	MikMod_Reset("");  BROKEN!*
  Shows the settings menu
 *
  Show the main menu
  double buffering thread  Prevent idle poweroff 
* Plugin entry point
*
 Select playback add_pool(audio_buffer, audio_buffer_free); If there's no configured rate, use the default  Persistent configuration  use long for aligning  the current full file name  list of the mod files  The MP3 audio buffer which we will use as heap memory  amount of bytes left in audio_buffer 
* strncat wrapper
 Loop over the data in s1.   s now points to s1's trailing null character, now copy
    up to n bytes from s2 into s1 stopping if a null character
    is encountered in s2.
    It is not safe to use strncpy here since it copies EXACTLY n
    characters, NULL padding if necessary.  
* sprintf wrapper

* printf wrapper
 bool ok;  ok =  Device LCDs display newlines funny. ************************ File Access ************************** support function for qsort()  not used
static int compare(const void* p1, const void* p2)
{
    return rb->strcasecmp(*((char **)p1), *((char **)p2));
}
Read directory contents for scrolling.  Remove path and leave only the name. Set Selected File.  remove 'erased' file names from list. ****************************************************************************
* Playback
printf("Buffer miss!");	MikMod_Reset("");  BROKEN!*
  Shows the settings menu
 *
  Show the main menu
  double buffering thread  Prevent idle poweroff 
* Plugin entry point
*
 Select playback add_pool(audio_buffer, audio_buffer_free); If there's no configured rate, use the default  Persistent configuration  use long for aligning  the current full file name  list of the mod files  The MP3 audio buffer which we will use as heap memory  amount of bytes left in audio_buffer 
* strncat wrapper
 Loop over the data in s1.   s now points to s1's trailing null character, now copy
    up to n bytes from s2 into s1 stopping if a null character
    is encountered in s2.
    It is not safe to use strncpy here since it copies EXACTLY n
    characters, NULL padding if necessary.  
* sprintf wrapper

* printf wrapper
 bool ok;  ok =  Device LCDs display newlines funny. ************************ File Access ************************** support function for qsort()  not used
static int compare(const void* p1, const void* p2)
{
    return rb->strcasecmp(*((char **)p1), *((char **)p2));
}
Read directory contents for scrolling.  Remove path and leave only the name. Set Selected File.  remove 'erased' file names from list. ****************************************************************************
* Playback
printf("Buffer miss!");	MikMod_Reset("");  BROKEN!*
  Shows the settings menu
 *
  Show the main menu
  double buffering thread  Prevent idle poweroff 
* Plugin entry point
*
 Select playback add_pool(audio_buffer, audio_buffer_free); If there's no configured rate, use the default 