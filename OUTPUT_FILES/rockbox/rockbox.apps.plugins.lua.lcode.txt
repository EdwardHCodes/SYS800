
** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
 no jumps to current position?  function start?  positions are already clean  can connect both?  else no optimization  save list of jumps to here  keep them on hold 
** returns current `pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
 point to itself represents end of list  end of list  turn offset into absolute position 
** check whether list has any jump that do not produce a value
** (or produce an inverted value)
 not found  cannot patch other instructions  no register to put value or register already has the value  jump to default target  find last element  constant not found; create a new entry  cannot use nil as key; instead use table itself to represent nil  expression is an open function call?  expression is an open function call?  can relocate its simple result  there is one value available (somewhere)  those instructions may be jump targets  nothing to do...  put this jump in `t' list  position after whole expression  position of an eventual LOAD false  position of an eventual LOAD true  exp is already in a register  reg. is not a local?  put value on it  default  constant fit in RK operand?  constant fit in argC?  not a constant in the right range: put it in a register  invalid var kind to store  remove previous OP_NOT  else go through  pc of last jump  always true; do nothing  insert last jump in `f' list  pc of last jump  always false; do nothing  insert last jump in `t' list  cannot happen  interchange true and false lists  ROCKLUA BUGFIX  do not attempt to divide by 0  ROCKLUA BUGFIX  do not attempt to divide by 0  no constant folding for 'len'  do not attempt to produce NaN  ROCKLUA BUGFIX  exchange args to replace by `<' or `<='  o1 <==> o2  cannot operate on non-numeric constants  cannot operate on constants  operand must be on the `stack'  list must be closed  list must be closed  operand must be on the 'stack' 
 * Attempted to write to last (null terminator) byte of lineinfo, so need
 * to grow the lineinfo vector and extend the fill bytes
  using the macro results in a redundant if test, but what the hell  Handle first time through when lineinfo points is NULL  The fixup line can be the same as existing one and in this case there's nothing to do  first remove the current line reference  this is simply decrementing the last count a multi-PC line  it's a bit more complicated if it's the 1st instruction on the line  this logic handles <i/c> [1snnnnnnn [1nnnnnnn]*]? <i/c=1>  work backwards over the coded delta computing the delta  and reposition the FuncState lastline pointers at the previous instruction count  Then add the new line reference  `pc' will change  put new instruction in code array  save corresponding line information  note that frst time fs->lastline==0 through, so the else branch is taken  The last instruction is occasionally overwritten as part of branch optimisation panic if its anything other than this !!  free registers with list values 
** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
 no jumps to current position?  function start?  positions are already clean  can connect both?  else no optimization  save list of jumps to here  keep them on hold 
** returns current `pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
 point to itself represents end of list  end of list  turn offset into absolute position 
** check whether list has any jump that do not produce a value
** (or produce an inverted value)
 not found  cannot patch other instructions  no register to put value or register already has the value  jump to default target  find last element  constant not found; create a new entry  cannot use nil as key; instead use table itself to represent nil  expression is an open function call?  expression is an open function call?  can relocate its simple result  there is one value available (somewhere)  those instructions may be jump targets  nothing to do...  put this jump in `t' list  position after whole expression  position of an eventual LOAD false  position of an eventual LOAD true  exp is already in a register  reg. is not a local?  put value on it  default  constant fit in RK operand?  constant fit in argC?  not a constant in the right range: put it in a register  invalid var kind to store  remove previous OP_NOT  else go through  pc of last jump  always true; do nothing  insert last jump in `f' list  pc of last jump  always false; do nothing  insert last jump in `t' list  cannot happen  interchange true and false lists  ROCKLUA BUGFIX  do not attempt to divide by 0  ROCKLUA BUGFIX  do not attempt to divide by 0  no constant folding for 'len'  do not attempt to produce NaN  ROCKLUA BUGFIX  exchange args to replace by `<' or `<='  o1 <==> o2  cannot operate on non-numeric constants  cannot operate on constants  operand must be on the `stack'  list must be closed  list must be closed  operand must be on the 'stack' 
 * Attempted to write to last (null terminator) byte of lineinfo, so need
 * to grow the lineinfo vector and extend the fill bytes
  using the macro results in a redundant if test, but what the hell  Handle first time through when lineinfo points is NULL  The fixup line can be the same as existing one and in this case there's nothing to do  first remove the current line reference  this is simply decrementing the last count a multi-PC line  it's a bit more complicated if it's the 1st instruction on the line  this logic handles <i/c> [1snnnnnnn [1nnnnnnn]*]? <i/c=1>  work backwards over the coded delta computing the delta  and reposition the FuncState lastline pointers at the previous instruction count  Then add the new line reference  `pc' will change  put new instruction in code array  save corresponding line information  note that frst time fs->lastline==0 through, so the else branch is taken  The last instruction is occasionally overwritten as part of branch optimisation panic if its anything other than this !!  free registers with list values 
** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
 no jumps to current position?  function start?  positions are already clean  can connect both?  else no optimization  save list of jumps to here  keep them on hold 
** returns current `pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
 point to itself represents end of list  end of list  turn offset into absolute position 
** check whether list has any jump that do not produce a value
** (or produce an inverted value)
 not found  cannot patch other instructions  no register to put value or register already has the value  jump to default target  find last element  constant not found; create a new entry  cannot use nil as key; instead use table itself to represent nil  expression is an open function call?  expression is an open function call?  can relocate its simple result  there is one value available (somewhere)  those instructions may be jump targets  nothing to do...  put this jump in `t' list  position after whole expression  position of an eventual LOAD false  position of an eventual LOAD true  exp is already in a register  reg. is not a local?  put value on it  default  constant fit in RK operand?  constant fit in argC?  not a constant in the right range: put it in a register  invalid var kind to store  remove previous OP_NOT  else go through  pc of last jump  always true; do nothing  insert last jump in `f' list  pc of last jump  always false; do nothing  insert last jump in `t' list  cannot happen  interchange true and false lists  ROCKLUA BUGFIX  do not attempt to divide by 0  ROCKLUA BUGFIX  do not attempt to divide by 0  no constant folding for 'len'  do not attempt to produce NaN  ROCKLUA BUGFIX  exchange args to replace by `<' or `<='  o1 <==> o2  cannot operate on non-numeric constants  cannot operate on constants  operand must be on the `stack'  list must be closed  list must be closed  operand must be on the 'stack' 
 * Attempted to write to last (null terminator) byte of lineinfo, so need
 * to grow the lineinfo vector and extend the fill bytes
  using the macro results in a redundant if test, but what the hell  Handle first time through when lineinfo points is NULL  The fixup line can be the same as existing one and in this case there's nothing to do  first remove the current line reference  this is simply decrementing the last count a multi-PC line  it's a bit more complicated if it's the 1st instruction on the line  this logic handles <i/c> [1snnnnnnn [1nnnnnnn]*]? <i/c=1>  work backwards over the coded delta computing the delta  and reposition the FuncState lastline pointers at the previous instruction count  Then add the new line reference  `pc' will change  put new instruction in code array  save corresponding line information  note that frst time fs->lastline==0 through, so the else branch is taken  The last instruction is occasionally overwritten as part of branch optimisation panic if its anything other than this !!  free registers with list values 