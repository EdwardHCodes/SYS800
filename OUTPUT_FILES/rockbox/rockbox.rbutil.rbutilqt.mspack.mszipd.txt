 This file is part of libmspack.
 * (C) 2003-2010 Stuart Caie.
 *
 * The deflate method was created by Phil Katz. MSZIP is equivalent to the
 * deflate method.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
  MS-ZIP decompression implementation.  import bit-reading macros and code  import huffman macros and code  match lengths for literal codes 257.. 285  match offsets for distance codes 0 .. 29  extra bits required for literal codes 257.. 285  extra bits required for distance codes 0 .. 29  the order of the bit length Huffman code lengths  inflate() error codes  unknown block type                       block size complement mismatch           error from flush_window() callback       too many bits in bit buffer              too many symbols in blocktype 2 header   failed to build bitlens huffman table    failed to build literals huffman table   failed to build distance huffman table   bitlen RLE code goes over table size     invalid bit-length code                  out-of-range literal code                out-of-range distance code               somehow, distance is beyond 32k          out of bits decoding huffman symbol      for the bit buffer and huffman decoding  bitlen Huffman codes -- immediate lookup, 7 bit max code length  read the number of codes  read in the bit lengths in their unusual order  create decoding table with an immediate lookup  read literal / distance code lengths  single-level huffman lookup  copy LITERAL code lengths and clear any remaining  a clean implementation of RFC 1951 / inflate  for the bit buffer and huffman decoding  read in last block bit  read in block type  uncompressed block  go to byte boundary  read 4 bytes of data, emptying the bit-buffer if necessary  get the length and its complement  read and copy the uncompressed data into the window  Huffman-compressed LZ77 block  block with fixed Huffman codes  block with dynamic Huffman codes  now huffman lengths are read for either kind of block, 
       * create huffman decoding tables  decode forever until end of block code  END OF BLOCK CODE: loop break point  codes 257-285 are matches  codes 286-287 are illegal  match position is window position minus distance. If distance
           * is more than window position numerically, it must 'wrap
           * around' the frame size.  copy match  short match, use slower loop but no loop setup code  longer match, use faster loop but with setup expense  else (code >= 257)  for(;;) -- break point at 'code == 256'  block_type == 3 -- bad block type  flush the remaining data  return success  inflate() calls this whenever the window should be flushed. As
 * MSZIP only expands to the size of the window, the implementation used
 * simply keeps track of the amount of data flushed, and if more than 32k
 * is flushed, an error is raised.
  round up input buffer size to multiple of two  allocate decompression state  allocate input buffer  initialise decompression state  for the bit buffer  easy answers  flush out any stored-up bytes before we begin  unpack another block  skip to next read 'CK' header  align to bytestream  inflate a block, repair and realign if necessary  recover partially-inflated buffers  write a frame  mspack errors (i.e. read errors) are fatal and can't be recovered  for the bit buffer  unpack blocks until block_len == 0  align to bytestream, read block_len  read "CK" header  inflate block  write inflated block  This file is part of libmspack.
 * (C) 2003-2010 Stuart Caie.
 *
 * The deflate method was created by Phil Katz. MSZIP is equivalent to the
 * deflate method.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
  MS-ZIP decompression implementation.  import bit-reading macros and code  import huffman macros and code  match lengths for literal codes 257.. 285  match offsets for distance codes 0 .. 29  extra bits required for literal codes 257.. 285  extra bits required for distance codes 0 .. 29  the order of the bit length Huffman code lengths  inflate() error codes  unknown block type                       block size complement mismatch           error from flush_window() callback       too many bits in bit buffer              too many symbols in blocktype 2 header   failed to build bitlens huffman table    failed to build literals huffman table   failed to build distance huffman table   bitlen RLE code goes over table size     invalid bit-length code                  out-of-range literal code                out-of-range distance code               somehow, distance is beyond 32k          out of bits decoding huffman symbol      for the bit buffer and huffman decoding  bitlen Huffman codes -- immediate lookup, 7 bit max code length  read the number of codes  read in the bit lengths in their unusual order  create decoding table with an immediate lookup  read literal / distance code lengths  single-level huffman lookup  copy LITERAL code lengths and clear any remaining  a clean implementation of RFC 1951 / inflate  for the bit buffer and huffman decoding  read in last block bit  read in block type  uncompressed block  go to byte boundary  read 4 bytes of data, emptying the bit-buffer if necessary  get the length and its complement  read and copy the uncompressed data into the window  Huffman-compressed LZ77 block  block with fixed Huffman codes  block with dynamic Huffman codes  now huffman lengths are read for either kind of block, 
       * create huffman decoding tables  decode forever until end of block code  END OF BLOCK CODE: loop break point  codes 257-285 are matches  codes 286-287 are illegal  match position is window position minus distance. If distance
           * is more than window position numerically, it must 'wrap
           * around' the frame size.  copy match  short match, use slower loop but no loop setup code  longer match, use faster loop but with setup expense  else (code >= 257)  for(;;) -- break point at 'code == 256'  block_type == 3 -- bad block type  flush the remaining data  return success  inflate() calls this whenever the window should be flushed. As
 * MSZIP only expands to the size of the window, the implementation used
 * simply keeps track of the amount of data flushed, and if more than 32k
 * is flushed, an error is raised.
  round up input buffer size to multiple of two  allocate decompression state  allocate input buffer  initialise decompression state  for the bit buffer  easy answers  flush out any stored-up bytes before we begin  unpack another block  skip to next read 'CK' header  align to bytestream  inflate a block, repair and realign if necessary  recover partially-inflated buffers  write a frame  mspack errors (i.e. read errors) are fatal and can't be recovered  for the bit buffer  unpack blocks until block_len == 0  align to bytestream, read block_len  read "CK" header  inflate block  write inflated block  This file is part of libmspack.
 * (C) 2003-2010 Stuart Caie.
 *
 * The deflate method was created by Phil Katz. MSZIP is equivalent to the
 * deflate method.
 *
 * libmspack is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License (LGPL) version 2.1
 *
 * For further details, see the file COPYING.LIB distributed with libmspack
  MS-ZIP decompression implementation.  import bit-reading macros and code  import huffman macros and code  match lengths for literal codes 257.. 285  match offsets for distance codes 0 .. 29  extra bits required for literal codes 257.. 285  extra bits required for distance codes 0 .. 29  the order of the bit length Huffman code lengths  inflate() error codes  unknown block type                       block size complement mismatch           error from flush_window() callback       too many bits in bit buffer              too many symbols in blocktype 2 header   failed to build bitlens huffman table    failed to build literals huffman table   failed to build distance huffman table   bitlen RLE code goes over table size     invalid bit-length code                  out-of-range literal code                out-of-range distance code               somehow, distance is beyond 32k          out of bits decoding huffman symbol      for the bit buffer and huffman decoding  bitlen Huffman codes -- immediate lookup, 7 bit max code length  read the number of codes  read in the bit lengths in their unusual order  create decoding table with an immediate lookup  read literal / distance code lengths  single-level huffman lookup  copy LITERAL code lengths and clear any remaining  a clean implementation of RFC 1951 / inflate  for the bit buffer and huffman decoding  read in last block bit  read in block type  uncompressed block  go to byte boundary  read 4 bytes of data, emptying the bit-buffer if necessary  get the length and its complement  read and copy the uncompressed data into the window  Huffman-compressed LZ77 block  block with fixed Huffman codes  block with dynamic Huffman codes  now huffman lengths are read for either kind of block, 
       * create huffman decoding tables  decode forever until end of block code  END OF BLOCK CODE: loop break point  codes 257-285 are matches  codes 286-287 are illegal  match position is window position minus distance. If distance
           * is more than window position numerically, it must 'wrap
           * around' the frame size.  copy match  short match, use slower loop but no loop setup code  longer match, use faster loop but with setup expense  else (code >= 257)  for(;;) -- break point at 'code == 256'  block_type == 3 -- bad block type  flush the remaining data  return success  inflate() calls this whenever the window should be flushed. As
 * MSZIP only expands to the size of the window, the implementation used
 * simply keeps track of the amount of data flushed, and if more than 32k
 * is flushed, an error is raised.
  round up input buffer size to multiple of two  allocate decompression state  allocate input buffer  initialise decompression state  for the bit buffer  easy answers  flush out any stored-up bytes before we begin  unpack another block  skip to next read 'CK' header  align to bytestream  inflate a block, repair and realign if necessary  recover partially-inflated buffers  write a frame  mspack errors (i.e. read errors) are fatal and can't be recovered  for the bit buffer  unpack blocks until block_len == 0  align to bytestream, read block_len  read "CK" header  inflate block  write inflated block 