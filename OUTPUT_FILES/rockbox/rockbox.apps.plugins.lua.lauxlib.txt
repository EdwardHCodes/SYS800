
** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
 ROCKLUA ADDED  This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
** Note ** luaS_newlloc breaks this guarantee ROCKLUA ADDED
 free list of references  convert a stack index to positive 
** {======================================================
** Error-report functions
** =======================================================
 no stack frame?  do not count `self'  error is in the self argument itself?  check function at level  get info about it  is there info?  else, no information available...  }======================================================  get registry.name  name already in use?  leave previous value on top, but return 0  create metatable  registry.name = metatable  value is a userdata?  does it have a metatable?  get correct metatable  does it have the correct mt?  remove both metatables  else error  to avoid warnings  avoid extra test when d is not 0  avoid extra test when d is not 0  ROCKLUA ADDED  ROCKLUA ADDED  no metatable?  remove metatable and metafield  remove only metatable  no metafield?  ROCKLUA ADDED  late bind cfunction tables to save ram  name @ top of stack 1(basetable;name)-1 basetable;name;__latebind; basetable;name;__latebind(t); (btable;name;__latebind(t))  lookup late bound func(s), lua_objlen allows check of multiple luaL_Reg  btable;name;__lb(t);llib (btable;name;__lb(t);llib) -> (btable;name;__lb(t))  don't overwrite existing keys within basetable  (btable;name;__lb(t);llib->name)  (btable;name;__lb(t);btable[func]?)  if function is used it is added to the base table  (btable;name;__lb(t);llib->func)  nil name binds all functions in table immediately  (btable;name;mtable)  dupe closure or existing func  (btable;name;__lb(t);llib->func;llib->func)  (btable;name;__lb(t);llib->func)  returns the closure  (btable;name;__lb(t)) -> (btable)  remove metatable (btable;name;__lb(t);nil) remove __latebind table basetable @ top of stack 1(basetable)-1  function to be called / returned (btable;pairs)  btable;pairs;newtable;  clone base table  first key  (btable;pairs;ntable;k;v)  dupe key Stk = (..;k;v -> ..k;v;k) Stk = (..k;k;v)  btable;pairs;ntable;k nil name retrieves all unbound late bound functions  (btable;pairs;ntable;nil) -> (btable;pairs;ntable)  (btable;pairs;ntable)  pairs(ntable) -> (btable;iter;state;value)  if there is no libname register normally  store empty table instead of passed luaL_Reg table  allows t("func") -- nil binds all  store func names  basetable;  create table if doesn't exist  basetable;__latebind(t);  save pointer to real luaL_reg basetable;__lb(t);userdata;lb(t)[n] = userdata  (basetable;__latebind(t)) -> (basetable) basetable;metatable dupe the metatable (basetable;mt;mt)  metatable[__metatable] = metatable  (basetable;mt) -> (basetable+mtable)  base table is top of stack (basetable)  check whether lib already exists  get _LOADED[libname]  not found?  remove previous result  try global variable (and create one if it does not exist)  _LOADED[libname] = new table  remove _LOADED table  move library table to below upvalues  copy upvalues to the top  remove upvalues 
** {======================================================
** getn-setn: size for arrays
** =======================================================
 no `size' table?  remove nil  create it  `size' will be its own metatable  metatable(N).__mode = "kv"  store in register  is there a numeric field `n'?  use it  use `sizes'  sizes[t] = n  remove `sizes'  try t.n  else try sizes[t]  }======================================================  push prefix  push replacement in place of pattern  continue after `p'  push last suffix  no such field?  remove this nil  new table for field  set new table into field  field has a non-table value?  remove table and value  return problematic part of the name  remove previous table 
** {======================================================
** Generic Buffer manipulation
** =======================================================
 put nothing on stack  number of levels to concat  fit into buffer?  put it there  remove from stack  put buffer before new value  add new value into B stack  }======================================================  remove from stack  `nil' has a unique fixed reference  get first free element  ref = t[FREELIST_REF]  remove it from stack  any free element?  remove it from list  (t[FREELIST_REF] = t[ref])  no free elements  create new reference  t[ref] = t[FREELIST_REF]  t[FREELIST_REF] = ref 
** {======================================================
** Load functions
** =======================================================
 index of filename on the stack  }======================================================  emergency full collection.  try allocation again  if defined.. signal OOM condition  try allocation again  allocator needs lua_State. 
** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
 ROCKLUA ADDED  This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
** Note ** luaS_newlloc breaks this guarantee ROCKLUA ADDED
 free list of references  convert a stack index to positive 
** {======================================================
** Error-report functions
** =======================================================
 no stack frame?  do not count `self'  error is in the self argument itself?  check function at level  get info about it  is there info?  else, no information available...  }======================================================  get registry.name  name already in use?  leave previous value on top, but return 0  create metatable  registry.name = metatable  value is a userdata?  does it have a metatable?  get correct metatable  does it have the correct mt?  remove both metatables  else error  to avoid warnings  avoid extra test when d is not 0  avoid extra test when d is not 0  ROCKLUA ADDED  ROCKLUA ADDED  no metatable?  remove metatable and metafield  remove only metatable  no metafield?  ROCKLUA ADDED  late bind cfunction tables to save ram  name @ top of stack 1(basetable;name)-1 basetable;name;__latebind; basetable;name;__latebind(t); (btable;name;__latebind(t))  lookup late bound func(s), lua_objlen allows check of multiple luaL_Reg  btable;name;__lb(t);llib (btable;name;__lb(t);llib) -> (btable;name;__lb(t))  don't overwrite existing keys within basetable  (btable;name;__lb(t);llib->name)  (btable;name;__lb(t);btable[func]?)  if function is used it is added to the base table  (btable;name;__lb(t);llib->func)  nil name binds all functions in table immediately  (btable;name;mtable)  dupe closure or existing func  (btable;name;__lb(t);llib->func;llib->func)  (btable;name;__lb(t);llib->func)  returns the closure  (btable;name;__lb(t)) -> (btable)  remove metatable (btable;name;__lb(t);nil) remove __latebind table basetable @ top of stack 1(basetable)-1  function to be called / returned (btable;pairs)  btable;pairs;newtable;  clone base table  first key  (btable;pairs;ntable;k;v)  dupe key Stk = (..;k;v -> ..k;v;k) Stk = (..k;k;v)  btable;pairs;ntable;k nil name retrieves all unbound late bound functions  (btable;pairs;ntable;nil) -> (btable;pairs;ntable)  (btable;pairs;ntable)  pairs(ntable) -> (btable;iter;state;value)  if there is no libname register normally  store empty table instead of passed luaL_Reg table  allows t("func") -- nil binds all  store func names  basetable;  create table if doesn't exist  basetable;__latebind(t);  save pointer to real luaL_reg basetable;__lb(t);userdata;lb(t)[n] = userdata  (basetable;__latebind(t)) -> (basetable) basetable;metatable dupe the metatable (basetable;mt;mt)  metatable[__metatable] = metatable  (basetable;mt) -> (basetable+mtable)  base table is top of stack (basetable)  check whether lib already exists  get _LOADED[libname]  not found?  remove previous result  try global variable (and create one if it does not exist)  _LOADED[libname] = new table  remove _LOADED table  move library table to below upvalues  copy upvalues to the top  remove upvalues 
** {======================================================
** getn-setn: size for arrays
** =======================================================
 no `size' table?  remove nil  create it  `size' will be its own metatable  metatable(N).__mode = "kv"  store in register  is there a numeric field `n'?  use it  use `sizes'  sizes[t] = n  remove `sizes'  try t.n  else try sizes[t]  }======================================================  push prefix  push replacement in place of pattern  continue after `p'  push last suffix  no such field?  remove this nil  new table for field  set new table into field  field has a non-table value?  remove table and value  return problematic part of the name  remove previous table 
** {======================================================
** Generic Buffer manipulation
** =======================================================
 put nothing on stack  number of levels to concat  fit into buffer?  put it there  remove from stack  put buffer before new value  add new value into B stack  }======================================================  remove from stack  `nil' has a unique fixed reference  get first free element  ref = t[FREELIST_REF]  remove it from stack  any free element?  remove it from list  (t[FREELIST_REF] = t[ref])  no free elements  create new reference  t[ref] = t[FREELIST_REF]  t[FREELIST_REF] = ref 
** {======================================================
** Load functions
** =======================================================
 index of filename on the stack  }======================================================  emergency full collection.  try allocation again  if defined.. signal OOM condition  try allocation again  allocator needs lua_State. 
** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
 ROCKLUA ADDED  This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
** Note ** luaS_newlloc breaks this guarantee ROCKLUA ADDED
 free list of references  convert a stack index to positive 
** {======================================================
** Error-report functions
** =======================================================
 no stack frame?  do not count `self'  error is in the self argument itself?  check function at level  get info about it  is there info?  else, no information available...  }======================================================  get registry.name  name already in use?  leave previous value on top, but return 0  create metatable  registry.name = metatable  value is a userdata?  does it have a metatable?  get correct metatable  does it have the correct mt?  remove both metatables  else error  to avoid warnings  avoid extra test when d is not 0  avoid extra test when d is not 0  ROCKLUA ADDED  ROCKLUA ADDED  no metatable?  remove metatable and metafield  remove only metatable  no metafield?  ROCKLUA ADDED  late bind cfunction tables to save ram  name @ top of stack 1(basetable;name)-1 basetable;name;__latebind; basetable;name;__latebind(t); (btable;name;__latebind(t))  lookup late bound func(s), lua_objlen allows check of multiple luaL_Reg  btable;name;__lb(t);llib (btable;name;__lb(t);llib) -> (btable;name;__lb(t))  don't overwrite existing keys within basetable  (btable;name;__lb(t);llib->name)  (btable;name;__lb(t);btable[func]?)  if function is used it is added to the base table  (btable;name;__lb(t);llib->func)  nil name binds all functions in table immediately  (btable;name;mtable)  dupe closure or existing func  (btable;name;__lb(t);llib->func;llib->func)  (btable;name;__lb(t);llib->func)  returns the closure  (btable;name;__lb(t)) -> (btable)  remove metatable (btable;name;__lb(t);nil) remove __latebind table basetable @ top of stack 1(basetable)-1  function to be called / returned (btable;pairs)  btable;pairs;newtable;  clone base table  first key  (btable;pairs;ntable;k;v)  dupe key Stk = (..;k;v -> ..k;v;k) Stk = (..k;k;v)  btable;pairs;ntable;k nil name retrieves all unbound late bound functions  (btable;pairs;ntable;nil) -> (btable;pairs;ntable)  (btable;pairs;ntable)  pairs(ntable) -> (btable;iter;state;value)  if there is no libname register normally  store empty table instead of passed luaL_Reg table  allows t("func") -- nil binds all  store func names  basetable;  create table if doesn't exist  basetable;__latebind(t);  save pointer to real luaL_reg basetable;__lb(t);userdata;lb(t)[n] = userdata  (basetable;__latebind(t)) -> (basetable) basetable;metatable dupe the metatable (basetable;mt;mt)  metatable[__metatable] = metatable  (basetable;mt) -> (basetable+mtable)  base table is top of stack (basetable)  check whether lib already exists  get _LOADED[libname]  not found?  remove previous result  try global variable (and create one if it does not exist)  _LOADED[libname] = new table  remove _LOADED table  move library table to below upvalues  copy upvalues to the top  remove upvalues 
** {======================================================
** getn-setn: size for arrays
** =======================================================
 no `size' table?  remove nil  create it  `size' will be its own metatable  metatable(N).__mode = "kv"  store in register  is there a numeric field `n'?  use it  use `sizes'  sizes[t] = n  remove `sizes'  try t.n  else try sizes[t]  }======================================================  push prefix  push replacement in place of pattern  continue after `p'  push last suffix  no such field?  remove this nil  new table for field  set new table into field  field has a non-table value?  remove table and value  return problematic part of the name  remove previous table 
** {======================================================
** Generic Buffer manipulation
** =======================================================
 put nothing on stack  number of levels to concat  fit into buffer?  put it there  remove from stack  put buffer before new value  add new value into B stack  }======================================================  remove from stack  `nil' has a unique fixed reference  get first free element  ref = t[FREELIST_REF]  remove it from stack  any free element?  remove it from list  (t[FREELIST_REF] = t[ref])  no free elements  create new reference  t[ref] = t[FREELIST_REF]  t[FREELIST_REF] = ref 
** {======================================================
** Load functions
** =======================================================
 index of filename on the stack  }======================================================  emergency full collection.  try allocation again  if defined.. signal OOM condition  try allocation again  allocator needs lua_State. 