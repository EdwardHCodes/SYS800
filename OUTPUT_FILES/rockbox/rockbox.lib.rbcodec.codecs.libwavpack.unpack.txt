//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //      Distributed under the BSD Software License (see license.txt)      //////////////////////////////////////////////////////////////////////////// unpack.c This module actually handles the decompression of the audio data, except for the entropy decoding which is handled by the words.c module. For maximum efficiency, the conversion is isolated to tight loops that handle an entire buffer./////////////////////////// executable code //////////////////////////////// This function initializes everything required to unpack a WavPack block and must be called before unpack_samples() is called to obtain audio data. It is assumed that the WavpackHeader has been read into the wps->wphdr (in the current WavpackStream). This is where all the metadata blocks are scanned up to the one containing the audio bitstream. This function initialzes the main bitstream for audio samples, which must be in the "wv" file. Read decorrelation terms from specified metadata block into the decorr_passes array. The terms range from -3 to 8, plus 17 & 18; other values are reserved and generate errors for now. The delta ranges from 0 to 7 with all values valid. Note that the terms are stored in the opposite order in the decorr_passes array compared to packing. Read decorrelation weights from specified metadata block into the decorr_passes array. The weights range +/-1024, but are rounded and truncated to fit in signed chars for metadata storage. Weights are separate for the two channels and are specified from the "last" term (first during encode). Unspecified weights are set to zero. Read decorrelation samples from specified metadata block into the decorr_passes array. The samples are signed 32-bit values, but are converted to signed log2 values for storage in metadata. Values are stored for both channels and are specified from the "last" term (first during encode) with unspecified samples set to zero. The number of samples stored varies with the actual term value, so those must obviously come first in the metadata. Read the int32 data from the specified metadata into the specified stream. This data is used for integer data that has more than 24 bits of magnitude or, in some cases, used to eliminate redundant bits from any audio stream. Read multichannel information from metadata. The first byte is the total number of channels and the following bytes represent the channel_mask as described for Microsoft WAVEFORMATEX. Read configuration information from metadata. Read non-standard sampling rate from metadata. This monster actually unpacks the WavPack bitstream(s) into the specified buffer as 32-bit integers or floats (depending on orignal data). Lossy samples will be clipped to their original limits (i.e. 8-bit samples are clipped to -128/+127) but are still returned in int32_ts. It is up to the caller to potentially reformat this for the final output including any multichannel distribution, block alignment or endian compensation. The function unpack_init() must have been called and the entire WavPack block must still be visible (although wps->blockbuff will not be accessed again). For maximum clarity, the function is broken up into segments that handle various modes. This makes for a few extra infrequent flag checks, but makes the code easier to follow because the nesting does not become so deep. For maximum efficiency, the conversion is isolated to tight loops that handle an entire buffer. The function returns the total number of samples unpacked, which can be less than the number requested if an error occurs or the end of the block is reached./////////////////// handle version 4 mono data /////////////////////////////////////////// handle version 4 stereo data //////////////////////// This is a helper function for unpack_samples() that applies several final operations. First, if the data is 32-bit float data, then that conversion is done in the float.c module (whether lossy or lossless) and we return. Otherwise, if the extended integer data applies, then that operation is executed first. If the unpacked data is lossy (and not corrected) then it is clipped and shifted in a single operation. Otherwise, if it's lossless then the last step is to apply the final shift (if any). This function has been modified for RockBox to return all integer samples as 28-bits, and clipping (for lossy mode) has been eliminated because this now happens in the dsp module. this provides RockBox with 28-bit (+sign) This function checks the crc value(s) for an unpacked block, returning the number of actual crc errors detected for the block. The block must be completely unpacked before this test is valid. For losslessly unpacked blocks of float or extended integer data the extended crc is also checked. Note that WavPack's crc is not a CCITT approved polynomial algorithm, but is a much simpler method that is virtually as robust for real world data.//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //      Distributed under the BSD Software License (see license.txt)      //////////////////////////////////////////////////////////////////////////// unpack.c This module actually handles the decompression of the audio data, except for the entropy decoding which is handled by the words.c module. For maximum efficiency, the conversion is isolated to tight loops that handle an entire buffer./////////////////////////// executable code //////////////////////////////// This function initializes everything required to unpack a WavPack block and must be called before unpack_samples() is called to obtain audio data. It is assumed that the WavpackHeader has been read into the wps->wphdr (in the current WavpackStream). This is where all the metadata blocks are scanned up to the one containing the audio bitstream. This function initialzes the main bitstream for audio samples, which must be in the "wv" file. Read decorrelation terms from specified metadata block into the decorr_passes array. The terms range from -3 to 8, plus 17 & 18; other values are reserved and generate errors for now. The delta ranges from 0 to 7 with all values valid. Note that the terms are stored in the opposite order in the decorr_passes array compared to packing. Read decorrelation weights from specified metadata block into the decorr_passes array. The weights range +/-1024, but are rounded and truncated to fit in signed chars for metadata storage. Weights are separate for the two channels and are specified from the "last" term (first during encode). Unspecified weights are set to zero. Read decorrelation samples from specified metadata block into the decorr_passes array. The samples are signed 32-bit values, but are converted to signed log2 values for storage in metadata. Values are stored for both channels and are specified from the "last" term (first during encode) with unspecified samples set to zero. The number of samples stored varies with the actual term value, so those must obviously come first in the metadata. Read the int32 data from the specified metadata into the specified stream. This data is used for integer data that has more than 24 bits of magnitude or, in some cases, used to eliminate redundant bits from any audio stream. Read multichannel information from metadata. The first byte is the total number of channels and the following bytes represent the channel_mask as described for Microsoft WAVEFORMATEX. Read configuration information from metadata. Read non-standard sampling rate from metadata. This monster actually unpacks the WavPack bitstream(s) into the specified buffer as 32-bit integers or floats (depending on orignal data). Lossy samples will be clipped to their original limits (i.e. 8-bit samples are clipped to -128/+127) but are still returned in int32_ts. It is up to the caller to potentially reformat this for the final output including any multichannel distribution, block alignment or endian compensation. The function unpack_init() must have been called and the entire WavPack block must still be visible (although wps->blockbuff will not be accessed again). For maximum clarity, the function is broken up into segments that handle various modes. This makes for a few extra infrequent flag checks, but makes the code easier to follow because the nesting does not become so deep. For maximum efficiency, the conversion is isolated to tight loops that handle an entire buffer. The function returns the total number of samples unpacked, which can be less than the number requested if an error occurs or the end of the block is reached./////////////////// handle version 4 mono data /////////////////////////////////////////// handle version 4 stereo data //////////////////////// This is a helper function for unpack_samples() that applies several final operations. First, if the data is 32-bit float data, then that conversion is done in the float.c module (whether lossy or lossless) and we return. Otherwise, if the extended integer data applies, then that operation is executed first. If the unpacked data is lossy (and not corrected) then it is clipped and shifted in a single operation. Otherwise, if it's lossless then the last step is to apply the final shift (if any). This function has been modified for RockBox to return all integer samples as 28-bits, and clipping (for lossy mode) has been eliminated because this now happens in the dsp module. this provides RockBox with 28-bit (+sign) This function checks the crc value(s) for an unpacked block, returning the number of actual crc errors detected for the block. The block must be completely unpacked before this test is valid. For losslessly unpacked blocks of float or extended integer data the extended crc is also checked. Note that WavPack's crc is not a CCITT approved polynomial algorithm, but is a much simpler method that is virtually as robust for real world data.//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //      Distributed under the BSD Software License (see license.txt)      //////////////////////////////////////////////////////////////////////////// unpack.c This module actually handles the decompression of the audio data, except for the entropy decoding which is handled by the words.c module. For maximum efficiency, the conversion is isolated to tight loops that handle an entire buffer./////////////////////////// executable code //////////////////////////////// This function initializes everything required to unpack a WavPack block and must be called before unpack_samples() is called to obtain audio data. It is assumed that the WavpackHeader has been read into the wps->wphdr (in the current WavpackStream). This is where all the metadata blocks are scanned up to the one containing the audio bitstream. This function initialzes the main bitstream for audio samples, which must be in the "wv" file. Read decorrelation terms from specified metadata block into the decorr_passes array. The terms range from -3 to 8, plus 17 & 18; other values are reserved and generate errors for now. The delta ranges from 0 to 7 with all values valid. Note that the terms are stored in the opposite order in the decorr_passes array compared to packing. Read decorrelation weights from specified metadata block into the decorr_passes array. The weights range +/-1024, but are rounded and truncated to fit in signed chars for metadata storage. Weights are separate for the two channels and are specified from the "last" term (first during encode). Unspecified weights are set to zero. Read decorrelation samples from specified metadata block into the decorr_passes array. The samples are signed 32-bit values, but are converted to signed log2 values for storage in metadata. Values are stored for both channels and are specified from the "last" term (first during encode) with unspecified samples set to zero. The number of samples stored varies with the actual term value, so those must obviously come first in the metadata. Read the int32 data from the specified metadata into the specified stream. This data is used for integer data that has more than 24 bits of magnitude or, in some cases, used to eliminate redundant bits from any audio stream. Read multichannel information from metadata. The first byte is the total number of channels and the following bytes represent the channel_mask as described for Microsoft WAVEFORMATEX. Read configuration information from metadata. Read non-standard sampling rate from metadata. This monster actually unpacks the WavPack bitstream(s) into the specified buffer as 32-bit integers or floats (depending on orignal data). Lossy samples will be clipped to their original limits (i.e. 8-bit samples are clipped to -128/+127) but are still returned in int32_ts. It is up to the caller to potentially reformat this for the final output including any multichannel distribution, block alignment or endian compensation. The function unpack_init() must have been called and the entire WavPack block must still be visible (although wps->blockbuff will not be accessed again). For maximum clarity, the function is broken up into segments that handle various modes. This makes for a few extra infrequent flag checks, but makes the code easier to follow because the nesting does not become so deep. For maximum efficiency, the conversion is isolated to tight loops that handle an entire buffer. The function returns the total number of samples unpacked, which can be less than the number requested if an error occurs or the end of the block is reached./////////////////// handle version 4 mono data /////////////////////////////////////////// handle version 4 stereo data //////////////////////// This is a helper function for unpack_samples() that applies several final operations. First, if the data is 32-bit float data, then that conversion is done in the float.c module (whether lossy or lossless) and we return. Otherwise, if the extended integer data applies, then that operation is executed first. If the unpacked data is lossy (and not corrected) then it is clipped and shifted in a single operation. Otherwise, if it's lossless then the last step is to apply the final shift (if any). This function has been modified for RockBox to return all integer samples as 28-bits, and clipping (for lossy mode) has been eliminated because this now happens in the dsp module. this provides RockBox with 28-bit (+sign) This function checks the crc value(s) for an unpacked block, returning the number of actual crc errors detected for the block. The block must be completely unpacked before this test is valid. For losslessly unpacked blocks of float or extended integer data the extended crc is also checked. Note that WavPack's crc is not a CCITT approved polynomial algorithm, but is a much simpler method that is virtually as robust for real world data.