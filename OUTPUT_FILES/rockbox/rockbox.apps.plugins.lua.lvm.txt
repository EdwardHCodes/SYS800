
** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
 limit for table tag-method chains (to avoid loops)  call linehook when enter a new function, when jump back (loop),
       or when enter a new line  push function  1st argument  2nd argument  push function  1st argument  2nd argument  3th argument  `t' is a table?  do a primitive get  result is no nil?  or no TM?  else will try the tag method  else repeat with `tm'  `t' is a table?  do a primitive set  result is no nil?  or no TM?  else will try the tag method  else repeat with `tm'  avoid pointing inside table (may rehash)  need to protect value from EGC.  try first operand  try second operand  no metamethod  same metatables => same metamethods  no metamethod  same metamethods?  no metamethod?  different metamethods?  strings are equal up to a `\0'  index of first `\0' in both strings  r is finished?  l is finished?  l is smaller than r (because r is not finished)  both strings longer than `len'; go on comparing (after the `\0')  first try `le'  else try `lt'  true must be 1 !!  will try TM  will try TM  no TM?  call TM  Any call which does a memory allocation may trim the stack,
       invalidating top unless the stack is fixed during the allocation  number of elements handled in this pass (at least 2)  restore 'top' pointer, since stack might have been reallocted  second op is empty?  result is first op (as string)  at least two string values; get as many as possible  collect total length  concat all strings  got `n' strings to create 1 new  repeat until only 1 result left 
** some macros for common tasks in `luaV_execute'
 to be used after possible stack reallocation  entry point  main loop of interpreter  did hook yield?  warning!! several calls may realloc the stack and invalidate `ra'  skip next instruction (if C)  ROCKLUA INTEGER BUGFIX  ROCKLUA INTEGER BUGFIX  next assignment may change this value  try metamethod  else previous instruction set top  restart luaV_execute over new Lua function  it was a C function (`precall' called it); adjust results  yield  else previous instruction set top  tail call: put new frame in place of previous one  previous frame  previous function index  move frame down  correct top  one more call lost  remove new frame  it was a C function (`precall' called it)  yield  was previous function running `here'?  no: return  yes: continue its execution  increment index  jump back  update internal index...  ...and external index  next steps may throw errors  call base  func. + 2 args (state and index)  previous call may change the stack  continue loop?  save control variable  jump back  needs more space?  pre-alloc it at once  previous call may change the stack 
** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
 limit for table tag-method chains (to avoid loops)  call linehook when enter a new function, when jump back (loop),
       or when enter a new line  push function  1st argument  2nd argument  push function  1st argument  2nd argument  3th argument  `t' is a table?  do a primitive get  result is no nil?  or no TM?  else will try the tag method  else repeat with `tm'  `t' is a table?  do a primitive set  result is no nil?  or no TM?  else will try the tag method  else repeat with `tm'  avoid pointing inside table (may rehash)  need to protect value from EGC.  try first operand  try second operand  no metamethod  same metatables => same metamethods  no metamethod  same metamethods?  no metamethod?  different metamethods?  strings are equal up to a `\0'  index of first `\0' in both strings  r is finished?  l is finished?  l is smaller than r (because r is not finished)  both strings longer than `len'; go on comparing (after the `\0')  first try `le'  else try `lt'  true must be 1 !!  will try TM  will try TM  no TM?  call TM  Any call which does a memory allocation may trim the stack,
       invalidating top unless the stack is fixed during the allocation  number of elements handled in this pass (at least 2)  restore 'top' pointer, since stack might have been reallocted  second op is empty?  result is first op (as string)  at least two string values; get as many as possible  collect total length  concat all strings  got `n' strings to create 1 new  repeat until only 1 result left 
** some macros for common tasks in `luaV_execute'
 to be used after possible stack reallocation  entry point  main loop of interpreter  did hook yield?  warning!! several calls may realloc the stack and invalidate `ra'  skip next instruction (if C)  ROCKLUA INTEGER BUGFIX  ROCKLUA INTEGER BUGFIX  next assignment may change this value  try metamethod  else previous instruction set top  restart luaV_execute over new Lua function  it was a C function (`precall' called it); adjust results  yield  else previous instruction set top  tail call: put new frame in place of previous one  previous frame  previous function index  move frame down  correct top  one more call lost  remove new frame  it was a C function (`precall' called it)  yield  was previous function running `here'?  no: return  yes: continue its execution  increment index  jump back  update internal index...  ...and external index  next steps may throw errors  call base  func. + 2 args (state and index)  previous call may change the stack  continue loop?  save control variable  jump back  needs more space?  pre-alloc it at once  previous call may change the stack 
** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
 limit for table tag-method chains (to avoid loops)  call linehook when enter a new function, when jump back (loop),
       or when enter a new line  push function  1st argument  2nd argument  push function  1st argument  2nd argument  3th argument  `t' is a table?  do a primitive get  result is no nil?  or no TM?  else will try the tag method  else repeat with `tm'  `t' is a table?  do a primitive set  result is no nil?  or no TM?  else will try the tag method  else repeat with `tm'  avoid pointing inside table (may rehash)  need to protect value from EGC.  try first operand  try second operand  no metamethod  same metatables => same metamethods  no metamethod  same metamethods?  no metamethod?  different metamethods?  strings are equal up to a `\0'  index of first `\0' in both strings  r is finished?  l is finished?  l is smaller than r (because r is not finished)  both strings longer than `len'; go on comparing (after the `\0')  first try `le'  else try `lt'  true must be 1 !!  will try TM  will try TM  no TM?  call TM  Any call which does a memory allocation may trim the stack,
       invalidating top unless the stack is fixed during the allocation  number of elements handled in this pass (at least 2)  restore 'top' pointer, since stack might have been reallocted  second op is empty?  result is first op (as string)  at least two string values; get as many as possible  collect total length  concat all strings  got `n' strings to create 1 new  repeat until only 1 result left 
** some macros for common tasks in `luaV_execute'
 to be used after possible stack reallocation  entry point  main loop of interpreter  did hook yield?  warning!! several calls may realloc the stack and invalidate `ra'  skip next instruction (if C)  ROCKLUA INTEGER BUGFIX  ROCKLUA INTEGER BUGFIX  next assignment may change this value  try metamethod  else previous instruction set top  restart luaV_execute over new Lua function  it was a C function (`precall' called it); adjust results  yield  else previous instruction set top  tail call: put new frame in place of previous one  previous frame  previous function index  move frame down  correct top  one more call lost  remove new frame  it was a C function (`precall' called it)  yield  was previous function running `here'?  no: return  yes: continue its execution  increment index  jump back  update internal index...  ...and external index  next steps may throw errors  call base  func. + 2 args (state and index)  previous call may change the stack  continue loop?  save control variable  jump back  needs more space?  pre-alloc it at once  previous call may change the stack 