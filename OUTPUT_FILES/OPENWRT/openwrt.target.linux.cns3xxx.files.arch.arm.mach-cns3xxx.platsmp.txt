
 *  linux/arch/arm/mach-cns3xxx/platsmp.c
 *
 *  Copyright (C) 2002 ARM Ltd.
 *  Copyright 2012 Gateworks Corporation
 *		   Chris Lang <clang@gateworks.com>
 *         Tim Harvey <tharvey@gateworks.com>
 *
 *  All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 
 * Write pen_release in a way that is guaranteed to be visible to all
 * observers, irrespective of whether they're taking part in coherency
 * or not.  This is necessary for the hotplug code to work reliably.
 
	 * Setup Secondary Core FIQ regs
	 
	 * let the primary processor know we're out of the
	 * pen, then head off into the C entry point
	 
	 * Synchronise with the boot thread.
	 
	 * Set synchronisation state between this boot processor
	 * and the secondary one
	 
	 * The secondary processor is waiting to be released from
	 * the holding pen - release it, then wait for it to flag
	 * that it has been released by resetting pen_release.
	 *
	 * Note that "pen_release" is the hardware CPU ID, whereas
	 * "cpu" is Linux's internal ID.
	 
	 * Send the secondary CPU a soft interrupt, thereby causing
	 * the boot monitor to read the system wide flags register,
	 * and branch to the address found there.
	 
	 * now the secondary core is starting up let it run its
	 * calibrations, then wait for it to finish
	 
 * Initialise the CPU possible map early - this describes the CPUs
 * which may be present or become present in the system.
  for CNS3xxx SCU_CPU_STATUS must be examined instead of SCU_CONFIGURATION
	 * used in scu_get_core_count
	 
	 * enable SCU
	 
	 * Write the address of secondary startup into the
	 * system-wide flags register. The boot monitor waits
	 * until it receives a soft interrupt, and then the
	 * secondary CPU branches to this address.
	 
	 * Setup FIQ's for main cpu
	  currently, not possible to take cpu0 down, so only check cpu1  currently, not possible to take cpu0 down, so only check cpu1  currently, not possible to take cpu0 down, so only check cpu1 
 *  linux/arch/arm/mach-cns3xxx/platsmp.c
 *
 *  Copyright (C) 2002 ARM Ltd.
 *  Copyright 2012 Gateworks Corporation
 *		   Chris Lang <clang@gateworks.com>
 *         Tim Harvey <tharvey@gateworks.com>
 *
 *  All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 
 * Write pen_release in a way that is guaranteed to be visible to all
 * observers, irrespective of whether they're taking part in coherency
 * or not.  This is necessary for the hotplug code to work reliably.
 
	 * Setup Secondary Core FIQ regs
	 
	 * let the primary processor know we're out of the
	 * pen, then head off into the C entry point
	 
	 * Synchronise with the boot thread.
	 
	 * Set synchronisation state between this boot processor
	 * and the secondary one
	 
	 * The secondary processor is waiting to be released from
	 * the holding pen - release it, then wait for it to flag
	 * that it has been released by resetting pen_release.
	 *
	 * Note that "pen_release" is the hardware CPU ID, whereas
	 * "cpu" is Linux's internal ID.
	 
	 * Send the secondary CPU a soft interrupt, thereby causing
	 * the boot monitor to read the system wide flags register,
	 * and branch to the address found there.
	 
	 * now the secondary core is starting up let it run its
	 * calibrations, then wait for it to finish
	 
 * Initialise the CPU possible map early - this describes the CPUs
 * which may be present or become present in the system.
  for CNS3xxx SCU_CPU_STATUS must be examined instead of SCU_CONFIGURATION
	 * used in scu_get_core_count
	 
	 * enable SCU
	 
	 * Write the address of secondary startup into the
	 * system-wide flags register. The boot monitor waits
	 * until it receives a soft interrupt, and then the
	 * secondary CPU branches to this address.
	 
	 * Setup FIQ's for main cpu
	  currently, not possible to take cpu0 down, so only check cpu1  currently, not possible to take cpu0 down, so only check cpu1  currently, not possible to take cpu0 down, so only check cpu1 