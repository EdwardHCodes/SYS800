  filesystem.c  Duke3D  Created by fabien sanglard on 12-12-19.  Copyright (c) 2012 fabien sanglard. All rights reserved.The multiplayer module in game.dll needs direct access to the crc32 (sic). A typical GRP index entry:     - 12 bytes for filename     -  4 for filesizeNumber of files in the archive.Array containing the filenames.Array containing the file offsets.Array containing the file offsets.The fd used for open,read operations.Hash to recognize GRP: Duke Shareware, Duke plutonimum etc... valid if cached == 1 0 = not cached, 1 = partial, 2 = full entire file in RAMAll GRP opened are in this structure Marking it static gurantee not only invisility outside module but also that the content will be set to 0.Init the slotgroupfil_memory[numgroupfiles] = NULL; // addresses of raw GRP files in memorygroupefil_crc32[numgroupfiles] = 0;FCS   : The ".grp" file format is just a collection of a lot of files stored into 1 big one.KS doc: I tried to make the format as simple as possible: The first 12 bytes contains my name,"KenSilverman". The next 4 bytes is the number of files that were compacted into thegroup file. Then for each file, there is a 16 byte structure, where the first 12bytes are the filename, and the last 4 bytes are the file's size. The rest of thegroup file is just the raw data packed one after the other in the same order as the listof files. - ken Check the magic number (12 bytes header). The next 4 bytes of the header feature the number of files in the GRP archive. Load the full index 16 bytes per file (12bytes for name + 4 bytes for the size).Initialize all file offset and pointers. get size Now that the filesize has been read, we can replace it with '0' and hence have a valid, null terminated character string that will be usable. absolute offset list of all files.archive->fileOffsets[archive->numFiles-1] = j; Compute CRC32 of the whole grp and implicitely caches the GRP in memory through windows caching service. Rewind the fileDescriptori = 1000000;groupfil_memory[numgroupfiles] = malloc(i);Load the full GRP in RAM. Atomic Edition won't fit  arbitrary, but must be multiple of CRC_BUFLEN (currently 1024*128)  we need a temporary buffer to calculate the CRC if it's not being cached  crcBuffer points to a permanent buffer  we've read enough, further reads go into a temp buffer  sorryrb->splashf(0, "point -%d", loop); The game layer seems to absolutely need to access an array int[4] groupefil_crc32 so we need to store the crc32 in there too.free(groupfil_memory[numgroupfiles]);groupfil_memory[numgroupfiles] = 0; build CRC32 table 
 *                                      16   12   5
 * this is the CCITT CRC 16 polynomial X  + X  + X  + 1.
 * This is 0x1021 when x is 2, but the way the algorithm works
 * we use 0x8408 (the reverse of the bit pattern).  The high
 * bit is always assumed to be set, thus we only use 16 bits to
 * represent the 17 bit value.
  1021H bit reversed  The engine can open files transparently on the filesystem or on the GRPsystemAn entry in the array tracking open filesEither the fileDescriptor or the fileIndex in a GRP depending on the type.lseek cursorGRP idMarker 1=usedSearch a free slotTry to look in the filesystem first. In this case fd = filedescriptor.Try to look in the GRP archives. In this case fd = index of the file in the GRP.FILESYSTEM ? OS takes care of it !File is actually in the GRPAdjust leng so we cannot read more than filesystem-cursor location. completely in RAM  3 cases here: either it's completely outside the cached region, in which case we
             * fall back to a disk read; it can be on a boundary; or completely in RAM  completely outside  partial  in-RAM portion  disk  fully in RAM  FILESYSTEM ? OS will take care of it.This is a typical handle for a non existing file. Internal LZW variables  Watch out for shorts!  uncompleng  uncompleng  try rootreturn game_dir;  filesystem.c  Duke3D  Created by fabien sanglard on 12-12-19.  Copyright (c) 2012 fabien sanglard. All rights reserved.The multiplayer module in game.dll needs direct access to the crc32 (sic). A typical GRP index entry:     - 12 bytes for filename     -  4 for filesizeNumber of files in the archive.Array containing the filenames.Array containing the file offsets.Array containing the file offsets.The fd used for open,read operations.Hash to recognize GRP: Duke Shareware, Duke plutonimum etc... valid if cached == 1 0 = not cached, 1 = partial, 2 = full entire file in RAMAll GRP opened are in this structure Marking it static gurantee not only invisility outside module but also that the content will be set to 0.Init the slotgroupfil_memory[numgroupfiles] = NULL; // addresses of raw GRP files in memorygroupefil_crc32[numgroupfiles] = 0;FCS   : The ".grp" file format is just a collection of a lot of files stored into 1 big one.KS doc: I tried to make the format as simple as possible: The first 12 bytes contains my name,"KenSilverman". The next 4 bytes is the number of files that were compacted into thegroup file. Then for each file, there is a 16 byte structure, where the first 12bytes are the filename, and the last 4 bytes are the file's size. The rest of thegroup file is just the raw data packed one after the other in the same order as the listof files. - ken Check the magic number (12 bytes header). The next 4 bytes of the header feature the number of files in the GRP archive. Load the full index 16 bytes per file (12bytes for name + 4 bytes for the size).Initialize all file offset and pointers. get size Now that the filesize has been read, we can replace it with '0' and hence have a valid, null terminated character string that will be usable. absolute offset list of all files.archive->fileOffsets[archive->numFiles-1] = j; Compute CRC32 of the whole grp and implicitely caches the GRP in memory through windows caching service. Rewind the fileDescriptori = 1000000;groupfil_memory[numgroupfiles] = malloc(i);Load the full GRP in RAM. Atomic Edition won't fit  arbitrary, but must be multiple of CRC_BUFLEN (currently 1024*128)  we need a temporary buffer to calculate the CRC if it's not being cached  crcBuffer points to a permanent buffer  we've read enough, further reads go into a temp buffer  sorryrb->splashf(0, "point -%d", loop); The game layer seems to absolutely need to access an array int[4] groupefil_crc32 so we need to store the crc32 in there too.free(groupfil_memory[numgroupfiles]);groupfil_memory[numgroupfiles] = 0; build CRC32 table 
 *                                      16   12   5
 * this is the CCITT CRC 16 polynomial X  + X  + X  + 1.
 * This is 0x1021 when x is 2, but the way the algorithm works
 * we use 0x8408 (the reverse of the bit pattern).  The high
 * bit is always assumed to be set, thus we only use 16 bits to
 * represent the 17 bit value.
  1021H bit reversed  The engine can open files transparently on the filesystem or on the GRPsystemAn entry in the array tracking open filesEither the fileDescriptor or the fileIndex in a GRP depending on the type.lseek cursorGRP idMarker 1=usedSearch a free slotTry to look in the filesystem first. In this case fd = filedescriptor.Try to look in the GRP archives. In this case fd = index of the file in the GRP.FILESYSTEM ? OS takes care of it !File is actually in the GRPAdjust leng so we cannot read more than filesystem-cursor location. completely in RAM  3 cases here: either it's completely outside the cached region, in which case we
             * fall back to a disk read; it can be on a boundary; or completely in RAM  completely outside  partial  in-RAM portion  disk  fully in RAM  FILESYSTEM ? OS will take care of it.This is a typical handle for a non existing file. Internal LZW variables  Watch out for shorts!  uncompleng  uncompleng  try rootreturn game_dir;  filesystem.c  Duke3D  Created by fabien sanglard on 12-12-19.  Copyright (c) 2012 fabien sanglard. All rights reserved.The multiplayer module in game.dll needs direct access to the crc32 (sic). A typical GRP index entry:     - 12 bytes for filename     -  4 for filesizeNumber of files in the archive.Array containing the filenames.Array containing the file offsets.Array containing the file offsets.The fd used for open,read operations.Hash to recognize GRP: Duke Shareware, Duke plutonimum etc... valid if cached == 1 0 = not cached, 1 = partial, 2 = full entire file in RAMAll GRP opened are in this structure Marking it static gurantee not only invisility outside module but also that the content will be set to 0.Init the slotgroupfil_memory[numgroupfiles] = NULL; // addresses of raw GRP files in memorygroupefil_crc32[numgroupfiles] = 0;FCS   : The ".grp" file format is just a collection of a lot of files stored into 1 big one.KS doc: I tried to make the format as simple as possible: The first 12 bytes contains my name,"KenSilverman". The next 4 bytes is the number of files that were compacted into thegroup file. Then for each file, there is a 16 byte structure, where the first 12bytes are the filename, and the last 4 bytes are the file's size. The rest of thegroup file is just the raw data packed one after the other in the same order as the listof files. - ken Check the magic number (12 bytes header). The next 4 bytes of the header feature the number of files in the GRP archive. Load the full index 16 bytes per file (12bytes for name + 4 bytes for the size).Initialize all file offset and pointers. get size Now that the filesize has been read, we can replace it with '0' and hence have a valid, null terminated character string that will be usable. absolute offset list of all files.archive->fileOffsets[archive->numFiles-1] = j; Compute CRC32 of the whole grp and implicitely caches the GRP in memory through windows caching service. Rewind the fileDescriptori = 1000000;groupfil_memory[numgroupfiles] = malloc(i);Load the full GRP in RAM. Atomic Edition won't fit  arbitrary, but must be multiple of CRC_BUFLEN (currently 1024*128)  we need a temporary buffer to calculate the CRC if it's not being cached  crcBuffer points to a permanent buffer  we've read enough, further reads go into a temp buffer  sorryrb->splashf(0, "point -%d", loop); The game layer seems to absolutely need to access an array int[4] groupefil_crc32 so we need to store the crc32 in there too.free(groupfil_memory[numgroupfiles]);groupfil_memory[numgroupfiles] = 0; build CRC32 table 
 *                                      16   12   5
 * this is the CCITT CRC 16 polynomial X  + X  + X  + 1.
 * This is 0x1021 when x is 2, but the way the algorithm works
 * we use 0x8408 (the reverse of the bit pattern).  The high
 * bit is always assumed to be set, thus we only use 16 bits to
 * represent the 17 bit value.
  1021H bit reversed  The engine can open files transparently on the filesystem or on the GRPsystemAn entry in the array tracking open filesEither the fileDescriptor or the fileIndex in a GRP depending on the type.lseek cursorGRP idMarker 1=usedSearch a free slotTry to look in the filesystem first. In this case fd = filedescriptor.Try to look in the GRP archives. In this case fd = index of the file in the GRP.FILESYSTEM ? OS takes care of it !File is actually in the GRPAdjust leng so we cannot read more than filesystem-cursor location. completely in RAM  3 cases here: either it's completely outside the cached region, in which case we
             * fall back to a disk read; it can be on a boundary; or completely in RAM  completely outside  partial  in-RAM portion  disk  fully in RAM  FILESYSTEM ? OS will take care of it.This is a typical handle for a non existing file. Internal LZW variables  Watch out for shorts!  uncompleng  uncompleng  try rootreturn game_dir;