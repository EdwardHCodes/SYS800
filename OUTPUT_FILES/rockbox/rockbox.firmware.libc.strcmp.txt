
FUNCTION
        <<strcmp>>---character string compare
        
INDEX
        strcmp

ANSI_SYNOPSIS
        #include <string.h>
        int strcmp(const char *<[a]>, const char *<[b]>);

TRAD_SYNOPSIS
        #include <string.h>
        int strcmp(<[a]>, <[b]>)
        char *<[a]>;
        char *<[b]>;

DESCRIPTION
        <<strcmp>> compares the string at <[a]> to
        the string at <[b]>.

RETURNS
        If <<*<[a]>>> sorts lexicographically after <<*<[b]>>>,
        <<strcmp>> returns a number greater than zero.  If the two
        strings match, <<strcmp>> returns zero.  If <<*<[a]>>>
        sorts lexicographically before <<*<[b]>>>, <<strcmp>> returns a
        number less than zero.

PORTABILITY
<<strcmp>> is ANSI C.

<<strcmp>> requires no supporting OS subroutines.

QUICKREF
        strcmp ansi pure
 for _DEFUN  Nonzero if either X or Y is not aligned on a "long" boundary.   DETECTNULL returns nonzero if (long)X contains a NULL byte.  If s1 or s2 are unaligned, then compare bytes.  If s1 and s2 are word-aligned, compare them a word at a time.  To get here, *a1 == *a2, thus if we find a null in *a1,
             then the strings must be equal, so return zero.   A difference was detected in last few bytes of s1, so search bytewise  not PREFER_SIZE_OVER_SPEED 
FUNCTION
        <<strcmp>>---character string compare
        
INDEX
        strcmp

ANSI_SYNOPSIS
        #include <string.h>
        int strcmp(const char *<[a]>, const char *<[b]>);

TRAD_SYNOPSIS
        #include <string.h>
        int strcmp(<[a]>, <[b]>)
        char *<[a]>;
        char *<[b]>;

DESCRIPTION
        <<strcmp>> compares the string at <[a]> to
        the string at <[b]>.

RETURNS
        If <<*<[a]>>> sorts lexicographically after <<*<[b]>>>,
        <<strcmp>> returns a number greater than zero.  If the two
        strings match, <<strcmp>> returns zero.  If <<*<[a]>>>
        sorts lexicographically before <<*<[b]>>>, <<strcmp>> returns a
        number less than zero.

PORTABILITY
<<strcmp>> is ANSI C.

<<strcmp>> requires no supporting OS subroutines.

QUICKREF
        strcmp ansi pure
 for _DEFUN  Nonzero if either X or Y is not aligned on a "long" boundary.   DETECTNULL returns nonzero if (long)X contains a NULL byte.  If s1 or s2 are unaligned, then compare bytes.  If s1 and s2 are word-aligned, compare them a word at a time.  To get here, *a1 == *a2, thus if we find a null in *a1,
             then the strings must be equal, so return zero.   A difference was detected in last few bytes of s1, so search bytewise  not PREFER_SIZE_OVER_SPEED 
FUNCTION
        <<strcmp>>---character string compare
        
INDEX
        strcmp

ANSI_SYNOPSIS
        #include <string.h>
        int strcmp(const char *<[a]>, const char *<[b]>);

TRAD_SYNOPSIS
        #include <string.h>
        int strcmp(<[a]>, <[b]>)
        char *<[a]>;
        char *<[b]>;

DESCRIPTION
        <<strcmp>> compares the string at <[a]> to
        the string at <[b]>.

RETURNS
        If <<*<[a]>>> sorts lexicographically after <<*<[b]>>>,
        <<strcmp>> returns a number greater than zero.  If the two
        strings match, <<strcmp>> returns zero.  If <<*<[a]>>>
        sorts lexicographically before <<*<[b]>>>, <<strcmp>> returns a
        number less than zero.

PORTABILITY
<<strcmp>> is ANSI C.

<<strcmp>> requires no supporting OS subroutines.

QUICKREF
        strcmp ansi pure
 for _DEFUN  Nonzero if either X or Y is not aligned on a "long" boundary.   DETECTNULL returns nonzero if (long)X contains a NULL byte.  If s1 or s2 are unaligned, then compare bytes.  If s1 and s2 are word-aligned, compare them a word at a time.  To get here, *a1 == *a2, thus if we find a null in *a1,
             then the strings must be equal, so return zero.   A difference was detected in last few bytes of s1, so search bytewise  not PREFER_SIZE_OVER_SPEED 