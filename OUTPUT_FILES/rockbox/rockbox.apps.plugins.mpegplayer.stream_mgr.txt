**************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * AV stream manager implementation
 *
 * Copyright (c) 2007 Michael Sevakis
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 *************************************************************************** Forward decs  Command to send to stream  Data to send with command  Save the current window since it actually might be ready by the time
     * the registration is received by buffering.  Set right edge to where probing left off + the minimum margin  Request would be passed the end of the file  Was ready - restore window and process  Error - quit parsing  Not ready - go wait for notification from buffering.  Normalize win_right back to the packet length  Nothing was yet parsed since init  Restore window based upon current packet  Set stream manager to a "no-file" state  Add a stream to the playback pool  Callback for various list-moving operations  Clear all streams from active and playback pools  Move the playback pool to the active list  Remove a stream from the active list and return it to the pool  Broadcast a message to all active streams  Set the current base clock  Fudge: Start clock 100ms early to allow for some filling time  Clear any seeked status  Flush old PCM data  Set the master clock  Make sure streams are back in active pool  Prepare the parser and associated streams  Start buffer which optional force fill  Tell each stream to start - may generate end of stream signals
     * now - we'll handle this when finished  Actually start the clock  Return the play time relative to the specified play time  Set the current time (time = unsigned offset from 0)  Seek forward or backward from the current time
         * (time = signed offset from current)  Seek from the end (time = unsigned offset from end)  Handle seeking details if playing or paused  Place streams in a non-running state - keep them on actl if
         * still there  Stop all buffering or else risk clobbering random-access data  Store the resume time at the last seek/current clock point  Assume invalidity  Read the current stream time or the last seeked position  Save the current stream time  Handle STREAM_OPEN  Open the video file  Initialize the parser  File ok - save the opened filename  If error - cleanup  Handler STREAM_PLAY  We just say we're playing now  Reply with previous state  Seek to initial position and set clock to that time  Save the resume time  Prepare seek to start point  Sync and start - force buffer fill  Reply with previous state  Handle STREAM_PAUSE  Reply with previous state  Pause the clock  Pause each active stream  Pause the disk buffer - buffer may continue filling  Unboost the CPU  Offically paused  Handle STREAM_RESUME  Reply with previous state  Boost the CPU  Sync and start - no force buffering  Officially playing  Handle STREAM_STOP  Pause the clock  Update the resume time info  Not stopped = paused or playing  Stop buffering  Clear any still-active streams and remove from actl  Stop PCM output (and clock)  Cancel our processor boost  Handle STREAM_SEEK  Keep things spinning if already doing so  Have data - reply in order to acquire lock  Either seeking must be possible or a full rewind must be done  Keep clock from advancing while seeking  Sync and restart - no force buffering  Invalid parameter or no file  Handle STREAM_CLOSE  Any open file that was accepted for playback?  Yes - hide video  Stop any playback  Tell parser file is finished  Reinitialize manager  Let disk buffer reset itself - file might be open even if no good  Handle STREAM_EV_COMPLETE  Stream is active?  No - remove this stream from the active list  All streams have acked - stop playback  Played to end - no resume  Stream is done - stop it and place back in pool  Callback for stream to notify about events internal to them  The last stream has ended  Clear any particular notification for which a stream registered  Special handling for certain messages since they involve multiple
 * operations behind the scenes  Only prepare image if showing and not playing  Prepare image if not playing  Ignore return and try video thread anyway  Image ready - pass message to video thread  Show/hide the video output  Query the visibility of video output  Return the video dimensions  Show/hide the gray video overlay (independently of vo visibility).  !HAVE_LCD_COLOR  Display a thumbnail at the last seek point  Return the time playback should resume if interrupted  A stop request is async and replies before setting this - must lock  Clock can be start early so keep in range  Wait for a state transistion to complete  Returns the smallest file window that includes all active streams'
 * windows  Playback control thread  Stream command interface APIs  Opens a new file  Plays the current file starting at time 'start'  Pauses playback if playing  Resumes playback if paused  Stops playback if not stopped  Seeks playback time to/by the specified time  Closes the current file  Initializes the playback engine  Initialize our window to the outside world first  sets audiosize and returns buffer pointer  Initialize non-allocator blocks first  Greylib init handles all necessary cache alignment  !HAVE_LCD_COLOR  Wait for thread to initialize  Initialise our malloc buffer  These inits use the allocator  Disk buffer takes max allotment of what's left so it must be last  Cleans everything up  Stop the threads and wait for them to terminate **************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * AV stream manager implementation
 *
 * Copyright (c) 2007 Michael Sevakis
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 *************************************************************************** Forward decs  Command to send to stream  Data to send with command  Save the current window since it actually might be ready by the time
     * the registration is received by buffering.  Set right edge to where probing left off + the minimum margin  Request would be passed the end of the file  Was ready - restore window and process  Error - quit parsing  Not ready - go wait for notification from buffering.  Normalize win_right back to the packet length  Nothing was yet parsed since init  Restore window based upon current packet  Set stream manager to a "no-file" state  Add a stream to the playback pool  Callback for various list-moving operations  Clear all streams from active and playback pools  Move the playback pool to the active list  Remove a stream from the active list and return it to the pool  Broadcast a message to all active streams  Set the current base clock  Fudge: Start clock 100ms early to allow for some filling time  Clear any seeked status  Flush old PCM data  Set the master clock  Make sure streams are back in active pool  Prepare the parser and associated streams  Start buffer which optional force fill  Tell each stream to start - may generate end of stream signals
     * now - we'll handle this when finished  Actually start the clock  Return the play time relative to the specified play time  Set the current time (time = unsigned offset from 0)  Seek forward or backward from the current time
         * (time = signed offset from current)  Seek from the end (time = unsigned offset from end)  Handle seeking details if playing or paused  Place streams in a non-running state - keep them on actl if
         * still there  Stop all buffering or else risk clobbering random-access data  Store the resume time at the last seek/current clock point  Assume invalidity  Read the current stream time or the last seeked position  Save the current stream time  Handle STREAM_OPEN  Open the video file  Initialize the parser  File ok - save the opened filename  If error - cleanup  Handler STREAM_PLAY  We just say we're playing now  Reply with previous state  Seek to initial position and set clock to that time  Save the resume time  Prepare seek to start point  Sync and start - force buffer fill  Reply with previous state  Handle STREAM_PAUSE  Reply with previous state  Pause the clock  Pause each active stream  Pause the disk buffer - buffer may continue filling  Unboost the CPU  Offically paused  Handle STREAM_RESUME  Reply with previous state  Boost the CPU  Sync and start - no force buffering  Officially playing  Handle STREAM_STOP  Pause the clock  Update the resume time info  Not stopped = paused or playing  Stop buffering  Clear any still-active streams and remove from actl  Stop PCM output (and clock)  Cancel our processor boost  Handle STREAM_SEEK  Keep things spinning if already doing so  Have data - reply in order to acquire lock  Either seeking must be possible or a full rewind must be done  Keep clock from advancing while seeking  Sync and restart - no force buffering  Invalid parameter or no file  Handle STREAM_CLOSE  Any open file that was accepted for playback?  Yes - hide video  Stop any playback  Tell parser file is finished  Reinitialize manager  Let disk buffer reset itself - file might be open even if no good  Handle STREAM_EV_COMPLETE  Stream is active?  No - remove this stream from the active list  All streams have acked - stop playback  Played to end - no resume  Stream is done - stop it and place back in pool  Callback for stream to notify about events internal to them  The last stream has ended  Clear any particular notification for which a stream registered  Special handling for certain messages since they involve multiple
 * operations behind the scenes  Only prepare image if showing and not playing  Prepare image if not playing  Ignore return and try video thread anyway  Image ready - pass message to video thread  Show/hide the video output  Query the visibility of video output  Return the video dimensions  Show/hide the gray video overlay (independently of vo visibility).  !HAVE_LCD_COLOR  Display a thumbnail at the last seek point  Return the time playback should resume if interrupted  A stop request is async and replies before setting this - must lock  Clock can be start early so keep in range  Wait for a state transistion to complete  Returns the smallest file window that includes all active streams'
 * windows  Playback control thread  Stream command interface APIs  Opens a new file  Plays the current file starting at time 'start'  Pauses playback if playing  Resumes playback if paused  Stops playback if not stopped  Seeks playback time to/by the specified time  Closes the current file  Initializes the playback engine  Initialize our window to the outside world first  sets audiosize and returns buffer pointer  Initialize non-allocator blocks first  Greylib init handles all necessary cache alignment  !HAVE_LCD_COLOR  Wait for thread to initialize  Initialise our malloc buffer  These inits use the allocator  Disk buffer takes max allotment of what's left so it must be last  Cleans everything up  Stop the threads and wait for them to terminate **************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * AV stream manager implementation
 *
 * Copyright (c) 2007 Michael Sevakis
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 *************************************************************************** Forward decs  Command to send to stream  Data to send with command  Save the current window since it actually might be ready by the time
     * the registration is received by buffering.  Set right edge to where probing left off + the minimum margin  Request would be passed the end of the file  Was ready - restore window and process  Error - quit parsing  Not ready - go wait for notification from buffering.  Normalize win_right back to the packet length  Nothing was yet parsed since init  Restore window based upon current packet  Set stream manager to a "no-file" state  Add a stream to the playback pool  Callback for various list-moving operations  Clear all streams from active and playback pools  Move the playback pool to the active list  Remove a stream from the active list and return it to the pool  Broadcast a message to all active streams  Set the current base clock  Fudge: Start clock 100ms early to allow for some filling time  Clear any seeked status  Flush old PCM data  Set the master clock  Make sure streams are back in active pool  Prepare the parser and associated streams  Start buffer which optional force fill  Tell each stream to start - may generate end of stream signals
     * now - we'll handle this when finished  Actually start the clock  Return the play time relative to the specified play time  Set the current time (time = unsigned offset from 0)  Seek forward or backward from the current time
         * (time = signed offset from current)  Seek from the end (time = unsigned offset from end)  Handle seeking details if playing or paused  Place streams in a non-running state - keep them on actl if
         * still there  Stop all buffering or else risk clobbering random-access data  Store the resume time at the last seek/current clock point  Assume invalidity  Read the current stream time or the last seeked position  Save the current stream time  Handle STREAM_OPEN  Open the video file  Initialize the parser  File ok - save the opened filename  If error - cleanup  Handler STREAM_PLAY  We just say we're playing now  Reply with previous state  Seek to initial position and set clock to that time  Save the resume time  Prepare seek to start point  Sync and start - force buffer fill  Reply with previous state  Handle STREAM_PAUSE  Reply with previous state  Pause the clock  Pause each active stream  Pause the disk buffer - buffer may continue filling  Unboost the CPU  Offically paused  Handle STREAM_RESUME  Reply with previous state  Boost the CPU  Sync and start - no force buffering  Officially playing  Handle STREAM_STOP  Pause the clock  Update the resume time info  Not stopped = paused or playing  Stop buffering  Clear any still-active streams and remove from actl  Stop PCM output (and clock)  Cancel our processor boost  Handle STREAM_SEEK  Keep things spinning if already doing so  Have data - reply in order to acquire lock  Either seeking must be possible or a full rewind must be done  Keep clock from advancing while seeking  Sync and restart - no force buffering  Invalid parameter or no file  Handle STREAM_CLOSE  Any open file that was accepted for playback?  Yes - hide video  Stop any playback  Tell parser file is finished  Reinitialize manager  Let disk buffer reset itself - file might be open even if no good  Handle STREAM_EV_COMPLETE  Stream is active?  No - remove this stream from the active list  All streams have acked - stop playback  Played to end - no resume  Stream is done - stop it and place back in pool  Callback for stream to notify about events internal to them  The last stream has ended  Clear any particular notification for which a stream registered  Special handling for certain messages since they involve multiple
 * operations behind the scenes  Only prepare image if showing and not playing  Prepare image if not playing  Ignore return and try video thread anyway  Image ready - pass message to video thread  Show/hide the video output  Query the visibility of video output  Return the video dimensions  Show/hide the gray video overlay (independently of vo visibility).  !HAVE_LCD_COLOR  Display a thumbnail at the last seek point  Return the time playback should resume if interrupted  A stop request is async and replies before setting this - must lock  Clock can be start early so keep in range  Wait for a state transistion to complete  Returns the smallest file window that includes all active streams'
 * windows  Playback control thread  Stream command interface APIs  Opens a new file  Plays the current file starting at time 'start'  Pauses playback if playing  Resumes playback if paused  Stops playback if not stopped  Seeks playback time to/by the specified time  Closes the current file  Initializes the playback engine  Initialize our window to the outside world first  sets audiosize and returns buffer pointer  Initialize non-allocator blocks first  Greylib init handles all necessary cache alignment  !HAVE_LCD_COLOR  Wait for thread to initialize  Initialise our malloc buffer  These inits use the allocator  Disk buffer takes max allotment of what's left so it must be last  Cleans everything up  Stop the threads and wait for them to terminate 