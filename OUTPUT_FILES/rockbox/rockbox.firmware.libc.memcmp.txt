
FUNCTION
        <<memcmp>>---compare two memory areas

INDEX
        memcmp

ANSI_SYNOPSIS
        #include <string.h>
        int memcmp(const void *<[s1]>, const void *<[s2]>, size_t <[n]>);

TRAD_SYNOPSIS
        #include <string.h>
        int memcmp(<[s1]>, <[s2]>, <[n]>)
        void *<[s1]>;
        void *<[s2]>;
        size_t <[n]>;

DESCRIPTION
        This function compares not more than <[n]> characters of the
        object pointed to by <[s1]> with the object pointed to by <[s2]>.


RETURNS
        The function returns an integer greater than, equal to or
        less than zero  according to whether the object pointed to by
        <[s1]> is greater than, equal to or less than the object
        pointed to by <[s2]>.

PORTABILITY
<<memcmp>> is ANSI C.

<<memcmp>> requires no supporting OS subroutines.

QUICKREF
        memcmp ansi pure
 for _DEFUN  Nonzero if either X or Y is not aligned on a "long" boundary.   How many bytes are copied each iteration of the word copy loop.   Threshhold for punting to the byte copier.   If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.   Otherwise, load and compare the blocks of memory one 
         word at a time.   check m mod LBLOCKSIZE remaining characters  not PREFER_SIZE_OVER_SPEED 
FUNCTION
        <<memcmp>>---compare two memory areas

INDEX
        memcmp

ANSI_SYNOPSIS
        #include <string.h>
        int memcmp(const void *<[s1]>, const void *<[s2]>, size_t <[n]>);

TRAD_SYNOPSIS
        #include <string.h>
        int memcmp(<[s1]>, <[s2]>, <[n]>)
        void *<[s1]>;
        void *<[s2]>;
        size_t <[n]>;

DESCRIPTION
        This function compares not more than <[n]> characters of the
        object pointed to by <[s1]> with the object pointed to by <[s2]>.


RETURNS
        The function returns an integer greater than, equal to or
        less than zero  according to whether the object pointed to by
        <[s1]> is greater than, equal to or less than the object
        pointed to by <[s2]>.

PORTABILITY
<<memcmp>> is ANSI C.

<<memcmp>> requires no supporting OS subroutines.

QUICKREF
        memcmp ansi pure
 for _DEFUN  Nonzero if either X or Y is not aligned on a "long" boundary.   How many bytes are copied each iteration of the word copy loop.   Threshhold for punting to the byte copier.   If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.   Otherwise, load and compare the blocks of memory one 
         word at a time.   check m mod LBLOCKSIZE remaining characters  not PREFER_SIZE_OVER_SPEED 
FUNCTION
        <<memcmp>>---compare two memory areas

INDEX
        memcmp

ANSI_SYNOPSIS
        #include <string.h>
        int memcmp(const void *<[s1]>, const void *<[s2]>, size_t <[n]>);

TRAD_SYNOPSIS
        #include <string.h>
        int memcmp(<[s1]>, <[s2]>, <[n]>)
        void *<[s1]>;
        void *<[s2]>;
        size_t <[n]>;

DESCRIPTION
        This function compares not more than <[n]> characters of the
        object pointed to by <[s1]> with the object pointed to by <[s2]>.


RETURNS
        The function returns an integer greater than, equal to or
        less than zero  according to whether the object pointed to by
        <[s1]> is greater than, equal to or less than the object
        pointed to by <[s2]>.

PORTABILITY
<<memcmp>> is ANSI C.

<<memcmp>> requires no supporting OS subroutines.

QUICKREF
        memcmp ansi pure
 for _DEFUN  Nonzero if either X or Y is not aligned on a "long" boundary.   How many bytes are copied each iteration of the word copy loop.   Threshhold for punting to the byte copier.   If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.   Otherwise, load and compare the blocks of memory one 
         word at a time.   check m mod LBLOCKSIZE remaining characters  not PREFER_SIZE_OVER_SPEED 