
 * windows.c: Windows front end for my puzzle collection.
  NO_HTMLHELP  NO_HTMLHELP  NO_HTMLHELP 
 * Wrapper implementations of functions not supplied by the
 * PocketPC API.
 DWORD dw;

    if (!debug_got_console) {
	if (AllocConsole()) {
	    debug_got_console = 1;
	    debug_hdl = GetStdHandle(STD_OUTPUT_HANDLE);
	}
    }
    if (!debug_fp) {
	debug_fp = fopen("debug.log", "w");
    }

    if (debug_hdl != INVALID_HANDLE_VALUE) {
	WriteFile(debug_hdl, buf, strlen(buf), &dw, NULL);
    }
    if (debug_fp) {
      fputs(buf, debug_fp);
      fflush(debug_fp);
    } window handle for the numeric pad  game bitmap position within game window  BitBlt(dstDC, dstX, dstY, dstW, dstH, srcDC, srcX, srcY, dType)  we should always have saved before loading  ick 
	 * Displaying text in hatched colours is not permitted.
	 
	     * This is only ever required during printing, and the
	     * PocketPC port doesn't support printing.
	      hatch == HATCH_X ? 
	 * Stroking in hatched colours is not permitted.
	 
     * Find or create the font.
     
     * Position and draw the text.
     
	 * Rectangle() appears to get uppity if asked to draw a 1x1
	 * rectangle, presumably on the grounds that that's beneath
	 * its dignity and you ought to be using SetPixel instead.
	 * So I will.
	 
     * Push a marker on the font stack so that we won't use the
     * same fonts for printing and drawing. (This is because
     * drawing seems to look generally better in bold, but printing
     * is better not in bold.)
     
     * Compute the puzzle's position on the logical page.
     
     * Work out what that comes to in pixels.
     
     * And determine the scale.
     * 
     * I need a scale such that the maximum puzzle-coordinate
     * extent of the rectangle (pw * scale) is equal to the pixel
     * equivalent of the puzzle's millimetre width (wmm * ppw /
     * mmpw).
     
     * Now store pox, poy and scale for use in the main drawing
     * functions.
      Nothing needs to be done here. 
     * Free all the fonts created since we began printing.
     
     * The MSDN web site sample code doesn't bother to call EndDoc
     * if an error occurs half way through printing. I expect doing
     * so would cause the erroneous document to actually be
     * printed, or something equally undesirable.
     
     * We assume Windows can cope with any UTF-8 likely to be
     * emitted by a puzzle.
      non-interactive midend for bulk puzzle generation 
     * Create our document structure and fill it up with puzzles.
     
		 * Set the non-interactive mid-end to have the same
		 * parameters as the standard one.
		 
     * Now pd.hDC is a device context for the printer.
     
     * FIXME: IWBNI we put up an Abort box here.
      for non-interactive midend  for non-interactive midend 
     * Windows expects CRLF in the clipboard, so we must convert
     * any \n that has come out of the puzzle backend.
     
 * Set up Help and see if we can find a help file.
 
     * Find the executable file path, so we can look alongside
     * it for help files. Trim the filename off the end.
     
     * Try HTML Help first.
     
	 * We have a .CHM. See if we can use it.
	  NO_HTMLHELP 
     * Now try old-style .HLP.
     
	 * See if there's a .CNT file alongside it.
	  didn't find any 
 * Start Help.
  NO_HTMLHELP 
 * Stop Help on window cleanup.
  NO_HTMLHELP 
 * Terminate Help on process exit.
  Nothing to do currently.
     * (If we were running HTML Help single-threaded, this is where we'd
     * call HH_UNINITIALIZE.) 
 * Given a proposed new puzzle size (cx,cy), work out the actual
 * puzzle size that would be (px,py) and the window size including
 * furniture (wx,wy).
  disallow making window thinner than menu bar 
     * See if we actually got the window size we wanted, and adjust
     * the puzzle size if not.
     
         * Resize the window, now we know what size we _really_
         * want it to be.
         
 * Given the current window size, make sure it's sane for the
 * current puzzle and resize if necessary.
  Toolbar buttons on the numeric pad 
 * Allocate a new frontend structure and create its main window.
 
 * Create an appropriate midend structure to go in a puzzle window,
 * given a game type and/or a command-line argument.
 *
 * 'arg' can be either a game ID string (descriptive, random, or a
 * plain set of parameters) or the filename of a save file. The two
 * boolean flag arguments indicate which possibilities are
 * permissible.
 
         * See if arg is a valid filename of a save game file.
         
             * Find out what kind of game is stored in the save
             * file; if we're going to end up loading that, it
             * will have to override our caller's judgment as to
             * what game to initialise our midend with.
              go back to the start for actual load 
             * See if arg is a game description.
             
         * FIXME: we ought to go through and do something with ampersands
         * here.
         
 * Populate a frontend structure with a new midend structure, and
 * create any window furniture that it needs.
 *
 * Previously-allocated memory and window furniture will be freed by
 * this function.
 *
  status bar does these  status bar does these  Flat status bar looks better on the Pocket PC 
	 * Now resize the window to take account of the status bar.
	  ...here I run out of sensible accelerator characters.  only include those games that aren't the same as the
                     * game we're currently playing. ick initialises fe->bitmap  - ((8 * GetDeviceCaps(hdc, LOGPIXELSY)) / 72)  Make dialog full screen 
 * Wrappers on midend_{get,set}_config, which extend the CFG_*
 * enumeration to add CFG_PRINT.
  Separate version of mkctrl function for the Pocket PC.  Control coordinates should be specified in dialog units.  Convert dialog units into pixels  Control placement done in dialog units  Label column  Input column (edit boxes and combo boxes) 
     * Count the controls so we can allocate cfgaux.
      Leave some room for the dialog title 
	     * Edit box with a label beside it.
	     
	     * Simple checkbox.
	     
	     * Drop-down list with a label beside it.
	     
	 * OK and Cancel are special cases.
	 
	 * First find the control whose id this is.
	  not our problem 
     * Figure out the layout of the About box by measuring the
     * length of each piece of text.
      *shrug*  OK button 
     * Create the dialog, now that we know its size.
     |
				DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
				WS_CAPTION | WS_SYSMENU
	 * Centre the dialog on its parent window.
	  extra space before OK 
     * Figure out the layout of the config box by measuring the
     * length of each piece of text.
     
	     * Both these control types have a label filling only
	     * the left-hand column of the box.
	     
	     * Checkboxes take up the whole of the box width.
	      OK / Cancel buttons 
     * Create the dialog, now that we know its size.
     |
				DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
				WS_CAPTION | WS_SYSMENU
	 * Centre the dialog on its parent window.
	 
     * Count the controls so we can allocate cfgaux.
     
	     * Edit box with a label beside it.
	     
	     * Simple checkbox.
	     
	     * Drop-down list with a label beside it.
	      extra space before OK and Cancel  Pocket PC - center the game in the full screen window  Plain Windows - position the game in the upper-left corner 
 * Given a proposed new window rect, work out the resulting
 * difference in client size (from current), and use to try
 * and resize the puzzle, returning (wx,wy) as the actual
 * new window size.
  Work out the current window sizing, and thus the
     * difference in size we're asking for.  These next four lines work around the fact that midend_size
       * is happy to shrink _but not grow_ if you change one dimension
       * but not the other.  reset size to current window size  Re-fetch rectangle; size limits mean we might not have
     * taken it quite to the mouse drag positions.  "Custom" menu item is at the bottom of the top-level Type menu  Numeric pad sends WM_COMMAND messages  low 4 bits reserved to Windows  file exists 
                         * This save file might be from a different
                         * game.
                          for the actual load 
		 * Diagonal keys on the numeric keypad.
		 
		 * Numeric keypad keys with Num Lock on.
		 
	     * Shift-clicks count as middle-clicks, since otherwise
	     * two-button Windows users won't have any kind of
	     * middle click to use.
	     
	     * Shift-clicks count as middle-clicks, since otherwise
	     * two-button Windows users won't have any kind of
	     * middle click to use.
	      Given the window size the puzzles constrain
             * us to, work out which edge we should be moving.  Check if application is running. If it's running then focus on the window 
 * Split a complete command line into argc/argv, attempting to do it
 * exactly the same way the Visual Studio C library would do it (so
 * that our console utilities, which receive argc and argv already
 * broken apart by the C library, will have their command lines
 * processed in the same way as the GUI utilities which get a whole
 * command line and must call this function).
 * 
 * Does not modify the input command line.
 * 
 * The final parameter (argstart) is used to return a second array
 * of char * pointers, the same length as argv, each one pointing
 * at the start of the corresponding element of argv in the
 * original command line. So if you get half way through processing
 * your command line in argc/argv form and then decide you want to
 * treat the rest as a raw string, you can. If you don't want to,
 * `argstart' can be safely left NULL.
 
     * These argument-breaking rules apply to Visual Studio 7, which
     * is currently the compiler expected to be used for the Windows
     * port of my puzzles. Visual Studio 10 has different rules,
     * lacking the curious mod 3 behaviour of consecutive quotes
     * described below; I presume they fixed a bug. As and when we
     * migrate to a newer compiler, we'll have to adjust this to
     * match; however, for the moment we faithfully imitate in our GUI
     * utilities what our CLI utilities can't be prevented from doing.
     *
     * When I investigated this, at first glance the rules appeared to
     * be:
     *
     *  - Single quotes are not special characters.
     *
     *  - Double quotes are removed, but within them spaces cease
     *    to be special.
     *
     *  - Backslashes are _only_ special when a sequence of them
     *    appear just before a double quote. In this situation,
     *    they are treated like C backslashes: so \" just gives a
     *    literal quote, \\" gives a literal backslash and then
     *    opens or closes a double-quoted segment, \\\" gives a
     *    literal backslash and then a literal quote, \\\\" gives
     *    two literal backslashes and then opens/closes a
     *    double-quoted segment, and so forth. Note that this
     *    behaviour is identical inside and outside double quotes.
     *
     *  - Two successive double quotes become one literal double
     *    quote, but only _inside_ a double-quoted segment.
     *    Outside, they just form an empty double-quoted segment
     *    (which may cause an empty argument word).
     *
     *  - That only leaves the interesting question of what happens
     *    when one or more backslashes precedes two or more double
     *    quotes, starting inside a double-quoted string. And the
     *    answer to that appears somewhat bizarre. Here I tabulate
     *    number of backslashes (across the top) against number of
     *    quotes (down the left), and indicate how many backslashes
     *    are output, how many quotes are output, and whether a
     *    quoted segment is open at the end of the sequence:
     * 
     *                      backslashes
     * 
     *               0         1      2      3      4
     * 
     *         0   0,0,y  |  1,0,y  2,0,y  3,0,y  4,0,y
     *            --------+-----------------------------
     *         1   0,0,n  |  0,1,y  1,0,n  1,1,y  2,0,n
     *    q    2   0,1,n  |  0,1,n  1,1,n  1,1,n  2,1,n
     *    u    3   0,1,y  |  0,2,n  1,1,y  1,2,n  2,1,y
     *    o    4   0,1,n  |  0,2,y  1,1,n  1,2,y  2,1,n
     *    t    5   0,2,n  |  0,2,n  1,2,n  1,2,n  2,2,n
     *    e    6   0,2,y  |  0,3,n  1,2,y  1,3,n  2,2,y
     *    s    7   0,2,n  |  0,3,y  1,2,n  1,3,y  2,2,n
     *         8   0,3,n  |  0,3,n  1,3,n  1,3,n  2,3,n
     *         9   0,3,y  |  0,4,n  1,3,y  1,4,n  2,3,y
     *        10   0,3,n  |  0,4,y  1,3,n  1,4,y  2,3,n
     *        11   0,4,n  |  0,4,n  1,4,n  1,4,n  2,4,n
     * 
     * 
     *      [Test fragment was of the form "a\\\"""b c" d.]
     * 
     * There is very weird mod-3 behaviour going on here in the
     * number of quotes, and it even applies when there aren't any
     * backslashes! How ghastly.
     * 
     * With a bit of thought, this extremely odd diagram suddenly
     * coalesced itself into a coherent, if still ghastly, model of
     * how things work:
     * 
     *  - As before, backslashes are only special when one or more
     *    of them appear contiguously before at least one double
     *    quote. In this situation the backslashes do exactly what
     *    you'd expect: each one quotes the next thing in front of
     *    it, so you end up with n/2 literal backslashes (if n is
     *    even) or (n-1)/2 literal backslashes and a literal quote
     *    (if n is odd). In the latter case the double quote
     *    character right after the backslashes is used up.
     * 
     *  - After that, any remaining double quotes are processed. A
     *    string of contiguous unescaped double quotes has a mod-3
     *    behaviour:
     * 
     *     * inside a quoted segment, a quote ends the segment.
     *     * _immediately_ after ending a quoted segment, a quote
     *       simply produces a literal quote.
     *     * otherwise, outside a quoted segment, a quote begins a
     *       quoted segment.
     * 
     *    So, for example, if we started inside a quoted segment
     *    then two contiguous quotes would close the segment and
     *    produce a literal quote; three would close the segment,
     *    produce a literal quote, and open a new segment. If we
     *    started outside a quoted segment, then two contiguous
     *    quotes would open and then close a segment, producing no
     *    output (but potentially creating a zero-length argument);
     *    but three quotes would open and close a segment and then
     *    produce a literal quote.
     
     * First deal with the simplest of all special cases: if there
     * aren't any arguments, return 0,NULL,NULL.
     
     * This will guaranteeably be big enough; we can realloc it
     * down later.
      Skip whitespace searching for start of argument.  We have an argument; start it.  Copy data into the argument until it's finished.  argument is finished 
		 * We have a sequence of zero or more backslashes
		 * followed by a sequence of zero or more quotes.
		 * Count up how many of each, and then deal with
		 * them as appropriate.
		 
		     * Special case: if there are no quotes,
		     * slashes are not special at all, so just copy
		     * n slashes to the output string.
		      Slashes annihilate in pairs.  One remaining slash takes out the first quote.  Outside a quote segment, a quote starts one.  Now we produce (n+1)/3 literal quotes...  ... and end in a quote segment iff 3 divides n.  At the end of an argument, just append a trailing NUL.  in case resource file is absent  vim: set shiftwidth=4 tabstop=8: 
 * windows.c: Windows front end for my puzzle collection.
  NO_HTMLHELP  NO_HTMLHELP  NO_HTMLHELP 
 * Wrapper implementations of functions not supplied by the
 * PocketPC API.
 DWORD dw;

    if (!debug_got_console) {
	if (AllocConsole()) {
	    debug_got_console = 1;
	    debug_hdl = GetStdHandle(STD_OUTPUT_HANDLE);
	}
    }
    if (!debug_fp) {
	debug_fp = fopen("debug.log", "w");
    }

    if (debug_hdl != INVALID_HANDLE_VALUE) {
	WriteFile(debug_hdl, buf, strlen(buf), &dw, NULL);
    }
    if (debug_fp) {
      fputs(buf, debug_fp);
      fflush(debug_fp);
    } window handle for the numeric pad  game bitmap position within game window  BitBlt(dstDC, dstX, dstY, dstW, dstH, srcDC, srcX, srcY, dType)  we should always have saved before loading  ick 
	 * Displaying text in hatched colours is not permitted.
	 
	     * This is only ever required during printing, and the
	     * PocketPC port doesn't support printing.
	      hatch == HATCH_X ? 
	 * Stroking in hatched colours is not permitted.
	 
     * Find or create the font.
     
     * Position and draw the text.
     
	 * Rectangle() appears to get uppity if asked to draw a 1x1
	 * rectangle, presumably on the grounds that that's beneath
	 * its dignity and you ought to be using SetPixel instead.
	 * So I will.
	 
     * Push a marker on the font stack so that we won't use the
     * same fonts for printing and drawing. (This is because
     * drawing seems to look generally better in bold, but printing
     * is better not in bold.)
     
     * Compute the puzzle's position on the logical page.
     
     * Work out what that comes to in pixels.
     
     * And determine the scale.
     * 
     * I need a scale such that the maximum puzzle-coordinate
     * extent of the rectangle (pw * scale) is equal to the pixel
     * equivalent of the puzzle's millimetre width (wmm * ppw /
     * mmpw).
     
     * Now store pox, poy and scale for use in the main drawing
     * functions.
      Nothing needs to be done here. 
     * Free all the fonts created since we began printing.
     
     * The MSDN web site sample code doesn't bother to call EndDoc
     * if an error occurs half way through printing. I expect doing
     * so would cause the erroneous document to actually be
     * printed, or something equally undesirable.
     
     * We assume Windows can cope with any UTF-8 likely to be
     * emitted by a puzzle.
      non-interactive midend for bulk puzzle generation 
     * Create our document structure and fill it up with puzzles.
     
		 * Set the non-interactive mid-end to have the same
		 * parameters as the standard one.
		 
     * Now pd.hDC is a device context for the printer.
     
     * FIXME: IWBNI we put up an Abort box here.
      for non-interactive midend  for non-interactive midend 
     * Windows expects CRLF in the clipboard, so we must convert
     * any \n that has come out of the puzzle backend.
     
 * Set up Help and see if we can find a help file.
 
     * Find the executable file path, so we can look alongside
     * it for help files. Trim the filename off the end.
     
     * Try HTML Help first.
     
	 * We have a .CHM. See if we can use it.
	  NO_HTMLHELP 
     * Now try old-style .HLP.
     
	 * See if there's a .CNT file alongside it.
	  didn't find any 
 * Start Help.
  NO_HTMLHELP 
 * Stop Help on window cleanup.
  NO_HTMLHELP 
 * Terminate Help on process exit.
  Nothing to do currently.
     * (If we were running HTML Help single-threaded, this is where we'd
     * call HH_UNINITIALIZE.) 
 * Given a proposed new puzzle size (cx,cy), work out the actual
 * puzzle size that would be (px,py) and the window size including
 * furniture (wx,wy).
  disallow making window thinner than menu bar 
     * See if we actually got the window size we wanted, and adjust
     * the puzzle size if not.
     
         * Resize the window, now we know what size we _really_
         * want it to be.
         
 * Given the current window size, make sure it's sane for the
 * current puzzle and resize if necessary.
  Toolbar buttons on the numeric pad 
 * Allocate a new frontend structure and create its main window.
 
 * Create an appropriate midend structure to go in a puzzle window,
 * given a game type and/or a command-line argument.
 *
 * 'arg' can be either a game ID string (descriptive, random, or a
 * plain set of parameters) or the filename of a save file. The two
 * boolean flag arguments indicate which possibilities are
 * permissible.
 
         * See if arg is a valid filename of a save game file.
         
             * Find out what kind of game is stored in the save
             * file; if we're going to end up loading that, it
             * will have to override our caller's judgment as to
             * what game to initialise our midend with.
              go back to the start for actual load 
             * See if arg is a game description.
             
         * FIXME: we ought to go through and do something with ampersands
         * here.
         
 * Populate a frontend structure with a new midend structure, and
 * create any window furniture that it needs.
 *
 * Previously-allocated memory and window furniture will be freed by
 * this function.
 *
  status bar does these  status bar does these  Flat status bar looks better on the Pocket PC 
	 * Now resize the window to take account of the status bar.
	  ...here I run out of sensible accelerator characters.  only include those games that aren't the same as the
                     * game we're currently playing. ick initialises fe->bitmap  - ((8 * GetDeviceCaps(hdc, LOGPIXELSY)) / 72)  Make dialog full screen 
 * Wrappers on midend_{get,set}_config, which extend the CFG_*
 * enumeration to add CFG_PRINT.
  Separate version of mkctrl function for the Pocket PC.  Control coordinates should be specified in dialog units.  Convert dialog units into pixels  Control placement done in dialog units  Label column  Input column (edit boxes and combo boxes) 
     * Count the controls so we can allocate cfgaux.
      Leave some room for the dialog title 
	     * Edit box with a label beside it.
	     
	     * Simple checkbox.
	     
	     * Drop-down list with a label beside it.
	     
	 * OK and Cancel are special cases.
	 
	 * First find the control whose id this is.
	  not our problem 
     * Figure out the layout of the About box by measuring the
     * length of each piece of text.
      *shrug*  OK button 
     * Create the dialog, now that we know its size.
     |
				DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
				WS_CAPTION | WS_SYSMENU
	 * Centre the dialog on its parent window.
	  extra space before OK 
     * Figure out the layout of the config box by measuring the
     * length of each piece of text.
     
	     * Both these control types have a label filling only
	     * the left-hand column of the box.
	     
	     * Checkboxes take up the whole of the box width.
	      OK / Cancel buttons 
     * Create the dialog, now that we know its size.
     |
				DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
				WS_CAPTION | WS_SYSMENU
	 * Centre the dialog on its parent window.
	 
     * Count the controls so we can allocate cfgaux.
     
	     * Edit box with a label beside it.
	     
	     * Simple checkbox.
	     
	     * Drop-down list with a label beside it.
	      extra space before OK and Cancel  Pocket PC - center the game in the full screen window  Plain Windows - position the game in the upper-left corner 
 * Given a proposed new window rect, work out the resulting
 * difference in client size (from current), and use to try
 * and resize the puzzle, returning (wx,wy) as the actual
 * new window size.
  Work out the current window sizing, and thus the
     * difference in size we're asking for.  These next four lines work around the fact that midend_size
       * is happy to shrink _but not grow_ if you change one dimension
       * but not the other.  reset size to current window size  Re-fetch rectangle; size limits mean we might not have
     * taken it quite to the mouse drag positions.  "Custom" menu item is at the bottom of the top-level Type menu  Numeric pad sends WM_COMMAND messages  low 4 bits reserved to Windows  file exists 
                         * This save file might be from a different
                         * game.
                          for the actual load 
		 * Diagonal keys on the numeric keypad.
		 
		 * Numeric keypad keys with Num Lock on.
		 
	     * Shift-clicks count as middle-clicks, since otherwise
	     * two-button Windows users won't have any kind of
	     * middle click to use.
	     
	     * Shift-clicks count as middle-clicks, since otherwise
	     * two-button Windows users won't have any kind of
	     * middle click to use.
	      Given the window size the puzzles constrain
             * us to, work out which edge we should be moving.  Check if application is running. If it's running then focus on the window 
 * Split a complete command line into argc/argv, attempting to do it
 * exactly the same way the Visual Studio C library would do it (so
 * that our console utilities, which receive argc and argv already
 * broken apart by the C library, will have their command lines
 * processed in the same way as the GUI utilities which get a whole
 * command line and must call this function).
 * 
 * Does not modify the input command line.
 * 
 * The final parameter (argstart) is used to return a second array
 * of char * pointers, the same length as argv, each one pointing
 * at the start of the corresponding element of argv in the
 * original command line. So if you get half way through processing
 * your command line in argc/argv form and then decide you want to
 * treat the rest as a raw string, you can. If you don't want to,
 * `argstart' can be safely left NULL.
 
     * These argument-breaking rules apply to Visual Studio 7, which
     * is currently the compiler expected to be used for the Windows
     * port of my puzzles. Visual Studio 10 has different rules,
     * lacking the curious mod 3 behaviour of consecutive quotes
     * described below; I presume they fixed a bug. As and when we
     * migrate to a newer compiler, we'll have to adjust this to
     * match; however, for the moment we faithfully imitate in our GUI
     * utilities what our CLI utilities can't be prevented from doing.
     *
     * When I investigated this, at first glance the rules appeared to
     * be:
     *
     *  - Single quotes are not special characters.
     *
     *  - Double quotes are removed, but within them spaces cease
     *    to be special.
     *
     *  - Backslashes are _only_ special when a sequence of them
     *    appear just before a double quote. In this situation,
     *    they are treated like C backslashes: so \" just gives a
     *    literal quote, \\" gives a literal backslash and then
     *    opens or closes a double-quoted segment, \\\" gives a
     *    literal backslash and then a literal quote, \\\\" gives
     *    two literal backslashes and then opens/closes a
     *    double-quoted segment, and so forth. Note that this
     *    behaviour is identical inside and outside double quotes.
     *
     *  - Two successive double quotes become one literal double
     *    quote, but only _inside_ a double-quoted segment.
     *    Outside, they just form an empty double-quoted segment
     *    (which may cause an empty argument word).
     *
     *  - That only leaves the interesting question of what happens
     *    when one or more backslashes precedes two or more double
     *    quotes, starting inside a double-quoted string. And the
     *    answer to that appears somewhat bizarre. Here I tabulate
     *    number of backslashes (across the top) against number of
     *    quotes (down the left), and indicate how many backslashes
     *    are output, how many quotes are output, and whether a
     *    quoted segment is open at the end of the sequence:
     * 
     *                      backslashes
     * 
     *               0         1      2      3      4
     * 
     *         0   0,0,y  |  1,0,y  2,0,y  3,0,y  4,0,y
     *            --------+-----------------------------
     *         1   0,0,n  |  0,1,y  1,0,n  1,1,y  2,0,n
     *    q    2   0,1,n  |  0,1,n  1,1,n  1,1,n  2,1,n
     *    u    3   0,1,y  |  0,2,n  1,1,y  1,2,n  2,1,y
     *    o    4   0,1,n  |  0,2,y  1,1,n  1,2,y  2,1,n
     *    t    5   0,2,n  |  0,2,n  1,2,n  1,2,n  2,2,n
     *    e    6   0,2,y  |  0,3,n  1,2,y  1,3,n  2,2,y
     *    s    7   0,2,n  |  0,3,y  1,2,n  1,3,y  2,2,n
     *         8   0,3,n  |  0,3,n  1,3,n  1,3,n  2,3,n
     *         9   0,3,y  |  0,4,n  1,3,y  1,4,n  2,3,y
     *        10   0,3,n  |  0,4,y  1,3,n  1,4,y  2,3,n
     *        11   0,4,n  |  0,4,n  1,4,n  1,4,n  2,4,n
     * 
     * 
     *      [Test fragment was of the form "a\\\"""b c" d.]
     * 
     * There is very weird mod-3 behaviour going on here in the
     * number of quotes, and it even applies when there aren't any
     * backslashes! How ghastly.
     * 
     * With a bit of thought, this extremely odd diagram suddenly
     * coalesced itself into a coherent, if still ghastly, model of
     * how things work:
     * 
     *  - As before, backslashes are only special when one or more
     *    of them appear contiguously before at least one double
     *    quote. In this situation the backslashes do exactly what
     *    you'd expect: each one quotes the next thing in front of
     *    it, so you end up with n/2 literal backslashes (if n is
     *    even) or (n-1)/2 literal backslashes and a literal quote
     *    (if n is odd). In the latter case the double quote
     *    character right after the backslashes is used up.
     * 
     *  - After that, any remaining double quotes are processed. A
     *    string of contiguous unescaped double quotes has a mod-3
     *    behaviour:
     * 
     *     * inside a quoted segment, a quote ends the segment.
     *     * _immediately_ after ending a quoted segment, a quote
     *       simply produces a literal quote.
     *     * otherwise, outside a quoted segment, a quote begins a
     *       quoted segment.
     * 
     *    So, for example, if we started inside a quoted segment
     *    then two contiguous quotes would close the segment and
     *    produce a literal quote; three would close the segment,
     *    produce a literal quote, and open a new segment. If we
     *    started outside a quoted segment, then two contiguous
     *    quotes would open and then close a segment, producing no
     *    output (but potentially creating a zero-length argument);
     *    but three quotes would open and close a segment and then
     *    produce a literal quote.
     
     * First deal with the simplest of all special cases: if there
     * aren't any arguments, return 0,NULL,NULL.
     
     * This will guaranteeably be big enough; we can realloc it
     * down later.
      Skip whitespace searching for start of argument.  We have an argument; start it.  Copy data into the argument until it's finished.  argument is finished 
		 * We have a sequence of zero or more backslashes
		 * followed by a sequence of zero or more quotes.
		 * Count up how many of each, and then deal with
		 * them as appropriate.
		 
		     * Special case: if there are no quotes,
		     * slashes are not special at all, so just copy
		     * n slashes to the output string.
		      Slashes annihilate in pairs.  One remaining slash takes out the first quote.  Outside a quote segment, a quote starts one.  Now we produce (n+1)/3 literal quotes...  ... and end in a quote segment iff 3 divides n.  At the end of an argument, just append a trailing NUL.  in case resource file is absent  vim: set shiftwidth=4 tabstop=8: 
 * windows.c: Windows front end for my puzzle collection.
  NO_HTMLHELP  NO_HTMLHELP  NO_HTMLHELP 
 * Wrapper implementations of functions not supplied by the
 * PocketPC API.
 DWORD dw;

    if (!debug_got_console) {
	if (AllocConsole()) {
	    debug_got_console = 1;
	    debug_hdl = GetStdHandle(STD_OUTPUT_HANDLE);
	}
    }
    if (!debug_fp) {
	debug_fp = fopen("debug.log", "w");
    }

    if (debug_hdl != INVALID_HANDLE_VALUE) {
	WriteFile(debug_hdl, buf, strlen(buf), &dw, NULL);
    }
    if (debug_fp) {
      fputs(buf, debug_fp);
      fflush(debug_fp);
    } window handle for the numeric pad  game bitmap position within game window  BitBlt(dstDC, dstX, dstY, dstW, dstH, srcDC, srcX, srcY, dType)  we should always have saved before loading  ick 
	 * Displaying text in hatched colours is not permitted.
	 
	     * This is only ever required during printing, and the
	     * PocketPC port doesn't support printing.
	      hatch == HATCH_X ? 
	 * Stroking in hatched colours is not permitted.
	 
     * Find or create the font.
     
     * Position and draw the text.
     
	 * Rectangle() appears to get uppity if asked to draw a 1x1
	 * rectangle, presumably on the grounds that that's beneath
	 * its dignity and you ought to be using SetPixel instead.
	 * So I will.
	 
     * Push a marker on the font stack so that we won't use the
     * same fonts for printing and drawing. (This is because
     * drawing seems to look generally better in bold, but printing
     * is better not in bold.)
     
     * Compute the puzzle's position on the logical page.
     
     * Work out what that comes to in pixels.
     
     * And determine the scale.
     * 
     * I need a scale such that the maximum puzzle-coordinate
     * extent of the rectangle (pw * scale) is equal to the pixel
     * equivalent of the puzzle's millimetre width (wmm * ppw /
     * mmpw).
     
     * Now store pox, poy and scale for use in the main drawing
     * functions.
      Nothing needs to be done here. 
     * Free all the fonts created since we began printing.
     
     * The MSDN web site sample code doesn't bother to call EndDoc
     * if an error occurs half way through printing. I expect doing
     * so would cause the erroneous document to actually be
     * printed, or something equally undesirable.
     
     * We assume Windows can cope with any UTF-8 likely to be
     * emitted by a puzzle.
      non-interactive midend for bulk puzzle generation 
     * Create our document structure and fill it up with puzzles.
     
		 * Set the non-interactive mid-end to have the same
		 * parameters as the standard one.
		 
     * Now pd.hDC is a device context for the printer.
     
     * FIXME: IWBNI we put up an Abort box here.
      for non-interactive midend  for non-interactive midend 
     * Windows expects CRLF in the clipboard, so we must convert
     * any \n that has come out of the puzzle backend.
     
 * Set up Help and see if we can find a help file.
 
     * Find the executable file path, so we can look alongside
     * it for help files. Trim the filename off the end.
     
     * Try HTML Help first.
     
	 * We have a .CHM. See if we can use it.
	  NO_HTMLHELP 
     * Now try old-style .HLP.
     
	 * See if there's a .CNT file alongside it.
	  didn't find any 
 * Start Help.
  NO_HTMLHELP 
 * Stop Help on window cleanup.
  NO_HTMLHELP 
 * Terminate Help on process exit.
  Nothing to do currently.
     * (If we were running HTML Help single-threaded, this is where we'd
     * call HH_UNINITIALIZE.) 
 * Given a proposed new puzzle size (cx,cy), work out the actual
 * puzzle size that would be (px,py) and the window size including
 * furniture (wx,wy).
  disallow making window thinner than menu bar 
     * See if we actually got the window size we wanted, and adjust
     * the puzzle size if not.
     
         * Resize the window, now we know what size we _really_
         * want it to be.
         
 * Given the current window size, make sure it's sane for the
 * current puzzle and resize if necessary.
  Toolbar buttons on the numeric pad 
 * Allocate a new frontend structure and create its main window.
 
 * Create an appropriate midend structure to go in a puzzle window,
 * given a game type and/or a command-line argument.
 *
 * 'arg' can be either a game ID string (descriptive, random, or a
 * plain set of parameters) or the filename of a save file. The two
 * boolean flag arguments indicate which possibilities are
 * permissible.
 
         * See if arg is a valid filename of a save game file.
         
             * Find out what kind of game is stored in the save
             * file; if we're going to end up loading that, it
             * will have to override our caller's judgment as to
             * what game to initialise our midend with.
              go back to the start for actual load 
             * See if arg is a game description.
             
         * FIXME: we ought to go through and do something with ampersands
         * here.
         
 * Populate a frontend structure with a new midend structure, and
 * create any window furniture that it needs.
 *
 * Previously-allocated memory and window furniture will be freed by
 * this function.
 *
  status bar does these  status bar does these  Flat status bar looks better on the Pocket PC 
	 * Now resize the window to take account of the status bar.
	  ...here I run out of sensible accelerator characters.  only include those games that aren't the same as the
                     * game we're currently playing. ick initialises fe->bitmap  - ((8 * GetDeviceCaps(hdc, LOGPIXELSY)) / 72)  Make dialog full screen 
 * Wrappers on midend_{get,set}_config, which extend the CFG_*
 * enumeration to add CFG_PRINT.
  Separate version of mkctrl function for the Pocket PC.  Control coordinates should be specified in dialog units.  Convert dialog units into pixels  Control placement done in dialog units  Label column  Input column (edit boxes and combo boxes) 
     * Count the controls so we can allocate cfgaux.
      Leave some room for the dialog title 
	     * Edit box with a label beside it.
	     
	     * Simple checkbox.
	     
	     * Drop-down list with a label beside it.
	     
	 * OK and Cancel are special cases.
	 
	 * First find the control whose id this is.
	  not our problem 
     * Figure out the layout of the About box by measuring the
     * length of each piece of text.
      *shrug*  OK button 
     * Create the dialog, now that we know its size.
     |
				DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
				WS_CAPTION | WS_SYSMENU
	 * Centre the dialog on its parent window.
	  extra space before OK 
     * Figure out the layout of the config box by measuring the
     * length of each piece of text.
     
	     * Both these control types have a label filling only
	     * the left-hand column of the box.
	     
	     * Checkboxes take up the whole of the box width.
	      OK / Cancel buttons 
     * Create the dialog, now that we know its size.
     |
				DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
				WS_CAPTION | WS_SYSMENU
	 * Centre the dialog on its parent window.
	 
     * Count the controls so we can allocate cfgaux.
     
	     * Edit box with a label beside it.
	     
	     * Simple checkbox.
	     
	     * Drop-down list with a label beside it.
	      extra space before OK and Cancel  Pocket PC - center the game in the full screen window  Plain Windows - position the game in the upper-left corner 
 * Given a proposed new window rect, work out the resulting
 * difference in client size (from current), and use to try
 * and resize the puzzle, returning (wx,wy) as the actual
 * new window size.
  Work out the current window sizing, and thus the
     * difference in size we're asking for.  These next four lines work around the fact that midend_size
       * is happy to shrink _but not grow_ if you change one dimension
       * but not the other.  reset size to current window size  Re-fetch rectangle; size limits mean we might not have
     * taken it quite to the mouse drag positions.  "Custom" menu item is at the bottom of the top-level Type menu  Numeric pad sends WM_COMMAND messages  low 4 bits reserved to Windows  file exists 
                         * This save file might be from a different
                         * game.
                          for the actual load 
		 * Diagonal keys on the numeric keypad.
		 
		 * Numeric keypad keys with Num Lock on.
		 
	     * Shift-clicks count as middle-clicks, since otherwise
	     * two-button Windows users won't have any kind of
	     * middle click to use.
	     
	     * Shift-clicks count as middle-clicks, since otherwise
	     * two-button Windows users won't have any kind of
	     * middle click to use.
	      Given the window size the puzzles constrain
             * us to, work out which edge we should be moving.  Check if application is running. If it's running then focus on the window 
 * Split a complete command line into argc/argv, attempting to do it
 * exactly the same way the Visual Studio C library would do it (so
 * that our console utilities, which receive argc and argv already
 * broken apart by the C library, will have their command lines
 * processed in the same way as the GUI utilities which get a whole
 * command line and must call this function).
 * 
 * Does not modify the input command line.
 * 
 * The final parameter (argstart) is used to return a second array
 * of char * pointers, the same length as argv, each one pointing
 * at the start of the corresponding element of argv in the
 * original command line. So if you get half way through processing
 * your command line in argc/argv form and then decide you want to
 * treat the rest as a raw string, you can. If you don't want to,
 * `argstart' can be safely left NULL.
 
     * These argument-breaking rules apply to Visual Studio 7, which
     * is currently the compiler expected to be used for the Windows
     * port of my puzzles. Visual Studio 10 has different rules,
     * lacking the curious mod 3 behaviour of consecutive quotes
     * described below; I presume they fixed a bug. As and when we
     * migrate to a newer compiler, we'll have to adjust this to
     * match; however, for the moment we faithfully imitate in our GUI
     * utilities what our CLI utilities can't be prevented from doing.
     *
     * When I investigated this, at first glance the rules appeared to
     * be:
     *
     *  - Single quotes are not special characters.
     *
     *  - Double quotes are removed, but within them spaces cease
     *    to be special.
     *
     *  - Backslashes are _only_ special when a sequence of them
     *    appear just before a double quote. In this situation,
     *    they are treated like C backslashes: so \" just gives a
     *    literal quote, \\" gives a literal backslash and then
     *    opens or closes a double-quoted segment, \\\" gives a
     *    literal backslash and then a literal quote, \\\\" gives
     *    two literal backslashes and then opens/closes a
     *    double-quoted segment, and so forth. Note that this
     *    behaviour is identical inside and outside double quotes.
     *
     *  - Two successive double quotes become one literal double
     *    quote, but only _inside_ a double-quoted segment.
     *    Outside, they just form an empty double-quoted segment
     *    (which may cause an empty argument word).
     *
     *  - That only leaves the interesting question of what happens
     *    when one or more backslashes precedes two or more double
     *    quotes, starting inside a double-quoted string. And the
     *    answer to that appears somewhat bizarre. Here I tabulate
     *    number of backslashes (across the top) against number of
     *    quotes (down the left), and indicate how many backslashes
     *    are output, how many quotes are output, and whether a
     *    quoted segment is open at the end of the sequence:
     * 
     *                      backslashes
     * 
     *               0         1      2      3      4
     * 
     *         0   0,0,y  |  1,0,y  2,0,y  3,0,y  4,0,y
     *            --------+-----------------------------
     *         1   0,0,n  |  0,1,y  1,0,n  1,1,y  2,0,n
     *    q    2   0,1,n  |  0,1,n  1,1,n  1,1,n  2,1,n
     *    u    3   0,1,y  |  0,2,n  1,1,y  1,2,n  2,1,y
     *    o    4   0,1,n  |  0,2,y  1,1,n  1,2,y  2,1,n
     *    t    5   0,2,n  |  0,2,n  1,2,n  1,2,n  2,2,n
     *    e    6   0,2,y  |  0,3,n  1,2,y  1,3,n  2,2,y
     *    s    7   0,2,n  |  0,3,y  1,2,n  1,3,y  2,2,n
     *         8   0,3,n  |  0,3,n  1,3,n  1,3,n  2,3,n
     *         9   0,3,y  |  0,4,n  1,3,y  1,4,n  2,3,y
     *        10   0,3,n  |  0,4,y  1,3,n  1,4,y  2,3,n
     *        11   0,4,n  |  0,4,n  1,4,n  1,4,n  2,4,n
     * 
     * 
     *      [Test fragment was of the form "a\\\"""b c" d.]
     * 
     * There is very weird mod-3 behaviour going on here in the
     * number of quotes, and it even applies when there aren't any
     * backslashes! How ghastly.
     * 
     * With a bit of thought, this extremely odd diagram suddenly
     * coalesced itself into a coherent, if still ghastly, model of
     * how things work:
     * 
     *  - As before, backslashes are only special when one or more
     *    of them appear contiguously before at least one double
     *    quote. In this situation the backslashes do exactly what
     *    you'd expect: each one quotes the next thing in front of
     *    it, so you end up with n/2 literal backslashes (if n is
     *    even) or (n-1)/2 literal backslashes and a literal quote
     *    (if n is odd). In the latter case the double quote
     *    character right after the backslashes is used up.
     * 
     *  - After that, any remaining double quotes are processed. A
     *    string of contiguous unescaped double quotes has a mod-3
     *    behaviour:
     * 
     *     * inside a quoted segment, a quote ends the segment.
     *     * _immediately_ after ending a quoted segment, a quote
     *       simply produces a literal quote.
     *     * otherwise, outside a quoted segment, a quote begins a
     *       quoted segment.
     * 
     *    So, for example, if we started inside a quoted segment
     *    then two contiguous quotes would close the segment and
     *    produce a literal quote; three would close the segment,
     *    produce a literal quote, and open a new segment. If we
     *    started outside a quoted segment, then two contiguous
     *    quotes would open and then close a segment, producing no
     *    output (but potentially creating a zero-length argument);
     *    but three quotes would open and close a segment and then
     *    produce a literal quote.
     
     * First deal with the simplest of all special cases: if there
     * aren't any arguments, return 0,NULL,NULL.
     
     * This will guaranteeably be big enough; we can realloc it
     * down later.
      Skip whitespace searching for start of argument.  We have an argument; start it.  Copy data into the argument until it's finished.  argument is finished 
		 * We have a sequence of zero or more backslashes
		 * followed by a sequence of zero or more quotes.
		 * Count up how many of each, and then deal with
		 * them as appropriate.
		 
		     * Special case: if there are no quotes,
		     * slashes are not special at all, so just copy
		     * n slashes to the output string.
		      Slashes annihilate in pairs.  One remaining slash takes out the first quote.  Outside a quote segment, a quote starts one.  Now we produce (n+1)/3 literal quotes...  ... and end in a quote segment iff 3 divides n.  At the end of an argument, just append a trailing NUL.  in case resource file is absent  vim: set shiftwidth=4 tabstop=8: 