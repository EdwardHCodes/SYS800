**************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * Copyright (C) 2002 Philipp Pertermann
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 *************************************************************************** size of the field the worm lives in  when the game starts  num of pixel the worm grows per eaten food  num of worms creeping in the FIELD  minimal distance between a worm and an argh
   when a new argh is made *
 * All the properties that a worm has.
  The worm is stored in a ring of xy coordinates  index of the head within the buffer  index of the tail within the buffer  number of cyles the worm still keeps growing  the worms living state  direction vector in which the worm moves  only values -1 0 1 allowed  only values -1 0 1 allowed  this method is used to fetch the direction the user
       has selected. It can be one of the values
       human_player1, human_player2, remote_player, virtual_player.
       All these values are fuctions, that can change the direction
       of the worm  stores the highscore - besides it was scored by a virtual player  maximal number of food items  The arrays store the food coordinates   maximal number of argh items  number of arghs produced per eaten food  The arrays store the argh coordinates  the number of arghs that are currently in use  the number of arghs per food, settable by user  the size of the argh, settable by user  the size of the food, settable by user  the speed of the worm, settable by user  the amount a worm grows by eating a food, settable by user  End additional variables  the number of active worms (dead or alive)  in multiplayer mode: en- / disables the remote worm control
   in singleplayer mode: toggles 4 / 2 button worm control  return values of check_collision  constants for use as directions.
   Note that the values are ordered clockwise.
   Thus increasing / decreasing the values
   is equivalent to right / left turns.  direction of human player 1  direction of human player 2  direction of human player 3  the number of (human) players that currently
   control a worm *
 * Returns the direction id in which the worm
 * currently is creeping.
 * @param struct worm *w The worm that is to be investigated.
 *        w Must not be null.
 * @return int A value 0 <= value < 4
 *         Note the predefined constants NORTH, SOUTH, EAST, WEST
 *
 * Set the direction of the specified worm with a direction id.
 * Increasing the value by 1 means to turn the worm direction
 * to right by 90 degree.
 * @param struct worm *w The worm that is to be altered. w Must not be null.
 * @param int dir The new direction in which the worm is to creep.
 *        dir must be  0 <= dir < 4. Use predefined constants
 *        NORTH, SOUTH, EAST, WEST
 *
 * Returns the current length of the worm array. This
 * is also a value for the number of bends that are in the worm.
 * @return int a positive value with 0 <= value < MAX_WORM_SEGMENTS
  initial simple calculation will be overwritten if wrong.  if the worm 'crosses' the boundaries of the ringbuffer *
 * Returns the score the specified worm. The score is the length
 * of the worm.
 * @param struct worm *w The worm that is to be investigated.
 *        w must not be null.
 * @return int The length of the worm (>= 0).
  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Determines wether the line specified by startx, starty, endx, endy intersects
 * the rectangle specified by x, y, width, height. Note that the line must be exactly
 * horizontal or vertical (startx == endx or starty == endy).
 * @param int startx The x coordinate of the start point of the line.
 * @param int starty The y coordinate of the start point of the line.
 * @param int endx The x coordinate of the end point of the line.
 * @param int endy The y coordinate of the end point of the line.
 * @param int x The x coordinate of the top left corner of the rectangle.
 * @param int y The y coordinate of the top left corner of the rectangle.
 * @param int width The width of the rectangle.
 * @param int height The height of the rectangle.
 * @return bool Returns true if the specified line intersects with the recangle.
 *
 * Tests wether the specified worm intersects with the rect.
 * @param struct worm *w The worm to be investigated
 * @param int x The x coordinate of the top left corner of the rect
 * @param int y The y coordinate of the top left corner of the rect
 * @param int widht The width of the rect
 * @param int height The height of the rect
 * @return bool Returns true if the worm intersects with the rect
  get_worm_array_length is expensive -> buffer the value  test each entry that is part of the worm  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Checks wether a specific food in the food arrays is at the
 * specified coordinates.
 * @param int foodIndex The index of the food in the food arrays
 * @param int x the x coordinate.
 * @param int y the y coordinate.
 * @return Returns true if the coordinate hits the food specified by
 * foodIndex.
 *
 * Returns the index of the food that is at the
 * given coordinates. If no food is at the coordinates
 * -1 is returned.
 * @return int  -1 <= value < MAX_FOOD
 *
 * Checks wether a specific argh in the argh arrays is at the
 * specified coordinates.
 * @param int arghIndex The index of the argh in the argh arrays
 * @param int x the x coordinate.
 * @param int y the y coordinate.
 * @return Returns true if the coordinate hits the argh specified by
 * arghIndex.
 *
 * Returns the index of the argh that is at the
 * given coordinates. If no argh is at the coordinates
 * -1 is returned.
 * @param int x The x coordinate.
 * @param int y The y coordinate.
 * @return int  -1 <= value < argh_count <= MAX_ARGH
  search for the argh that has the specified coords *
 * Checks wether the worm collides with the food at the specfied food-arrays.
 * @param int foodIndex The index of the food in the arrays. Ensure the value is
 * 0 <= foodIndex <= MAX_FOOD
 * @return Returns true if the worm collides with the specified food.
 *
 * Returns true if the worm hits the argh within the next moves (unless
 * the worm changes it's direction).
 * @param struct worm *w - The worm to investigate
 * @param int argh_idx - The index of the argh
 * @param int moves - The number of moves that are considered.
 * @return Returns false if the specified argh is not hit within the next
 *         moves.
 *
 * Checks wether the worm collides with the argh at the specfied argh-arrays.
 * @param int arghIndex The index of the argh in the arrays.
 * Ensure the value is 0 <= arghIndex < argh_count <= MAX_ARGH
 * @return Returns true if the worm collides with the specified argh.
 *
 * Find new coordinates for the food stored in foodx[index], foody[index]
 * that don't collide with any other food or argh
 * @param int index
 * Ensure that 0 <= index < MAX_FOOD.
  make coordinates for a new food so that
           the entire food lies within the FIELD  Ensure that the new food doesn't collide with any
           existing foods or arghs.
           If the new food hit any existing
           argh or food a collision is detected.
         use coordinates for further testing  now test wether we accidently hit the worm with food ;) *
 * Clears a food from the lcd buffer.
 * @param int index The index of the food arrays under which
 * the coordinates of the desired food can be found. Ensure
 * that the value is 0 <= index <= MAX_FOOD.
  remove the old food from the screen *
 * Draws a food in the lcd buffer.
 * @param int index The index of the food arrays under which
 * the coordinates of the desired food can be found. Ensure
 * that the value is 0 <= index <= MAX_FOOD.
  draw the food object *
 * Find new coordinates for the argh stored in arghx[index], arghy[index]
 * that don't collide with any other food or argh.
 * @param int index
 * Ensure that 0 <= index < argh_count < MAX_ARGH.
  make coordinates for a new argh so that
           the entire food lies within the FIELD  Ensure that the new argh doesn't intersect with any
           existing foods or arghs.
           If the new argh hit any existing
           argh or food an intersection is detected.
         use the candidate coordinates to make a real argh  now test wether we accidently hit the worm with argh ;) *
 * Draws an argh in the lcd buffer.
 * @param int index The index of the argh arrays under which
 * the coordinates of the desired argh can be found. Ensure
 * that the value is 0 <= index < argh_count <= MAX_ARGH.
  draw the new argh *
 * Initialzes the specified worm with INITIAL_WORM_LENGTH
 * and the tail at the specified position. The worm will
 * be initialized alive and creeping EAST.
 * @param struct worm *w The worm that is to be initialized
 * @param int x The x coordinate at which the tail of the worm starts.
 *        x must be 0 <= x < FIELD_RECT_WIDTH.
 * @param int y The y coordinate at which the tail of the worm starts
 *        y must be 0 <= y < FIELD_RECT_WIDTH.
  initialize the worm size  set the initial direction the worm creeps to *
 * Writes the direction that was stored for
 * human player 1 into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player1_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Writes the direction that was stored for
 * human player 2 into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player2_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Writes the direction that was stored for
 * human player using a remote control
 * into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player3_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Initializes the worm-, food- and argh-arrays, draws a frame,
 * makes some food and argh and display all that stuff.
  Initialize all the worm coordinates to center.  Needed when the game is restarted using BTN_STOPRESET  make and display some food and argh  draw the game field  make everything visible *
 * Move the worm one step further if it is alive.
 * The direction in which the worm moves is taken from dirx and diry.
 * move_worm decreases growing if > 0. While the worm is growing the tail
 * is left untouched.
 * @param struct worm *w The worm to move. w must not be NULL.
  determine the head point and its precessor  determine the old direction  olddir == dir?
           a change of direction means a new segment
           has been opened  new head position  while the worm is growing no tail procession is necessary  update the worms grow state  if the worm isn't growing the tail has to be dragged  index of the end of the tail segment  drag the end of the tail  only one coordinate has to be altered. Here it is
               determined which one  specifies wether the coord has to be in- or decreased  when the tail has been dragged so far that it meets
               the next segment start the tail segment is obsolete and
               must be freed  drop the last tail point *
 * Draws the head and clears the tail of the worm in
 * the display buffer. lcd_update() is NOT called thus
 * the caller has to take care that the buffer is displayed.
  draw the new head  clear the space behind the worm *
 * Checks wether the coordinate is part of the worm. Returns
 * true if any part of the worm was hit - including the head.
 * @param x int The x coordinate
 * @param y int The y coordinate
 * @return int The index of the worm arrays that contain x, y.
 * Returns -1 if the coordinates are not part of the worm.
  get_worm_array_length is expensive -> buffer the value  test each entry that is part of the worm  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Increases the length of the specified worm by marking
 * that it may grow by len pixels. Note that the worm has
 * to move to make the growing happen.
 * @param worm *w The worm that is to be altered.
 * @param int len A positive value specifying the amount of
 * pixels the worm may grow.
 *
 * Determins the worm that is at the coordinates x, y. The parameter
 * w is a switch parameter that changes the functionality of worm_collision.
 * If w is specified and x,y hits the head of w NULL is returned.
 * This is a useful way to determine wether the head of w hits
 * any worm but including itself but excluding its own head.
 * (It hits always its own head ;))
 * If w is set to NULL worm_collision returns any worm including all heads
 * that is at position of x,y.
 * @param struct worm *w The worm of which the head should be excluded in
 * the test. w may be set to NULL.
 * @param int x The x coordinate that is checked
 * @param int y The y coordinate that is checkec
 * @return struct worm*  The worm that has been hit by x,y. If no worm
 * was at the position NULL is returned.
 *
 * Returns true if the head of the worm just has
 * crossed the field boundaries.
 * @return bool true if the worm just has wrapped.
 *
 * Returns true if the specified coordinates are within the
 * field specified by the FIELD_RECT_XXX constants.
 * @param int x The x coordinate of the point that is investigated
 * @param int y The y coordinate of the point that is investigated
 * @return bool Returns false if x,y specifies a point outside the
 * field of worms.
 *
 * Checks and returns wether the head of the w
 * is colliding with something currently.
 * @return int One of the values:
 *   COLLISION_NONE
 *   COLLISION_w
 *   COLLISION_FOOD
 *   COLLISION_ARGH
 *   COLLISION_FIELD
 *
 * Returns the index of the food that is closest to the point
 * specified by x, y. This index may be used in the foodx and
 * foody arrays.
 * @param int x The x coordinate of the point
 * @param int y The y coordinate of the point
 * @return int A value usable as index in foodx and foody.
 *
 * Returns wether the specified position is next to the worm
 * and in the direction the worm looks. Use this method to
 * test wether this position would be hit with the next move of
 * the worm unless the worm changes its direction.
 * @param struct worm *w - The worm to be investigated
 * @param int x - The x coordinate of the position to test.
 * @param int y - The y coordinate of the position to test.
 * @return Returns true if the worm will hit the position unless
 * it change its direction before the next move.
 *
 * Returns true if the worm will collide with the next move unless
 * it changes its direction.
 * @param struct worm *w - The worm to be investigated.
 * @return Returns true if the worm will collide with the next move
 * unless it changes its direction.
 *
 * This function
 * may be used to be stored in worm.fetch_worm_direction for
 * worms that are not controlled by humans but by artificial stupidity.
 * A direction is searched that doesn't lead to collision but to the nearest
 * food - but not very intelligent. The direction is written to the specified
 * worm.
 * @param struct worm *w - The worm of which the direction
 * is altered.
  find the next lunch  determine in which direction it is  in front of me?  left right of me?  detect situation, set strategy  test for collision  plan b  test for collision  plan c *
 * prints out the score board with all the status information
 * about the game.
  high score  worm state  length *
 * Checks for collisions of the worm and its environment and
 * takes appropriate actions like growing the worm or killing it.
 * @return bool Returns true if the worm is dead. Returns
 * false if the worm is healthy, up and creeping.
  check if food was eaten  check if argh was eaten *
 * The main loop of the game.
 * @return bool Returns true if the game ended
 * with a dead worm. Returns false if the user
 * aborted the game manually.
  ticks are counted to compensate speed variations  initialize the board and so on  change the direction of the worm  restart game  back to menu  here the wormlet game cycle ends
               thus the current tick is stored
               as end time  The duration of the game cycle  adjust the number of ticks to wait for a button.
           This ensures that a complete game cycle including
           user input runs in constant time  back to menu *
 * Just a test routine that checks that worm_food_collision works
 * in some typical situations.
  Test 1  test 2  test 3  test 4  test 5  test 6  test 7  test 8  test 9  test 10  test 11  test 12  test 13  test 14 *
 * Just a test routine to test wether specific_worm_collision might work properly
  DEBUG_WORMLET 
 * Reverts default settings
 
 * Launches the wormlet game
  Turn off backlight timeout  start the game  Turn on backlight timeout (revert to settings) *
 * Main entry point
  If the loading failed, save a new config file (as the disk is
           already spinning)  Setup screen **************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * Copyright (C) 2002 Philipp Pertermann
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 *************************************************************************** size of the field the worm lives in  when the game starts  num of pixel the worm grows per eaten food  num of worms creeping in the FIELD  minimal distance between a worm and an argh
   when a new argh is made *
 * All the properties that a worm has.
  The worm is stored in a ring of xy coordinates  index of the head within the buffer  index of the tail within the buffer  number of cyles the worm still keeps growing  the worms living state  direction vector in which the worm moves  only values -1 0 1 allowed  only values -1 0 1 allowed  this method is used to fetch the direction the user
       has selected. It can be one of the values
       human_player1, human_player2, remote_player, virtual_player.
       All these values are fuctions, that can change the direction
       of the worm  stores the highscore - besides it was scored by a virtual player  maximal number of food items  The arrays store the food coordinates   maximal number of argh items  number of arghs produced per eaten food  The arrays store the argh coordinates  the number of arghs that are currently in use  the number of arghs per food, settable by user  the size of the argh, settable by user  the size of the food, settable by user  the speed of the worm, settable by user  the amount a worm grows by eating a food, settable by user  End additional variables  the number of active worms (dead or alive)  in multiplayer mode: en- / disables the remote worm control
   in singleplayer mode: toggles 4 / 2 button worm control  return values of check_collision  constants for use as directions.
   Note that the values are ordered clockwise.
   Thus increasing / decreasing the values
   is equivalent to right / left turns.  direction of human player 1  direction of human player 2  direction of human player 3  the number of (human) players that currently
   control a worm *
 * Returns the direction id in which the worm
 * currently is creeping.
 * @param struct worm *w The worm that is to be investigated.
 *        w Must not be null.
 * @return int A value 0 <= value < 4
 *         Note the predefined constants NORTH, SOUTH, EAST, WEST
 *
 * Set the direction of the specified worm with a direction id.
 * Increasing the value by 1 means to turn the worm direction
 * to right by 90 degree.
 * @param struct worm *w The worm that is to be altered. w Must not be null.
 * @param int dir The new direction in which the worm is to creep.
 *        dir must be  0 <= dir < 4. Use predefined constants
 *        NORTH, SOUTH, EAST, WEST
 *
 * Returns the current length of the worm array. This
 * is also a value for the number of bends that are in the worm.
 * @return int a positive value with 0 <= value < MAX_WORM_SEGMENTS
  initial simple calculation will be overwritten if wrong.  if the worm 'crosses' the boundaries of the ringbuffer *
 * Returns the score the specified worm. The score is the length
 * of the worm.
 * @param struct worm *w The worm that is to be investigated.
 *        w must not be null.
 * @return int The length of the worm (>= 0).
  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Determines wether the line specified by startx, starty, endx, endy intersects
 * the rectangle specified by x, y, width, height. Note that the line must be exactly
 * horizontal or vertical (startx == endx or starty == endy).
 * @param int startx The x coordinate of the start point of the line.
 * @param int starty The y coordinate of the start point of the line.
 * @param int endx The x coordinate of the end point of the line.
 * @param int endy The y coordinate of the end point of the line.
 * @param int x The x coordinate of the top left corner of the rectangle.
 * @param int y The y coordinate of the top left corner of the rectangle.
 * @param int width The width of the rectangle.
 * @param int height The height of the rectangle.
 * @return bool Returns true if the specified line intersects with the recangle.
 *
 * Tests wether the specified worm intersects with the rect.
 * @param struct worm *w The worm to be investigated
 * @param int x The x coordinate of the top left corner of the rect
 * @param int y The y coordinate of the top left corner of the rect
 * @param int widht The width of the rect
 * @param int height The height of the rect
 * @return bool Returns true if the worm intersects with the rect
  get_worm_array_length is expensive -> buffer the value  test each entry that is part of the worm  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Checks wether a specific food in the food arrays is at the
 * specified coordinates.
 * @param int foodIndex The index of the food in the food arrays
 * @param int x the x coordinate.
 * @param int y the y coordinate.
 * @return Returns true if the coordinate hits the food specified by
 * foodIndex.
 *
 * Returns the index of the food that is at the
 * given coordinates. If no food is at the coordinates
 * -1 is returned.
 * @return int  -1 <= value < MAX_FOOD
 *
 * Checks wether a specific argh in the argh arrays is at the
 * specified coordinates.
 * @param int arghIndex The index of the argh in the argh arrays
 * @param int x the x coordinate.
 * @param int y the y coordinate.
 * @return Returns true if the coordinate hits the argh specified by
 * arghIndex.
 *
 * Returns the index of the argh that is at the
 * given coordinates. If no argh is at the coordinates
 * -1 is returned.
 * @param int x The x coordinate.
 * @param int y The y coordinate.
 * @return int  -1 <= value < argh_count <= MAX_ARGH
  search for the argh that has the specified coords *
 * Checks wether the worm collides with the food at the specfied food-arrays.
 * @param int foodIndex The index of the food in the arrays. Ensure the value is
 * 0 <= foodIndex <= MAX_FOOD
 * @return Returns true if the worm collides with the specified food.
 *
 * Returns true if the worm hits the argh within the next moves (unless
 * the worm changes it's direction).
 * @param struct worm *w - The worm to investigate
 * @param int argh_idx - The index of the argh
 * @param int moves - The number of moves that are considered.
 * @return Returns false if the specified argh is not hit within the next
 *         moves.
 *
 * Checks wether the worm collides with the argh at the specfied argh-arrays.
 * @param int arghIndex The index of the argh in the arrays.
 * Ensure the value is 0 <= arghIndex < argh_count <= MAX_ARGH
 * @return Returns true if the worm collides with the specified argh.
 *
 * Find new coordinates for the food stored in foodx[index], foody[index]
 * that don't collide with any other food or argh
 * @param int index
 * Ensure that 0 <= index < MAX_FOOD.
  make coordinates for a new food so that
           the entire food lies within the FIELD  Ensure that the new food doesn't collide with any
           existing foods or arghs.
           If the new food hit any existing
           argh or food a collision is detected.
         use coordinates for further testing  now test wether we accidently hit the worm with food ;) *
 * Clears a food from the lcd buffer.
 * @param int index The index of the food arrays under which
 * the coordinates of the desired food can be found. Ensure
 * that the value is 0 <= index <= MAX_FOOD.
  remove the old food from the screen *
 * Draws a food in the lcd buffer.
 * @param int index The index of the food arrays under which
 * the coordinates of the desired food can be found. Ensure
 * that the value is 0 <= index <= MAX_FOOD.
  draw the food object *
 * Find new coordinates for the argh stored in arghx[index], arghy[index]
 * that don't collide with any other food or argh.
 * @param int index
 * Ensure that 0 <= index < argh_count < MAX_ARGH.
  make coordinates for a new argh so that
           the entire food lies within the FIELD  Ensure that the new argh doesn't intersect with any
           existing foods or arghs.
           If the new argh hit any existing
           argh or food an intersection is detected.
         use the candidate coordinates to make a real argh  now test wether we accidently hit the worm with argh ;) *
 * Draws an argh in the lcd buffer.
 * @param int index The index of the argh arrays under which
 * the coordinates of the desired argh can be found. Ensure
 * that the value is 0 <= index < argh_count <= MAX_ARGH.
  draw the new argh *
 * Initialzes the specified worm with INITIAL_WORM_LENGTH
 * and the tail at the specified position. The worm will
 * be initialized alive and creeping EAST.
 * @param struct worm *w The worm that is to be initialized
 * @param int x The x coordinate at which the tail of the worm starts.
 *        x must be 0 <= x < FIELD_RECT_WIDTH.
 * @param int y The y coordinate at which the tail of the worm starts
 *        y must be 0 <= y < FIELD_RECT_WIDTH.
  initialize the worm size  set the initial direction the worm creeps to *
 * Writes the direction that was stored for
 * human player 1 into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player1_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Writes the direction that was stored for
 * human player 2 into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player2_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Writes the direction that was stored for
 * human player using a remote control
 * into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player3_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Initializes the worm-, food- and argh-arrays, draws a frame,
 * makes some food and argh and display all that stuff.
  Initialize all the worm coordinates to center.  Needed when the game is restarted using BTN_STOPRESET  make and display some food and argh  draw the game field  make everything visible *
 * Move the worm one step further if it is alive.
 * The direction in which the worm moves is taken from dirx and diry.
 * move_worm decreases growing if > 0. While the worm is growing the tail
 * is left untouched.
 * @param struct worm *w The worm to move. w must not be NULL.
  determine the head point and its precessor  determine the old direction  olddir == dir?
           a change of direction means a new segment
           has been opened  new head position  while the worm is growing no tail procession is necessary  update the worms grow state  if the worm isn't growing the tail has to be dragged  index of the end of the tail segment  drag the end of the tail  only one coordinate has to be altered. Here it is
               determined which one  specifies wether the coord has to be in- or decreased  when the tail has been dragged so far that it meets
               the next segment start the tail segment is obsolete and
               must be freed  drop the last tail point *
 * Draws the head and clears the tail of the worm in
 * the display buffer. lcd_update() is NOT called thus
 * the caller has to take care that the buffer is displayed.
  draw the new head  clear the space behind the worm *
 * Checks wether the coordinate is part of the worm. Returns
 * true if any part of the worm was hit - including the head.
 * @param x int The x coordinate
 * @param y int The y coordinate
 * @return int The index of the worm arrays that contain x, y.
 * Returns -1 if the coordinates are not part of the worm.
  get_worm_array_length is expensive -> buffer the value  test each entry that is part of the worm  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Increases the length of the specified worm by marking
 * that it may grow by len pixels. Note that the worm has
 * to move to make the growing happen.
 * @param worm *w The worm that is to be altered.
 * @param int len A positive value specifying the amount of
 * pixels the worm may grow.
 *
 * Determins the worm that is at the coordinates x, y. The parameter
 * w is a switch parameter that changes the functionality of worm_collision.
 * If w is specified and x,y hits the head of w NULL is returned.
 * This is a useful way to determine wether the head of w hits
 * any worm but including itself but excluding its own head.
 * (It hits always its own head ;))
 * If w is set to NULL worm_collision returns any worm including all heads
 * that is at position of x,y.
 * @param struct worm *w The worm of which the head should be excluded in
 * the test. w may be set to NULL.
 * @param int x The x coordinate that is checked
 * @param int y The y coordinate that is checkec
 * @return struct worm*  The worm that has been hit by x,y. If no worm
 * was at the position NULL is returned.
 *
 * Returns true if the head of the worm just has
 * crossed the field boundaries.
 * @return bool true if the worm just has wrapped.
 *
 * Returns true if the specified coordinates are within the
 * field specified by the FIELD_RECT_XXX constants.
 * @param int x The x coordinate of the point that is investigated
 * @param int y The y coordinate of the point that is investigated
 * @return bool Returns false if x,y specifies a point outside the
 * field of worms.
 *
 * Checks and returns wether the head of the w
 * is colliding with something currently.
 * @return int One of the values:
 *   COLLISION_NONE
 *   COLLISION_w
 *   COLLISION_FOOD
 *   COLLISION_ARGH
 *   COLLISION_FIELD
 *
 * Returns the index of the food that is closest to the point
 * specified by x, y. This index may be used in the foodx and
 * foody arrays.
 * @param int x The x coordinate of the point
 * @param int y The y coordinate of the point
 * @return int A value usable as index in foodx and foody.
 *
 * Returns wether the specified position is next to the worm
 * and in the direction the worm looks. Use this method to
 * test wether this position would be hit with the next move of
 * the worm unless the worm changes its direction.
 * @param struct worm *w - The worm to be investigated
 * @param int x - The x coordinate of the position to test.
 * @param int y - The y coordinate of the position to test.
 * @return Returns true if the worm will hit the position unless
 * it change its direction before the next move.
 *
 * Returns true if the worm will collide with the next move unless
 * it changes its direction.
 * @param struct worm *w - The worm to be investigated.
 * @return Returns true if the worm will collide with the next move
 * unless it changes its direction.
 *
 * This function
 * may be used to be stored in worm.fetch_worm_direction for
 * worms that are not controlled by humans but by artificial stupidity.
 * A direction is searched that doesn't lead to collision but to the nearest
 * food - but not very intelligent. The direction is written to the specified
 * worm.
 * @param struct worm *w - The worm of which the direction
 * is altered.
  find the next lunch  determine in which direction it is  in front of me?  left right of me?  detect situation, set strategy  test for collision  plan b  test for collision  plan c *
 * prints out the score board with all the status information
 * about the game.
  high score  worm state  length *
 * Checks for collisions of the worm and its environment and
 * takes appropriate actions like growing the worm or killing it.
 * @return bool Returns true if the worm is dead. Returns
 * false if the worm is healthy, up and creeping.
  check if food was eaten  check if argh was eaten *
 * The main loop of the game.
 * @return bool Returns true if the game ended
 * with a dead worm. Returns false if the user
 * aborted the game manually.
  ticks are counted to compensate speed variations  initialize the board and so on  change the direction of the worm  restart game  back to menu  here the wormlet game cycle ends
               thus the current tick is stored
               as end time  The duration of the game cycle  adjust the number of ticks to wait for a button.
           This ensures that a complete game cycle including
           user input runs in constant time  back to menu *
 * Just a test routine that checks that worm_food_collision works
 * in some typical situations.
  Test 1  test 2  test 3  test 4  test 5  test 6  test 7  test 8  test 9  test 10  test 11  test 12  test 13  test 14 *
 * Just a test routine to test wether specific_worm_collision might work properly
  DEBUG_WORMLET 
 * Reverts default settings
 
 * Launches the wormlet game
  Turn off backlight timeout  start the game  Turn on backlight timeout (revert to settings) *
 * Main entry point
  If the loading failed, save a new config file (as the disk is
           already spinning)  Setup screen **************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * Copyright (C) 2002 Philipp Pertermann
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 *************************************************************************** size of the field the worm lives in  when the game starts  num of pixel the worm grows per eaten food  num of worms creeping in the FIELD  minimal distance between a worm and an argh
   when a new argh is made *
 * All the properties that a worm has.
  The worm is stored in a ring of xy coordinates  index of the head within the buffer  index of the tail within the buffer  number of cyles the worm still keeps growing  the worms living state  direction vector in which the worm moves  only values -1 0 1 allowed  only values -1 0 1 allowed  this method is used to fetch the direction the user
       has selected. It can be one of the values
       human_player1, human_player2, remote_player, virtual_player.
       All these values are fuctions, that can change the direction
       of the worm  stores the highscore - besides it was scored by a virtual player  maximal number of food items  The arrays store the food coordinates   maximal number of argh items  number of arghs produced per eaten food  The arrays store the argh coordinates  the number of arghs that are currently in use  the number of arghs per food, settable by user  the size of the argh, settable by user  the size of the food, settable by user  the speed of the worm, settable by user  the amount a worm grows by eating a food, settable by user  End additional variables  the number of active worms (dead or alive)  in multiplayer mode: en- / disables the remote worm control
   in singleplayer mode: toggles 4 / 2 button worm control  return values of check_collision  constants for use as directions.
   Note that the values are ordered clockwise.
   Thus increasing / decreasing the values
   is equivalent to right / left turns.  direction of human player 1  direction of human player 2  direction of human player 3  the number of (human) players that currently
   control a worm *
 * Returns the direction id in which the worm
 * currently is creeping.
 * @param struct worm *w The worm that is to be investigated.
 *        w Must not be null.
 * @return int A value 0 <= value < 4
 *         Note the predefined constants NORTH, SOUTH, EAST, WEST
 *
 * Set the direction of the specified worm with a direction id.
 * Increasing the value by 1 means to turn the worm direction
 * to right by 90 degree.
 * @param struct worm *w The worm that is to be altered. w Must not be null.
 * @param int dir The new direction in which the worm is to creep.
 *        dir must be  0 <= dir < 4. Use predefined constants
 *        NORTH, SOUTH, EAST, WEST
 *
 * Returns the current length of the worm array. This
 * is also a value for the number of bends that are in the worm.
 * @return int a positive value with 0 <= value < MAX_WORM_SEGMENTS
  initial simple calculation will be overwritten if wrong.  if the worm 'crosses' the boundaries of the ringbuffer *
 * Returns the score the specified worm. The score is the length
 * of the worm.
 * @param struct worm *w The worm that is to be investigated.
 *        w must not be null.
 * @return int The length of the worm (>= 0).
  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Determines wether the line specified by startx, starty, endx, endy intersects
 * the rectangle specified by x, y, width, height. Note that the line must be exactly
 * horizontal or vertical (startx == endx or starty == endy).
 * @param int startx The x coordinate of the start point of the line.
 * @param int starty The y coordinate of the start point of the line.
 * @param int endx The x coordinate of the end point of the line.
 * @param int endy The y coordinate of the end point of the line.
 * @param int x The x coordinate of the top left corner of the rectangle.
 * @param int y The y coordinate of the top left corner of the rectangle.
 * @param int width The width of the rectangle.
 * @param int height The height of the rectangle.
 * @return bool Returns true if the specified line intersects with the recangle.
 *
 * Tests wether the specified worm intersects with the rect.
 * @param struct worm *w The worm to be investigated
 * @param int x The x coordinate of the top left corner of the rect
 * @param int y The y coordinate of the top left corner of the rect
 * @param int widht The width of the rect
 * @param int height The height of the rect
 * @return bool Returns true if the worm intersects with the rect
  get_worm_array_length is expensive -> buffer the value  test each entry that is part of the worm  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Checks wether a specific food in the food arrays is at the
 * specified coordinates.
 * @param int foodIndex The index of the food in the food arrays
 * @param int x the x coordinate.
 * @param int y the y coordinate.
 * @return Returns true if the coordinate hits the food specified by
 * foodIndex.
 *
 * Returns the index of the food that is at the
 * given coordinates. If no food is at the coordinates
 * -1 is returned.
 * @return int  -1 <= value < MAX_FOOD
 *
 * Checks wether a specific argh in the argh arrays is at the
 * specified coordinates.
 * @param int arghIndex The index of the argh in the argh arrays
 * @param int x the x coordinate.
 * @param int y the y coordinate.
 * @return Returns true if the coordinate hits the argh specified by
 * arghIndex.
 *
 * Returns the index of the argh that is at the
 * given coordinates. If no argh is at the coordinates
 * -1 is returned.
 * @param int x The x coordinate.
 * @param int y The y coordinate.
 * @return int  -1 <= value < argh_count <= MAX_ARGH
  search for the argh that has the specified coords *
 * Checks wether the worm collides with the food at the specfied food-arrays.
 * @param int foodIndex The index of the food in the arrays. Ensure the value is
 * 0 <= foodIndex <= MAX_FOOD
 * @return Returns true if the worm collides with the specified food.
 *
 * Returns true if the worm hits the argh within the next moves (unless
 * the worm changes it's direction).
 * @param struct worm *w - The worm to investigate
 * @param int argh_idx - The index of the argh
 * @param int moves - The number of moves that are considered.
 * @return Returns false if the specified argh is not hit within the next
 *         moves.
 *
 * Checks wether the worm collides with the argh at the specfied argh-arrays.
 * @param int arghIndex The index of the argh in the arrays.
 * Ensure the value is 0 <= arghIndex < argh_count <= MAX_ARGH
 * @return Returns true if the worm collides with the specified argh.
 *
 * Find new coordinates for the food stored in foodx[index], foody[index]
 * that don't collide with any other food or argh
 * @param int index
 * Ensure that 0 <= index < MAX_FOOD.
  make coordinates for a new food so that
           the entire food lies within the FIELD  Ensure that the new food doesn't collide with any
           existing foods or arghs.
           If the new food hit any existing
           argh or food a collision is detected.
         use coordinates for further testing  now test wether we accidently hit the worm with food ;) *
 * Clears a food from the lcd buffer.
 * @param int index The index of the food arrays under which
 * the coordinates of the desired food can be found. Ensure
 * that the value is 0 <= index <= MAX_FOOD.
  remove the old food from the screen *
 * Draws a food in the lcd buffer.
 * @param int index The index of the food arrays under which
 * the coordinates of the desired food can be found. Ensure
 * that the value is 0 <= index <= MAX_FOOD.
  draw the food object *
 * Find new coordinates for the argh stored in arghx[index], arghy[index]
 * that don't collide with any other food or argh.
 * @param int index
 * Ensure that 0 <= index < argh_count < MAX_ARGH.
  make coordinates for a new argh so that
           the entire food lies within the FIELD  Ensure that the new argh doesn't intersect with any
           existing foods or arghs.
           If the new argh hit any existing
           argh or food an intersection is detected.
         use the candidate coordinates to make a real argh  now test wether we accidently hit the worm with argh ;) *
 * Draws an argh in the lcd buffer.
 * @param int index The index of the argh arrays under which
 * the coordinates of the desired argh can be found. Ensure
 * that the value is 0 <= index < argh_count <= MAX_ARGH.
  draw the new argh *
 * Initialzes the specified worm with INITIAL_WORM_LENGTH
 * and the tail at the specified position. The worm will
 * be initialized alive and creeping EAST.
 * @param struct worm *w The worm that is to be initialized
 * @param int x The x coordinate at which the tail of the worm starts.
 *        x must be 0 <= x < FIELD_RECT_WIDTH.
 * @param int y The y coordinate at which the tail of the worm starts
 *        y must be 0 <= y < FIELD_RECT_WIDTH.
  initialize the worm size  set the initial direction the worm creeps to *
 * Writes the direction that was stored for
 * human player 1 into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player1_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Writes the direction that was stored for
 * human player 2 into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player2_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Writes the direction that was stored for
 * human player using a remote control
 * into the specified worm. This function
 * may be used to be stored in worm.fetch_worm_direction.
 * The value of
 * the direction is read from player3_dir.
 * @param struct worm *w - The worm of which the direction
 * is altered.
 *
 * Initializes the worm-, food- and argh-arrays, draws a frame,
 * makes some food and argh and display all that stuff.
  Initialize all the worm coordinates to center.  Needed when the game is restarted using BTN_STOPRESET  make and display some food and argh  draw the game field  make everything visible *
 * Move the worm one step further if it is alive.
 * The direction in which the worm moves is taken from dirx and diry.
 * move_worm decreases growing if > 0. While the worm is growing the tail
 * is left untouched.
 * @param struct worm *w The worm to move. w must not be NULL.
  determine the head point and its precessor  determine the old direction  olddir == dir?
           a change of direction means a new segment
           has been opened  new head position  while the worm is growing no tail procession is necessary  update the worms grow state  if the worm isn't growing the tail has to be dragged  index of the end of the tail segment  drag the end of the tail  only one coordinate has to be altered. Here it is
               determined which one  specifies wether the coord has to be in- or decreased  when the tail has been dragged so far that it meets
               the next segment start the tail segment is obsolete and
               must be freed  drop the last tail point *
 * Draws the head and clears the tail of the worm in
 * the display buffer. lcd_update() is NOT called thus
 * the caller has to take care that the buffer is displayed.
  draw the new head  clear the space behind the worm *
 * Checks wether the coordinate is part of the worm. Returns
 * true if any part of the worm was hit - including the head.
 * @param x int The x coordinate
 * @param y int The y coordinate
 * @return int The index of the worm arrays that contain x, y.
 * Returns -1 if the coordinates are not part of the worm.
  get_worm_array_length is expensive -> buffer the value  test each entry that is part of the worm  The iteration iterates the length of the worm.
           Here's the conversion to the true indices within the worm arrays. *
 * Increases the length of the specified worm by marking
 * that it may grow by len pixels. Note that the worm has
 * to move to make the growing happen.
 * @param worm *w The worm that is to be altered.
 * @param int len A positive value specifying the amount of
 * pixels the worm may grow.
 *
 * Determins the worm that is at the coordinates x, y. The parameter
 * w is a switch parameter that changes the functionality of worm_collision.
 * If w is specified and x,y hits the head of w NULL is returned.
 * This is a useful way to determine wether the head of w hits
 * any worm but including itself but excluding its own head.
 * (It hits always its own head ;))
 * If w is set to NULL worm_collision returns any worm including all heads
 * that is at position of x,y.
 * @param struct worm *w The worm of which the head should be excluded in
 * the test. w may be set to NULL.
 * @param int x The x coordinate that is checked
 * @param int y The y coordinate that is checkec
 * @return struct worm*  The worm that has been hit by x,y. If no worm
 * was at the position NULL is returned.
 *
 * Returns true if the head of the worm just has
 * crossed the field boundaries.
 * @return bool true if the worm just has wrapped.
 *
 * Returns true if the specified coordinates are within the
 * field specified by the FIELD_RECT_XXX constants.
 * @param int x The x coordinate of the point that is investigated
 * @param int y The y coordinate of the point that is investigated
 * @return bool Returns false if x,y specifies a point outside the
 * field of worms.
 *
 * Checks and returns wether the head of the w
 * is colliding with something currently.
 * @return int One of the values:
 *   COLLISION_NONE
 *   COLLISION_w
 *   COLLISION_FOOD
 *   COLLISION_ARGH
 *   COLLISION_FIELD
 *
 * Returns the index of the food that is closest to the point
 * specified by x, y. This index may be used in the foodx and
 * foody arrays.
 * @param int x The x coordinate of the point
 * @param int y The y coordinate of the point
 * @return int A value usable as index in foodx and foody.
 *
 * Returns wether the specified position is next to the worm
 * and in the direction the worm looks. Use this method to
 * test wether this position would be hit with the next move of
 * the worm unless the worm changes its direction.
 * @param struct worm *w - The worm to be investigated
 * @param int x - The x coordinate of the position to test.
 * @param int y - The y coordinate of the position to test.
 * @return Returns true if the worm will hit the position unless
 * it change its direction before the next move.
 *
 * Returns true if the worm will collide with the next move unless
 * it changes its direction.
 * @param struct worm *w - The worm to be investigated.
 * @return Returns true if the worm will collide with the next move
 * unless it changes its direction.
 *
 * This function
 * may be used to be stored in worm.fetch_worm_direction for
 * worms that are not controlled by humans but by artificial stupidity.
 * A direction is searched that doesn't lead to collision but to the nearest
 * food - but not very intelligent. The direction is written to the specified
 * worm.
 * @param struct worm *w - The worm of which the direction
 * is altered.
  find the next lunch  determine in which direction it is  in front of me?  left right of me?  detect situation, set strategy  test for collision  plan b  test for collision  plan c *
 * prints out the score board with all the status information
 * about the game.
  high score  worm state  length *
 * Checks for collisions of the worm and its environment and
 * takes appropriate actions like growing the worm or killing it.
 * @return bool Returns true if the worm is dead. Returns
 * false if the worm is healthy, up and creeping.
  check if food was eaten  check if argh was eaten *
 * The main loop of the game.
 * @return bool Returns true if the game ended
 * with a dead worm. Returns false if the user
 * aborted the game manually.
  ticks are counted to compensate speed variations  initialize the board and so on  change the direction of the worm  restart game  back to menu  here the wormlet game cycle ends
               thus the current tick is stored
               as end time  The duration of the game cycle  adjust the number of ticks to wait for a button.
           This ensures that a complete game cycle including
           user input runs in constant time  back to menu *
 * Just a test routine that checks that worm_food_collision works
 * in some typical situations.
  Test 1  test 2  test 3  test 4  test 5  test 6  test 7  test 8  test 9  test 10  test 11  test 12  test 13  test 14 *
 * Just a test routine to test wether specific_worm_collision might work properly
  DEBUG_WORMLET 
 * Reverts default settings
 
 * Launches the wormlet game
  Turn off backlight timeout  start the game  Turn on backlight timeout (revert to settings) *
 * Main entry point
  If the loading failed, save a new config file (as the disk is
           already spinning)  Setup screen 