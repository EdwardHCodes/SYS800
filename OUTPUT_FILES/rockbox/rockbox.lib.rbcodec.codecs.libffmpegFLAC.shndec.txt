
 * Shorten decoder
 * Copyright (c) 2005 Jeff Muizelaar
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * @file shorten.c
 * Shorten decoder
 * @author Jeff Muizelaar
 *
  signed 16 bit shorts: high-low  signed 16 bit shorts: low-high  converts fourcc string to int assert( strlen(s)==4 );
    for (i = 0; i < n; i++)
        samples[i] =<< shift;
 d0 = loop counter  main loop (unroll by 4)  any loops left?  remaining loops  exit  Wrapped samples don't get bitshifted, so we'll do them during
       the next iteration.  Also, when we have to remember to fix the wrapped samples when
       the bitshift changes. this is a hack as version 0 differed in defintion of
                   get_sr_golomb_shorten  Wrap the samples for the next loop  Scale the samples for the pcmbuf s->bit_rate = 8*get_le32(&hb); shorten signature  get blocksize if version > 0 
 * Shorten decoder
 * Copyright (c) 2005 Jeff Muizelaar
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * @file shorten.c
 * Shorten decoder
 * @author Jeff Muizelaar
 *
  signed 16 bit shorts: high-low  signed 16 bit shorts: low-high  converts fourcc string to int assert( strlen(s)==4 );
    for (i = 0; i < n; i++)
        samples[i] =<< shift;
 d0 = loop counter  main loop (unroll by 4)  any loops left?  remaining loops  exit  Wrapped samples don't get bitshifted, so we'll do them during
       the next iteration.  Also, when we have to remember to fix the wrapped samples when
       the bitshift changes. this is a hack as version 0 differed in defintion of
                   get_sr_golomb_shorten  Wrap the samples for the next loop  Scale the samples for the pcmbuf s->bit_rate = 8*get_le32(&hb); shorten signature  get blocksize if version > 0 
 * Shorten decoder
 * Copyright (c) 2005 Jeff Muizelaar
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * @file shorten.c
 * Shorten decoder
 * @author Jeff Muizelaar
 *
  signed 16 bit shorts: high-low  signed 16 bit shorts: low-high  converts fourcc string to int assert( strlen(s)==4 );
    for (i = 0; i < n; i++)
        samples[i] =<< shift;
 d0 = loop counter  main loop (unroll by 4)  any loops left?  remaining loops  exit  Wrapped samples don't get bitshifted, so we'll do them during
       the next iteration.  Also, when we have to remember to fix the wrapped samples when
       the bitshift changes. this is a hack as version 0 differed in defintion of
                   get_sr_golomb_shorten  Wrap the samples for the next loop  Scale the samples for the pcmbuf s->bit_rate = 8*get_le32(&hb); shorten signature  get blocksize if version > 0 