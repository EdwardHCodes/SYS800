
 * group.c: a Latin-square puzzle, but played with groups' Cayley
 * tables. That is, you are given a Cayley table of a group with
 * most elements blank and a few clues, and you must fill it in
 * so as to preserve the group axioms.
 *
 * This is a perfectly playable and fully working puzzle, but I'm
 * leaving it for the moment in the 'unfinished' directory because
 * it's just too esoteric (not to mention _hard_) for me to be
 * comfortable presenting it to the general public as something they
 * might (implicitly) actually want to play.
 *
 * TODO:
 *
 *  - more solver techniques?
 *     * Inverses: once we know that gh = e, we can immediately
 * 	 deduce hg = e as well; then for any gx=y we can deduce
 * 	 hy=x, and for any xg=y we have yh=x.
 *     * Hard-mode associativity: we currently deduce based on
 * 	 definite numbers in the grid, but we could also winnow
 * 	 based on _possible_ numbers.
 *     * My overambitious original thoughts included wondering if we
 * 	 could infer that there must be elements of certain orders
 * 	 (e.g. a group of order divisible by 5 must contain an
 * 	 element of order 5), but I think in fact this is probably
 * 	 silly.
 
 * Difficulty levels. I do some macro ickery here to ensure that my
 * enum and the various forms of my name list always match up.
 
 * In identity mode, we number the elements e,a,b,c,d,f,g,h,...
 * Otherwise, they're a,b,c,d,e,f,g,h,... in the obvious way.
  bitmaps using bits 1<<1..1<<n  sequence of group elements shown 
     * This array indicates thick lines separating rows and columns
     * placed and unplaced manually by the user as a visual aid, e.g.
     * to delineate a subgroup and its cosets.
     *
     * When a line is placed, it's deemed to be between the two
     * particular group elements that are on either side of it at the
     * time; dragging those two away from each other automatically
     * gets rid of the line. Hence, for a given element i, dividers[i]
     * is either -1 (indicating no divider to the right of i), or some
     * other element (indicating a divider to the right of i iff that
     * element is the one right of it). These are eagerly cleared
     * during drags.
      thick lines between rows/cols  structure copy  structure copy  ...which is invalid  unrecognised character 
	 * We can't have a Trivial-difficulty puzzle (i.e. latin
	 * square deductions only) without a clear identity, because
	 * identityless puzzles always have two rows and two columns
	 * entirely blank, and no latin-square deduction permits the
	 * distinguishing of two such rows.
	 
	 * We can't have a 3x3 puzzle without an identity either,
	 * because 3x3 puzzles can't ever be harder than Trivial
	 * (there are no 3x3 latin squares which aren't also valid
	 * group tables, so enabling group-based deductions doesn't
	 * rule out any possible solutions) and - as above - Trivial
	 * puzzles can't not have an identity.
	  ----------------------------------------------------------------------
 * Solver.
 
     * Deduce using associativity: (ab)c = a(bc).
     *
     * So we pick any a,b,c we like; then if we know ab, bc, and
     * (ab)c we can fill in a(bc).
     
     * Fill in the row and column for the group identity, if it's not
     * already known and if we've just found out what it is.
     
     * In identity-hidden mode, systematically rule out possibilities
     * for the group identity.
     *
     * In solver_normal, we used the fact that any filled square in
     * the grid whose contents _does_ match one of the elements it's
     * the product of - that is, ab=a or ab=b - tells you immediately
     * that the other element is the identity.
     *
     * Here, we use the flip side of that: any filled square in the
     * grid whose contents does _not_ match either its row or column -
     * that is, if ab is neither a nor b - tells you immediately that
     * _neither_ of those elements is the identity. And if that's
     * true, then we can also immediately rule out the possibility
     * that it acts as the identity on any element at all.
      Now rule out ij=j or ji=j for all j.  ----------------------------------------------------------------------
 * Grid generation.
 
		 * If there's a number in the very top left or
		 * bottom right, there's no point putting an
		 * unnecessary _ before or after it.
		  ----- data generated by group.gap begins -----  order 2  order 3  order 4  order 5  order 6  order 7  order 8  order 9  order 10  order 11  order 12  order 13  order 14  order 15  order 16  order 17  order 18  order 19  order 20  order 21  order 22  order 23  order 24  order 25  order 26  trivial case: 0  trivial case: 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  ----- data generated by group.gap ends ----- 
     * Difficulty exceptions: some combinations of size and
     * difficulty cannot be satisfied, because all puzzles of at
     * most that difficulty are actually even easier.
     *
     * Remember to re-test this whenever a change is made to the
     * solver logic!
     *
     * I tested it using the following shell command:

for d in t n h x u; do
  for id in '' i; do
    for i in {3..9}; do
      echo -n "./group --generate 1 ${i}d${d}${id}: "
      perl -e 'alarm 30; exec @ARGV' \
        ./group --generate 1 ${i}d${d}${id} >/dev/null && echo ok
    done
  done
done

     * Of course, it's better to do that after taking the exceptions
     * _out_, so as to detect exceptions that should be removed as
     * well as those which should be added.
     
	 * Construct a valid group table, by picking a group from
	 * the above data table, decompressing it into a full
	 * representation by BFS, and then randomly permuting its
	 * non-identity elements.
	 *
	 * We build the canonical table in 'soln' (and use 'grid' as
	 * our BFS queue), then transfer the table into 'grid'
	 * having shuffled the rows.
	 
		 * Apply each group generator to row, constructing a
		 * new row.
		  which row is it?  not done yet  That's got the canonical table. Now shuffle it.  do we shuffle in the identity? 
	 * Remove entries one by one while the puzzle is still
	 * soluble at the appropriate difficulty level.
	 
	     * Start by blanking the entire identity row and column,
	     * and also another row and column so that the player
	     * can't trivially determine which element is the
	     * identity.
	      pick a second row/col to blank  go round again if that didn't work 
	 * Make sure the puzzle isn't too easy.
	  go round and try again 
	 * Done.
	 
     * Encode the puzzle description.
     
     * Encode the solution.
      ----------------------------------------------------------------------
 * Gameplay.
  do nothing  do nothing  structure copy  structure copy  leave room for terminating NUL 
     * These are the coordinates of the primary highlighted square on
     * the grid, if hshow = 1.
     
     * These are the coordinates hx,hy _before_ they go through
     * state->sequence.
     
     * These variables give the length and displacement of a diagonal
     * sequence of highlighted squares starting at ohx,ohy (still if
     * hshow = 1). To find the squares' real coordinates, for 0<=i<dn,
     * compute ohx+i*odx and ohy+i*ody and then map through
     * state->sequence.
     
     * This indicates whether the current highlight is a
     * pencil-mark one or a real one.
     
     * This indicates whether or not we're showing the highlight
     * (used to be hx = hy = -1); important so that when we're
     * using the cursor keys it doesn't keep coming back at a
     * fixed position. When hshow = 1, pressing a valid number
     * or letter key or Space will enter that number or letter in the grid.
     
     * This indicates whether we're using the highlight as a cursor;
     * it means that it doesn't vanish on a keypress, and that it is
     * allowed on immutable squares.
     
     * This indicates whether we're dragging a table header to
     * reposition an entire row or column.
      0=none 1=row 2=col  element being dragged  its current position 
     * We prevent pencil-mode highlighting of a filled square, unless
     * we're using the cursor keys. So if the user has just filled in
     * a square which we had a pencil-mode highlight in (by Undo, or
     * by Redo, or by Solve), then we cancel the highlight.
     
         * Reordering of rows or columns within the range of a
         * multifill selection cancels the multifill and deselects
         * everything.
         
         * Otherwise, reordering of the row or column containing the
         * selection causes the selection to move with it.
         
     * To verify that we have a valid group table, it suffices to
     * test latin-square-hood and associativity only. All the other
     * group axioms follow from those two.
     *
     * Proof:
     *
     * Associativity is given; closure is obvious from latin-
     * square-hood. We need to show that an identity exists and that
     * every element has an inverse.
     *
     * Identity: take any element a. There will be some element e
     * such that ea=a (in a latin square, every element occurs in
     * every row and column, so a must occur somewhere in the a
     * column, say on row e). For any other element b, there must
     * exist x such that ax=b (same argument from latin-square-hood
     * again), and then associativity gives us eb = e(ax) = (ea)x =
     * ax = b. Hence eb=b for all b, i.e. e is a left-identity. A
     * similar argument tells us that there must be some f which is
     * a right-identity, and then we show they are the same element
     * by observing that ef must simultaneously equal e and equal f.
     *
     * Inverses: given any a, by the latin-square argument again,
     * there must exist p and q such that pa=e and aq=e (i.e. left-
     * and right-inverses). We can show these are equal by
     * associativity: p = pe = p(aq) = (pa)q = eq = q. []
     
			 * If the appropriate error slot is already
			 * used for one of the squares, we don't
			 * fill either of them.
			  some movement has happened  end drag  drag was a no-op overall  end 'drag'  no-op 
                 * Pencil-mode highlighting for non filled squares.
                 
             * Can't make pencil marks in a filled square. This can only
             * become highlighted if we're using cursor keys.
             
             * Can't do anything to an immutable square. Exception:
             * trying to set it to what it already was is OK (so that
             * multifilling can set a whole diagonal to a without
             * having to detour round the one immutable square in the
             * middle that already said a).
              OK even if it is immutable 
	 * Fill in absolutely all pencil marks everywhere. (I
	 * wouldn't use this for actual play, but it's a handy
	 * starting point when following through a set of
	 * diagnostics output by the standalone solver.)
	 
	 * Reorder the rows and columns so that digit x is in position
	 * y.
	 
         * Eliminate any obsoleted dividers.
          couldn't parse move string  ----------------------------------------------------------------------
 * Drawing routines.
  Ick: fake up `ds->tilesize' for macro expansion purposes  structure copy  , a = w*w  background needs erasing  dividers  pencil-mode highlight  new number needs drawing?  Count the pencil marks required. 
	     * Determine the bounding rectangle within which we're going
	     * to put the pencil marks.
	      Start with the whole square 
	     * We arrange our pencil marks in a grid layout, with
	     * the number of rows and columns adjusted to allow the
	     * maximum font size.
	     *
	     * So now we work out what the grid size ought to be.
	      Minimum 
	     * Now we've got our grid dimensions, work out the pixel
	     * size of a grid element, and round it to the nearest
	     * pixel. (We don't want rounding errors to make the
	     * grid look uneven at low pixel sizes.)
	     
	     * Centre the resulting figure in the square.
	     
	     * Now actually draw the pencil marks.
	     , a = w*w 
	 * The initial contents of the window are not guaranteed and
	 * can vary with front ends. To be on the safe side, all
	 * games should start by drawing a big background-colour
	 * rectangle covering the whole window.
	 
	 * Big containing rectangle.
	 
     * Construct a modified version of state->sequence which takes
     * into account an unfinished drag operation.
     
     * Draw the table legend.
     
                     * When a diagonal multifill selection is shown,
                     * we show it in its original grid position
                     * regardless of in-progress row/col drags. Moving
                     * every square about would be horrible.
                     
                     * For a single square, we move its highlight
                     * around with the drag.
                      completion flash 
     * We use 9mm squares by default, like Solo.
      Ick: fake up `ds->tilesize' for macro expansion purposes 
     * Border.
     
     * Legend on table.
     
     * Main grid.
     
     * Numbers.
      game_request_keys  wants_statusbar  flags 
     * When solving a Normal puzzle, we don't want to bother the
     * user with Hard-level deductions. For this reason, we grade
     * the puzzle internally before doing anything else.
      placate optimiser  vim: set shiftwidth=4 tabstop=8: 
 * group.c: a Latin-square puzzle, but played with groups' Cayley
 * tables. That is, you are given a Cayley table of a group with
 * most elements blank and a few clues, and you must fill it in
 * so as to preserve the group axioms.
 *
 * This is a perfectly playable and fully working puzzle, but I'm
 * leaving it for the moment in the 'unfinished' directory because
 * it's just too esoteric (not to mention _hard_) for me to be
 * comfortable presenting it to the general public as something they
 * might (implicitly) actually want to play.
 *
 * TODO:
 *
 *  - more solver techniques?
 *     * Inverses: once we know that gh = e, we can immediately
 * 	 deduce hg = e as well; then for any gx=y we can deduce
 * 	 hy=x, and for any xg=y we have yh=x.
 *     * Hard-mode associativity: we currently deduce based on
 * 	 definite numbers in the grid, but we could also winnow
 * 	 based on _possible_ numbers.
 *     * My overambitious original thoughts included wondering if we
 * 	 could infer that there must be elements of certain orders
 * 	 (e.g. a group of order divisible by 5 must contain an
 * 	 element of order 5), but I think in fact this is probably
 * 	 silly.
 
 * Difficulty levels. I do some macro ickery here to ensure that my
 * enum and the various forms of my name list always match up.
 
 * In identity mode, we number the elements e,a,b,c,d,f,g,h,...
 * Otherwise, they're a,b,c,d,e,f,g,h,... in the obvious way.
  bitmaps using bits 1<<1..1<<n  sequence of group elements shown 
     * This array indicates thick lines separating rows and columns
     * placed and unplaced manually by the user as a visual aid, e.g.
     * to delineate a subgroup and its cosets.
     *
     * When a line is placed, it's deemed to be between the two
     * particular group elements that are on either side of it at the
     * time; dragging those two away from each other automatically
     * gets rid of the line. Hence, for a given element i, dividers[i]
     * is either -1 (indicating no divider to the right of i), or some
     * other element (indicating a divider to the right of i iff that
     * element is the one right of it). These are eagerly cleared
     * during drags.
      thick lines between rows/cols  structure copy  structure copy  ...which is invalid  unrecognised character 
	 * We can't have a Trivial-difficulty puzzle (i.e. latin
	 * square deductions only) without a clear identity, because
	 * identityless puzzles always have two rows and two columns
	 * entirely blank, and no latin-square deduction permits the
	 * distinguishing of two such rows.
	 
	 * We can't have a 3x3 puzzle without an identity either,
	 * because 3x3 puzzles can't ever be harder than Trivial
	 * (there are no 3x3 latin squares which aren't also valid
	 * group tables, so enabling group-based deductions doesn't
	 * rule out any possible solutions) and - as above - Trivial
	 * puzzles can't not have an identity.
	  ----------------------------------------------------------------------
 * Solver.
 
     * Deduce using associativity: (ab)c = a(bc).
     *
     * So we pick any a,b,c we like; then if we know ab, bc, and
     * (ab)c we can fill in a(bc).
     
     * Fill in the row and column for the group identity, if it's not
     * already known and if we've just found out what it is.
     
     * In identity-hidden mode, systematically rule out possibilities
     * for the group identity.
     *
     * In solver_normal, we used the fact that any filled square in
     * the grid whose contents _does_ match one of the elements it's
     * the product of - that is, ab=a or ab=b - tells you immediately
     * that the other element is the identity.
     *
     * Here, we use the flip side of that: any filled square in the
     * grid whose contents does _not_ match either its row or column -
     * that is, if ab is neither a nor b - tells you immediately that
     * _neither_ of those elements is the identity. And if that's
     * true, then we can also immediately rule out the possibility
     * that it acts as the identity on any element at all.
      Now rule out ij=j or ji=j for all j.  ----------------------------------------------------------------------
 * Grid generation.
 
		 * If there's a number in the very top left or
		 * bottom right, there's no point putting an
		 * unnecessary _ before or after it.
		  ----- data generated by group.gap begins -----  order 2  order 3  order 4  order 5  order 6  order 7  order 8  order 9  order 10  order 11  order 12  order 13  order 14  order 15  order 16  order 17  order 18  order 19  order 20  order 21  order 22  order 23  order 24  order 25  order 26  trivial case: 0  trivial case: 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  ----- data generated by group.gap ends ----- 
     * Difficulty exceptions: some combinations of size and
     * difficulty cannot be satisfied, because all puzzles of at
     * most that difficulty are actually even easier.
     *
     * Remember to re-test this whenever a change is made to the
     * solver logic!
     *
     * I tested it using the following shell command:

for d in t n h x u; do
  for id in '' i; do
    for i in {3..9}; do
      echo -n "./group --generate 1 ${i}d${d}${id}: "
      perl -e 'alarm 30; exec @ARGV' \
        ./group --generate 1 ${i}d${d}${id} >/dev/null && echo ok
    done
  done
done

     * Of course, it's better to do that after taking the exceptions
     * _out_, so as to detect exceptions that should be removed as
     * well as those which should be added.
     
	 * Construct a valid group table, by picking a group from
	 * the above data table, decompressing it into a full
	 * representation by BFS, and then randomly permuting its
	 * non-identity elements.
	 *
	 * We build the canonical table in 'soln' (and use 'grid' as
	 * our BFS queue), then transfer the table into 'grid'
	 * having shuffled the rows.
	 
		 * Apply each group generator to row, constructing a
		 * new row.
		  which row is it?  not done yet  That's got the canonical table. Now shuffle it.  do we shuffle in the identity? 
	 * Remove entries one by one while the puzzle is still
	 * soluble at the appropriate difficulty level.
	 
	     * Start by blanking the entire identity row and column,
	     * and also another row and column so that the player
	     * can't trivially determine which element is the
	     * identity.
	      pick a second row/col to blank  go round again if that didn't work 
	 * Make sure the puzzle isn't too easy.
	  go round and try again 
	 * Done.
	 
     * Encode the puzzle description.
     
     * Encode the solution.
      ----------------------------------------------------------------------
 * Gameplay.
  do nothing  do nothing  structure copy  structure copy  leave room for terminating NUL 
     * These are the coordinates of the primary highlighted square on
     * the grid, if hshow = 1.
     
     * These are the coordinates hx,hy _before_ they go through
     * state->sequence.
     
     * These variables give the length and displacement of a diagonal
     * sequence of highlighted squares starting at ohx,ohy (still if
     * hshow = 1). To find the squares' real coordinates, for 0<=i<dn,
     * compute ohx+i*odx and ohy+i*ody and then map through
     * state->sequence.
     
     * This indicates whether the current highlight is a
     * pencil-mark one or a real one.
     
     * This indicates whether or not we're showing the highlight
     * (used to be hx = hy = -1); important so that when we're
     * using the cursor keys it doesn't keep coming back at a
     * fixed position. When hshow = 1, pressing a valid number
     * or letter key or Space will enter that number or letter in the grid.
     
     * This indicates whether we're using the highlight as a cursor;
     * it means that it doesn't vanish on a keypress, and that it is
     * allowed on immutable squares.
     
     * This indicates whether we're dragging a table header to
     * reposition an entire row or column.
      0=none 1=row 2=col  element being dragged  its current position 
     * We prevent pencil-mode highlighting of a filled square, unless
     * we're using the cursor keys. So if the user has just filled in
     * a square which we had a pencil-mode highlight in (by Undo, or
     * by Redo, or by Solve), then we cancel the highlight.
     
         * Reordering of rows or columns within the range of a
         * multifill selection cancels the multifill and deselects
         * everything.
         
         * Otherwise, reordering of the row or column containing the
         * selection causes the selection to move with it.
         
     * To verify that we have a valid group table, it suffices to
     * test latin-square-hood and associativity only. All the other
     * group axioms follow from those two.
     *
     * Proof:
     *
     * Associativity is given; closure is obvious from latin-
     * square-hood. We need to show that an identity exists and that
     * every element has an inverse.
     *
     * Identity: take any element a. There will be some element e
     * such that ea=a (in a latin square, every element occurs in
     * every row and column, so a must occur somewhere in the a
     * column, say on row e). For any other element b, there must
     * exist x such that ax=b (same argument from latin-square-hood
     * again), and then associativity gives us eb = e(ax) = (ea)x =
     * ax = b. Hence eb=b for all b, i.e. e is a left-identity. A
     * similar argument tells us that there must be some f which is
     * a right-identity, and then we show they are the same element
     * by observing that ef must simultaneously equal e and equal f.
     *
     * Inverses: given any a, by the latin-square argument again,
     * there must exist p and q such that pa=e and aq=e (i.e. left-
     * and right-inverses). We can show these are equal by
     * associativity: p = pe = p(aq) = (pa)q = eq = q. []
     
			 * If the appropriate error slot is already
			 * used for one of the squares, we don't
			 * fill either of them.
			  some movement has happened  end drag  drag was a no-op overall  end 'drag'  no-op 
                 * Pencil-mode highlighting for non filled squares.
                 
             * Can't make pencil marks in a filled square. This can only
             * become highlighted if we're using cursor keys.
             
             * Can't do anything to an immutable square. Exception:
             * trying to set it to what it already was is OK (so that
             * multifilling can set a whole diagonal to a without
             * having to detour round the one immutable square in the
             * middle that already said a).
              OK even if it is immutable 
	 * Fill in absolutely all pencil marks everywhere. (I
	 * wouldn't use this for actual play, but it's a handy
	 * starting point when following through a set of
	 * diagnostics output by the standalone solver.)
	 
	 * Reorder the rows and columns so that digit x is in position
	 * y.
	 
         * Eliminate any obsoleted dividers.
          couldn't parse move string  ----------------------------------------------------------------------
 * Drawing routines.
  Ick: fake up `ds->tilesize' for macro expansion purposes  structure copy  , a = w*w  background needs erasing  dividers  pencil-mode highlight  new number needs drawing?  Count the pencil marks required. 
	     * Determine the bounding rectangle within which we're going
	     * to put the pencil marks.
	      Start with the whole square 
	     * We arrange our pencil marks in a grid layout, with
	     * the number of rows and columns adjusted to allow the
	     * maximum font size.
	     *
	     * So now we work out what the grid size ought to be.
	      Minimum 
	     * Now we've got our grid dimensions, work out the pixel
	     * size of a grid element, and round it to the nearest
	     * pixel. (We don't want rounding errors to make the
	     * grid look uneven at low pixel sizes.)
	     
	     * Centre the resulting figure in the square.
	     
	     * Now actually draw the pencil marks.
	     , a = w*w 
	 * The initial contents of the window are not guaranteed and
	 * can vary with front ends. To be on the safe side, all
	 * games should start by drawing a big background-colour
	 * rectangle covering the whole window.
	 
	 * Big containing rectangle.
	 
     * Construct a modified version of state->sequence which takes
     * into account an unfinished drag operation.
     
     * Draw the table legend.
     
                     * When a diagonal multifill selection is shown,
                     * we show it in its original grid position
                     * regardless of in-progress row/col drags. Moving
                     * every square about would be horrible.
                     
                     * For a single square, we move its highlight
                     * around with the drag.
                      completion flash 
     * We use 9mm squares by default, like Solo.
      Ick: fake up `ds->tilesize' for macro expansion purposes 
     * Border.
     
     * Legend on table.
     
     * Main grid.
     
     * Numbers.
      game_request_keys  wants_statusbar  flags 
     * When solving a Normal puzzle, we don't want to bother the
     * user with Hard-level deductions. For this reason, we grade
     * the puzzle internally before doing anything else.
      placate optimiser  vim: set shiftwidth=4 tabstop=8: 
 * group.c: a Latin-square puzzle, but played with groups' Cayley
 * tables. That is, you are given a Cayley table of a group with
 * most elements blank and a few clues, and you must fill it in
 * so as to preserve the group axioms.
 *
 * This is a perfectly playable and fully working puzzle, but I'm
 * leaving it for the moment in the 'unfinished' directory because
 * it's just too esoteric (not to mention _hard_) for me to be
 * comfortable presenting it to the general public as something they
 * might (implicitly) actually want to play.
 *
 * TODO:
 *
 *  - more solver techniques?
 *     * Inverses: once we know that gh = e, we can immediately
 * 	 deduce hg = e as well; then for any gx=y we can deduce
 * 	 hy=x, and for any xg=y we have yh=x.
 *     * Hard-mode associativity: we currently deduce based on
 * 	 definite numbers in the grid, but we could also winnow
 * 	 based on _possible_ numbers.
 *     * My overambitious original thoughts included wondering if we
 * 	 could infer that there must be elements of certain orders
 * 	 (e.g. a group of order divisible by 5 must contain an
 * 	 element of order 5), but I think in fact this is probably
 * 	 silly.
 
 * Difficulty levels. I do some macro ickery here to ensure that my
 * enum and the various forms of my name list always match up.
 
 * In identity mode, we number the elements e,a,b,c,d,f,g,h,...
 * Otherwise, they're a,b,c,d,e,f,g,h,... in the obvious way.
  bitmaps using bits 1<<1..1<<n  sequence of group elements shown 
     * This array indicates thick lines separating rows and columns
     * placed and unplaced manually by the user as a visual aid, e.g.
     * to delineate a subgroup and its cosets.
     *
     * When a line is placed, it's deemed to be between the two
     * particular group elements that are on either side of it at the
     * time; dragging those two away from each other automatically
     * gets rid of the line. Hence, for a given element i, dividers[i]
     * is either -1 (indicating no divider to the right of i), or some
     * other element (indicating a divider to the right of i iff that
     * element is the one right of it). These are eagerly cleared
     * during drags.
      thick lines between rows/cols  structure copy  structure copy  ...which is invalid  unrecognised character 
	 * We can't have a Trivial-difficulty puzzle (i.e. latin
	 * square deductions only) without a clear identity, because
	 * identityless puzzles always have two rows and two columns
	 * entirely blank, and no latin-square deduction permits the
	 * distinguishing of two such rows.
	 
	 * We can't have a 3x3 puzzle without an identity either,
	 * because 3x3 puzzles can't ever be harder than Trivial
	 * (there are no 3x3 latin squares which aren't also valid
	 * group tables, so enabling group-based deductions doesn't
	 * rule out any possible solutions) and - as above - Trivial
	 * puzzles can't not have an identity.
	  ----------------------------------------------------------------------
 * Solver.
 
     * Deduce using associativity: (ab)c = a(bc).
     *
     * So we pick any a,b,c we like; then if we know ab, bc, and
     * (ab)c we can fill in a(bc).
     
     * Fill in the row and column for the group identity, if it's not
     * already known and if we've just found out what it is.
     
     * In identity-hidden mode, systematically rule out possibilities
     * for the group identity.
     *
     * In solver_normal, we used the fact that any filled square in
     * the grid whose contents _does_ match one of the elements it's
     * the product of - that is, ab=a or ab=b - tells you immediately
     * that the other element is the identity.
     *
     * Here, we use the flip side of that: any filled square in the
     * grid whose contents does _not_ match either its row or column -
     * that is, if ab is neither a nor b - tells you immediately that
     * _neither_ of those elements is the identity. And if that's
     * true, then we can also immediately rule out the possibility
     * that it acts as the identity on any element at all.
      Now rule out ij=j or ji=j for all j.  ----------------------------------------------------------------------
 * Grid generation.
 
		 * If there's a number in the very top left or
		 * bottom right, there's no point putting an
		 * unnecessary _ before or after it.
		  ----- data generated by group.gap begins -----  order 2  order 3  order 4  order 5  order 6  order 7  order 8  order 9  order 10  order 11  order 12  order 13  order 14  order 15  order 16  order 17  order 18  order 19  order 20  order 21  order 22  order 23  order 24  order 25  order 26  trivial case: 0  trivial case: 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  ----- data generated by group.gap ends ----- 
     * Difficulty exceptions: some combinations of size and
     * difficulty cannot be satisfied, because all puzzles of at
     * most that difficulty are actually even easier.
     *
     * Remember to re-test this whenever a change is made to the
     * solver logic!
     *
     * I tested it using the following shell command:

for d in t n h x u; do
  for id in '' i; do
    for i in {3..9}; do
      echo -n "./group --generate 1 ${i}d${d}${id}: "
      perl -e 'alarm 30; exec @ARGV' \
        ./group --generate 1 ${i}d${d}${id} >/dev/null && echo ok
    done
  done
done

     * Of course, it's better to do that after taking the exceptions
     * _out_, so as to detect exceptions that should be removed as
     * well as those which should be added.
     
	 * Construct a valid group table, by picking a group from
	 * the above data table, decompressing it into a full
	 * representation by BFS, and then randomly permuting its
	 * non-identity elements.
	 *
	 * We build the canonical table in 'soln' (and use 'grid' as
	 * our BFS queue), then transfer the table into 'grid'
	 * having shuffled the rows.
	 
		 * Apply each group generator to row, constructing a
		 * new row.
		  which row is it?  not done yet  That's got the canonical table. Now shuffle it.  do we shuffle in the identity? 
	 * Remove entries one by one while the puzzle is still
	 * soluble at the appropriate difficulty level.
	 
	     * Start by blanking the entire identity row and column,
	     * and also another row and column so that the player
	     * can't trivially determine which element is the
	     * identity.
	      pick a second row/col to blank  go round again if that didn't work 
	 * Make sure the puzzle isn't too easy.
	  go round and try again 
	 * Done.
	 
     * Encode the puzzle description.
     
     * Encode the solution.
      ----------------------------------------------------------------------
 * Gameplay.
  do nothing  do nothing  structure copy  structure copy  leave room for terminating NUL 
     * These are the coordinates of the primary highlighted square on
     * the grid, if hshow = 1.
     
     * These are the coordinates hx,hy _before_ they go through
     * state->sequence.
     
     * These variables give the length and displacement of a diagonal
     * sequence of highlighted squares starting at ohx,ohy (still if
     * hshow = 1). To find the squares' real coordinates, for 0<=i<dn,
     * compute ohx+i*odx and ohy+i*ody and then map through
     * state->sequence.
     
     * This indicates whether the current highlight is a
     * pencil-mark one or a real one.
     
     * This indicates whether or not we're showing the highlight
     * (used to be hx = hy = -1); important so that when we're
     * using the cursor keys it doesn't keep coming back at a
     * fixed position. When hshow = 1, pressing a valid number
     * or letter key or Space will enter that number or letter in the grid.
     
     * This indicates whether we're using the highlight as a cursor;
     * it means that it doesn't vanish on a keypress, and that it is
     * allowed on immutable squares.
     
     * This indicates whether we're dragging a table header to
     * reposition an entire row or column.
      0=none 1=row 2=col  element being dragged  its current position 
     * We prevent pencil-mode highlighting of a filled square, unless
     * we're using the cursor keys. So if the user has just filled in
     * a square which we had a pencil-mode highlight in (by Undo, or
     * by Redo, or by Solve), then we cancel the highlight.
     
         * Reordering of rows or columns within the range of a
         * multifill selection cancels the multifill and deselects
         * everything.
         
         * Otherwise, reordering of the row or column containing the
         * selection causes the selection to move with it.
         
     * To verify that we have a valid group table, it suffices to
     * test latin-square-hood and associativity only. All the other
     * group axioms follow from those two.
     *
     * Proof:
     *
     * Associativity is given; closure is obvious from latin-
     * square-hood. We need to show that an identity exists and that
     * every element has an inverse.
     *
     * Identity: take any element a. There will be some element e
     * such that ea=a (in a latin square, every element occurs in
     * every row and column, so a must occur somewhere in the a
     * column, say on row e). For any other element b, there must
     * exist x such that ax=b (same argument from latin-square-hood
     * again), and then associativity gives us eb = e(ax) = (ea)x =
     * ax = b. Hence eb=b for all b, i.e. e is a left-identity. A
     * similar argument tells us that there must be some f which is
     * a right-identity, and then we show they are the same element
     * by observing that ef must simultaneously equal e and equal f.
     *
     * Inverses: given any a, by the latin-square argument again,
     * there must exist p and q such that pa=e and aq=e (i.e. left-
     * and right-inverses). We can show these are equal by
     * associativity: p = pe = p(aq) = (pa)q = eq = q. []
     
			 * If the appropriate error slot is already
			 * used for one of the squares, we don't
			 * fill either of them.
			  some movement has happened  end drag  drag was a no-op overall  end 'drag'  no-op 
                 * Pencil-mode highlighting for non filled squares.
                 
             * Can't make pencil marks in a filled square. This can only
             * become highlighted if we're using cursor keys.
             
             * Can't do anything to an immutable square. Exception:
             * trying to set it to what it already was is OK (so that
             * multifilling can set a whole diagonal to a without
             * having to detour round the one immutable square in the
             * middle that already said a).
              OK even if it is immutable 
	 * Fill in absolutely all pencil marks everywhere. (I
	 * wouldn't use this for actual play, but it's a handy
	 * starting point when following through a set of
	 * diagnostics output by the standalone solver.)
	 
	 * Reorder the rows and columns so that digit x is in position
	 * y.
	 
         * Eliminate any obsoleted dividers.
          couldn't parse move string  ----------------------------------------------------------------------
 * Drawing routines.
  Ick: fake up `ds->tilesize' for macro expansion purposes  structure copy  , a = w*w  background needs erasing  dividers  pencil-mode highlight  new number needs drawing?  Count the pencil marks required. 
	     * Determine the bounding rectangle within which we're going
	     * to put the pencil marks.
	      Start with the whole square 
	     * We arrange our pencil marks in a grid layout, with
	     * the number of rows and columns adjusted to allow the
	     * maximum font size.
	     *
	     * So now we work out what the grid size ought to be.
	      Minimum 
	     * Now we've got our grid dimensions, work out the pixel
	     * size of a grid element, and round it to the nearest
	     * pixel. (We don't want rounding errors to make the
	     * grid look uneven at low pixel sizes.)
	     
	     * Centre the resulting figure in the square.
	     
	     * Now actually draw the pencil marks.
	     , a = w*w 
	 * The initial contents of the window are not guaranteed and
	 * can vary with front ends. To be on the safe side, all
	 * games should start by drawing a big background-colour
	 * rectangle covering the whole window.
	 
	 * Big containing rectangle.
	 
     * Construct a modified version of state->sequence which takes
     * into account an unfinished drag operation.
     
     * Draw the table legend.
     
                     * When a diagonal multifill selection is shown,
                     * we show it in its original grid position
                     * regardless of in-progress row/col drags. Moving
                     * every square about would be horrible.
                     
                     * For a single square, we move its highlight
                     * around with the drag.
                      completion flash 
     * We use 9mm squares by default, like Solo.
      Ick: fake up `ds->tilesize' for macro expansion purposes 
     * Border.
     
     * Legend on table.
     
     * Main grid.
     
     * Numbers.
      game_request_keys  wants_statusbar  flags 
     * When solving a Normal puzzle, we don't want to bother the
     * user with Hard-level deductions. For this reason, we grade
     * the puzzle internally before doing anything else.
      placate optimiser  vim: set shiftwidth=4 tabstop=8: 