*****************************************************************************

                               Copyright (c) 2009
                            Infineon Technologies AG
                     Am Campeon 1-12; 81726 Munich, Germany

  For licensing information, see the file 'LICENSE' in the root folder of
  this software module.

*****************************************************************************!
  \defgroup AMAZON_S_MEI Amazon-S MEI Driver Module
  \brief Amazon-S MEI driver module
 !
  \defgroup Internal Compile Parametere
  \ingroup AMAZON_S_MEI
  \brief exported functions for other driver use
 !
  \file amazon_s_mei_bsp.c
  \ingroup AMAZON_S_MEI
  \brief Amazon-S MEI driver file
 #include "ifxmips_atm.h"#define LTQ_RCU_RST                   IFX_RCU_RST_REQ
#define LTQ_RCU_RST_REQ_ARC_JTAG      IFX_RCU_RST_REQ_ARC_JTAG
#define LTQ_RCU_RST_REQ_DFE		  IFX_RCU_RST_REQ_DFE
#define LTQ_RCU_RST_REQ_AFE		  IFX_RCU_RST_REQ_AFE
#define IFXMIPS_FUSE_BASE_ADDR            IFX_FUSE_BASE_ADDR
#define IFXMIPS_ICU_IM0_IER               IFX_ICU_IM0_IER
#define IFXMIPS_ICU_IM2_IER               IFX_ICU_IM2_IER
#define LTQ_MEI_INT                   IFX_MEI_INT
#define LTQ_MEI_DYING_GASP_INT        IFX_MEI_DYING_GASP_INT
#define LTQ_MEI_BASE_ADDR  		  IFX_MEI_SPACE_ACCESS
#define IFXMIPS_PMU_PWDCR		  IFX_PMU_PWDCR
#define IFXMIPS_MPS_CHIPID                IFX_MPS_CHIPID

#define ifxmips_port_reserve_pin 	  ifx_gpio_pin_reserve
#define ifxmips_port_set_dir_in		  ifx_gpio_dir_in_set
#define ifxmips_port_clear_altsel0        ifx_gpio_altsel0_set
#define ifxmips_port_clear_altsel1 	  ifx_gpio_altsel1_clear
#define ifxmips_port_set_open_drain       ifx_gpio_open_drain_clear
#define ifxmips_port_free_pin		  ifx_gpio_pin_free
#define ifxmips_mask_and_ack_irq	  bsp_mask_and_ack_irq
#define IFXMIPS_MPS_CHIPID_VERSION_GET    IFX_MCD_CHIPID_VERSION_GET
#define ltq_r32(reg)                        __raw_readl(reg)
#define ltq_w32(val, reg)                   __raw_writel(val, reg)
#define ltq_w32_mask(clear, set, reg)       ltq_w32((ltq_r32(reg) & ~clear) | set, reg)
#define DFE_MEM_TEST#define DFE_PING_TESTCONFIG_AMAZON_S_MEI_FW_LOOPBACKDSL_DEV_MeiError_t DSL_BSP_AdslLedSet (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedMode_t);  holding swap pages*
 * Write a value to register
 * This function writes a value to danube register
 *
 * \param  	ul_address	The address to write
 * \param  	ul_data		The value to write
 * \ingroup	Internal
 *
 * Write a value to register
 * This function writes a value to danube register
 *
 * \param 	pDev		the device pointer
 * \param  	ul_address	The address to write
 * \param  	ul_data		The value to write
 * \ingroup	Internal
 *
 * Read the danube register
 * This function read the value from danube register
 *
 * \param  	ul_address	The address to write
 * \param  	pul_data	Pointer to the data
 * \ingroup	Internal
 *
 * Read the danube register
 * This function read the value from danube register
 *
 * \param 	pDev		the device pointer
 * \param  	ul_address	The address to write
 * \param  	pul_data	Pointer to the data
 * \ingroup	Internal
 *
 * Write several DWORD datas to ARC memory via ARC DMA interface
 * This function writes several DWORD datas to ARC memory via DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	destaddr	The address to write
 * \param  	databuff	Pointer to the data buffer
 * \param  	databuffsize	Number of DWORDs to write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Set the write transfer address      Write the data pushed across DMA*
 * Read several DWORD datas from ARC memory via ARC DMA interface
 * This function reads several DWORD datas from ARC memory via DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	srcaddr		The address to read
 * \param  	databuff	Pointer to the data buffer
 * \param  	databuffsize	Number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Set the read transfer address      Read the data popped across DMA swap half word*
 * Switch the ARC control mode
 * This function switchs the ARC control mode to JTAG mode or MEI mode
 *
 * \param 	pDev		the device pointer
 * \param  	mode		The mode want to switch: JTAG_MASTER_MODE or MEI_MASTER_MODE.
 * \ingroup	Internal
 *
 * Disable ARC to MEI interrupt
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
 *
 * Eable ARC to MEI interrupt
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
 *
 * Poll for transaction complete signal
 * This function polls and waits for transaction complete signal.
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
  to clear this interrupt*
 * ARC Debug Memory Access for a single DWORD reading.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	DEC_mode	ARC memory space to used
 * \param  	address	  	Address to read
 * \param  	data	  	Pointer to data
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * ARC Debug Memory Access for a single DWORD writing.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	DEC_mode	ARC memory space to used
 * \param  	address	  	The address to write
 * \param  	data	  	The data to write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * ARC Debug Memory Access for writing.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	destaddr	The address to read
 * \param  	databuffer  	Pointer to data
 * \param	databuffsize	The number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Open the debug port before DMP memory write      For the requested length, write the address and write the data      Close the debug port after DMP memory write*
 * ARC Debug Memory Access for reading.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	srcaddr	  	The address to read
 * \param  	databuffer  	Pointer to data
 * \param	databuffsize	The number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Open the debug port before DMP memory read      For the requested length, write the address and read the data      Close the debug port after DMP memory read*
 * Send a message to ARC MailBox.
 * This function sends a message to ARC Mailbox via ARC DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	msgsrcbuffer  	Pointer to message.
 * \param	msgsize		The number of words to write.
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Write to mailbox      Notify arc that mailbox write completed wait for ARC to clear the bit*
 * Read a message from ARC MailBox.
 * This function reads a message from ARC Mailbox via ARC DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	msgsrcbuffer  	Pointer to message.
 * \param	msgsize		The number of words to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Read from mailbox      Notify arc that mailbox read completed*
 * Download boot pages to ARC.
 * This function downloads boot pages to ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 
	 **     DMA the boot code page(s)
	 *
 * Initial efuse rar.
 **
 * efuse rar program
 * 0x4000 translate to  about 16 ms@111M, so should be enough  STEP a: Prepare memory for external accesses Write fuse_en bit24 PPE efuse*
 * Enable DFE Clock
 * This function enables DFE Clock
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 enable ac_clk signal*
 * Halt the ARC.
 * This function halts the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Switch arc control from JTAG mode to MEI mode      Switch arc control from MEI mode to JTAG mode*
 * Run the ARC.
 * This function runs the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Switch arc control from JTAG mode to MEI mode- write '1' to bit0      Write debug data reg with content ANDd with 0xFDFFFFFF (halt bit cleared)      Switch arc control from MEI mode to JTAG mode- write '0' to bit0      Enable mask for arc codeswap interrupts*
 * Reset the ARC.
 * This function resets the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
  reset ARC reset part of PPE*
 * Reset/halt/run the DFE.
 * This function provide operations to reset/halt/run the DFE.
 *
 * \param 	pDev		the device pointer
 * \param	mode		which operation want to do
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Accress DFE memory.
 * This function provide a way to access DFE memory;
 *
 * \param 	pDev		the device pointer
 * \param	type		read or write
 * \param	destaddr	destination address
 * \param	databuff	pointer to hold data
 * \param	databuffsize	size want to read/write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Download boot code to ARC.
 * This function downloads boot code to ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 program fuse rar*
 * Enable Jtag debugger interface
 * This function setups mips gpio to enable jtag debugger
 *
 * \param 	pDev		the device pointer
 * \param 	enable		enable or disable
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 
	int meierr=0;
	u32 reg_data;
	switch (enable) {
	case 1:
                //reserve gpio 9, 10, 11, 14, 19 for ARC JTAG
		ifxmips_port_reserve_pin (0, 9);
		ifxmips_port_reserve_pin (0, 10);
		ifxmips_port_reserve_pin (0, 11);
		ifxmips_port_reserve_pin (0, 14);
		ifxmips_port_reserve_pin (1, 3);

		ifxmips_port_set_dir_in(0, 11);
		ifxmips_port_clear_altsel0(0, 11);
		ifxmips_port_clear_altsel1(0, 11);
		ifxmips_port_set_open_drain(0, 11);
        //enable ARC JTAG
        IFX_MEI_LongWordRead ((u32) LTQ_RCU_RST, &reg_data);
        IFX_MEI_LongWordWrite ((u32) LTQ_RCU_RST, reg_data | LTQ_RCU_RST_REQ_ARC_JTAG);
		break;
	case 0:
	default:
		break;
	}
jtag_end:
	if (meierr)
		return DSL_DEV_MEI_ERR_FAILURE;
*
 * Enable DFE to MIPS interrupt
 * This function enable DFE to MIPS interrupt
 *
 * \param 	pDev		the device pointer
 * \param 	enable		enable or disable
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Get the modem status
 * This function return the modem status
 *
 * \param 	pDev		the device pointer
 * \return	1: modem ready 0: not ready
 * \ingroup	Internal
 DSL_LED_HD_CPU                bsp_led_config (&param);                bsp_led_config (&param); data data*
* Compose a message.
* This function compose a message from opcode, group, address, index, size, and data
*
* \param       opcode          The message opcode
* \param       group           The message group number
* \param       address         The message address.
* \param       index           The message index.
* \param       size            The number of words to read/write.
* \param       data            The pointer to data.
* \param       CMVMSG          The pointer to message buffer.
* \ingroup     Internal
*
 * Send a message to ARC and read the response
 * This function sends a message to arc, waits the response, and reads the responses.
 *
 * \param 	pDev		the device pointer
 * \param	request		Pointer to the request
 * \param	reply		Wait reply or not.
 * \param	response	Pointer to the response
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
  write cmv to arc, if reply needed, wait for replyCMV_timeout*
 * Reset the ARC, download boot codes, and run the ARC.
 * This function resets the ARC, downloads boot codes to ARC, and runs the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 	DSL_DEV_WinHost_Message_t m; check image size TODO: check crc/IFX_MEI_DMSG("Starting to meiDownloadBootCode\n"); Turn off irq  Re-enable irq *
 * Get the page's data pointer
 * This function caculats the data address from the firmware header.
 *
 * \param 	pDev		the device pointer
 * \param	Page		The page number.
 * \param	data		Data page or program page.
 * \param	MaxSize		The maximum size to read.
 * \param	Buffer		Pointer to data.
 * \param	Dest		Pointer to the destination address.
 * \return	The number of bytes to read.
 * \ingroup	Internal
 
	 **     Get program or data size, depending on "data" flag
	       Clear boot bit!
	 **     Get program or data offset, depending on "data" flag
	 
	 **     Copy data/program to buffer
	 
	 **     Pass back data/program destination address
	 *
 * Free the memory for ARC firmware
 *
 * \param 	pDev		the device pointer
 * \param	type	Free all memory or free the unused memory after showtime
 * \ingroup	Internal
 		DSL_DEV_PRIVATE(pDev)->adsl_mem_info; Alloc Swap Pages skip bar15 for XDATA usage. Pointer not 1k aligned, so free it and allocate a larger chunk
			 * for further alignment.
			 *
 * Program the BAR registers
 *
 * \param 	pDev		the device pointer
 * \param	nTotalBar	The number of bar to program.
 * \ingroup	Internal
 skip XDATA register These are for /proc/danube_mei/meminfo purpose  Prevent it from being freed  update MEI_XDATA_BASE_SH This copies the firmware from secondary storage to 64k memory segment in SDRAM  header of image_size and crc are not included. check if arc is haltfree allskip XDATA register Pointer not 1k aligned, so free it and allocate a larger chunk
			 * for further alignment.
			 
 * Register a callback event.
 * Return:
 * -1 if the event already has a callback function registered.
 *  0 success
 *
 * MEI Dying Gasp interrupt handler
 *
 * \param int1
 * \param void0
 * \param regs	Pointer to the structure of danube mips registers
 * \ingroup	Internal
 static irqreturn_t IFX_MEI_Dying_Gasp_IrqHandle (int int1, void *void0)
{
	DSL_DEV_Device_t *pDev = (DSL_DEV_Device_t *) void0;
        DSL_BSP_CB_Type_t event;

	if (pDev == NULL)
		IFX_MEI_EMSG("Error: Got Interrupt but pDev is NULL!!!!\n");

#ifndef CONFIG_SMP
	disable_irq (pDev->nIrq[IFX_DYING_GASP]);
#else
	disable_irq_nosync(pDev->nIrq[IFX_DYING_GASP]);
#endif
	event = DSL_BSP_CB_DYING_GASP;

	if (dsl_bsp_event_callback[event].function)
		(*dsl_bsp_event_callback[event].function)(pDev, event, dsl_bsp_event_callback[event].pData);

#ifdef CONFIG_USE_EMULATOR
    IFX_MEI_EMSG("Dying Gasp! Shutting Down... (Work around for Amazon-S Venus emulator)\n");
#else
	IFX_MEI_EMSG("Dying Gasp! Shutting Down...\n");
//	kill_proc (1, SIGINT, 1);   
#endif
        return IRQ_HANDLED;
}
*
 * MEI interrupt handler
 *
 * \param int1
 * \param void0
 * \param regs	Pointer to the structure of danube mips registers
 * \ingroup	Internal
 CONFIG_AMAZON_S_MEI_FW_LOOPBACK clear eoc message interrupt Reboot normal messagecheck ARC ready message Iridia Registers Address Constants *((volatile u32 *)(addr)) =  data; u32  rd_val;rd_val = *((volatile u32 *)(addr)); return rd_val; This routine writes the mailbox with the data in an input array  This routine reads the output mailbox and places the results into an array  Write address register  Write data register  wait until complete - timeout at 40  clear the flag printk("jt %X %08X %08X\n",i,jump_table[i*2+0],jump_table[i*2+1]);got_int = 1;printk("IFX_MEI_MailboxWrite ret=%d\n",i);schedule();mbox_read(&rd_mbox[0],6); start the clock WriteARCreg(AUX_XMEM_LTEST,0); WriteARCreg(AUX_XDMA_GAP,0);WriteARCreg(AUX_IC_CTRL,2);DFE_PING_TESTdefined( DFE_PING_TEST )|| defined( DFE_ATM_LOOPBACK)DFE_MEM_TESTTIMER_DELAY   - org: 1024TXFB_START0TXFB_END0     - org: 49TXFB_START1   - org: 80TXFB_END1     - org: 109RXFB_START0   - org: 0RXFB_END0     - org: 49RXFB_START1   - org: 256RXFB_END1     - org: 315 Start Iridia IT_AMODE (in dmp access) why is it required?DFE_ATM_LOOPBACKDFE_PING_TESTDFE_MEM_TESTCONFIG_AMAZON_S_MEI_FW_LOOPBACK Power up MEI  enable dsl enable AHB base for ARCMSGAV for arc modem ready semaphore initialization, mutexif (request_irq (pDev->nIrq[IFX_DYING_GASP], IFX_MEI_Dying_Gasp_IrqHandle, 0, "DYING_GASP", pDev) != 0) {
		IFX_MEI_EMSG ("request_irq %d failed!\n", pDev->nIrq[IFX_DYING_GASP]);
		return -1;
	}	IFX_MEI_DMSG("Device %d initialized. IER %#x\n", num, bsp_get_irq_ier(pDev->nIrq[IFX_DYING_GASP]));int maj = MAJOR(ino->i_rdev);*
 * Callback function for linux userspace program writing
 *
 * Callback function for linux userspace program ioctling
 	DSL_DEV_MeiDebug_t debugrdwr;	case DSL_FIO_BSP_DEBUG_READ:
	case DSL_FIO_BSP_DEBUG_WRITE:
		IFX_MEI_IoctlCopyFrom (from_kernel,
					     (char *) (&debugrdwr),
					     (char *) lon,
					     sizeof (debugrdwr));

		if (command == DSL_FIO_BSP_DEBUG_READ)
			meierr = DSL_BSP_MemoryDebugAccess (pDev,
								 DSL_BSP_MEMORY_READ,
								 debugrdwr.
								 iAddress,
								 debugrdwr.
								 buffer,
								 debugrdwr.
								 iCount);
		else
			meierr = DSL_BSP_MemoryDebugAccess (pDev,
								 DSL_BSP_MEMORY_WRITE,
								 debugrdwr.
								 iAddress,
								 debugrdwr.
								 buffer,
								 debugrdwr.
								 iCount);

		IFX_MEI_IoctlCopyTo (from_kernel, (char *) lon, (char *) (&debugrdwr), sizeof (debugrdwr));
		break;		IFX_MEI_EMSG("Invalid IOCTL command: %d\n");
 * Writing function for linux proc filesystem
  export function for DSL Driver  The functions of MEI_DriverHandleGet and MEI_DriverHandleDelete are
something like open/close in kernel space , where the open could be used
to register a callback for autonomous messages and returns a mei driver context pointer (comparable to the file descriptor in user space)
   The context will be required for the multi line chips future! EXPORT_SYMBOL (DSL_BSP_AdslLedSet); provide a register/unregister function for DSL driver to register a event callback function*****************************************************************************

                               Copyright (c) 2009
                            Infineon Technologies AG
                     Am Campeon 1-12; 81726 Munich, Germany

  For licensing information, see the file 'LICENSE' in the root folder of
  this software module.

*****************************************************************************!
  \defgroup AMAZON_S_MEI Amazon-S MEI Driver Module
  \brief Amazon-S MEI driver module
 !
  \defgroup Internal Compile Parametere
  \ingroup AMAZON_S_MEI
  \brief exported functions for other driver use
 !
  \file amazon_s_mei_bsp.c
  \ingroup AMAZON_S_MEI
  \brief Amazon-S MEI driver file
 #include "ifxmips_atm.h"#define LTQ_RCU_RST                   IFX_RCU_RST_REQ
#define LTQ_RCU_RST_REQ_ARC_JTAG      IFX_RCU_RST_REQ_ARC_JTAG
#define LTQ_RCU_RST_REQ_DFE		  IFX_RCU_RST_REQ_DFE
#define LTQ_RCU_RST_REQ_AFE		  IFX_RCU_RST_REQ_AFE
#define IFXMIPS_FUSE_BASE_ADDR            IFX_FUSE_BASE_ADDR
#define IFXMIPS_ICU_IM0_IER               IFX_ICU_IM0_IER
#define IFXMIPS_ICU_IM2_IER               IFX_ICU_IM2_IER
#define LTQ_MEI_INT                   IFX_MEI_INT
#define LTQ_MEI_DYING_GASP_INT        IFX_MEI_DYING_GASP_INT
#define LTQ_MEI_BASE_ADDR  		  IFX_MEI_SPACE_ACCESS
#define IFXMIPS_PMU_PWDCR		  IFX_PMU_PWDCR
#define IFXMIPS_MPS_CHIPID                IFX_MPS_CHIPID

#define ifxmips_port_reserve_pin 	  ifx_gpio_pin_reserve
#define ifxmips_port_set_dir_in		  ifx_gpio_dir_in_set
#define ifxmips_port_clear_altsel0        ifx_gpio_altsel0_set
#define ifxmips_port_clear_altsel1 	  ifx_gpio_altsel1_clear
#define ifxmips_port_set_open_drain       ifx_gpio_open_drain_clear
#define ifxmips_port_free_pin		  ifx_gpio_pin_free
#define ifxmips_mask_and_ack_irq	  bsp_mask_and_ack_irq
#define IFXMIPS_MPS_CHIPID_VERSION_GET    IFX_MCD_CHIPID_VERSION_GET
#define ltq_r32(reg)                        __raw_readl(reg)
#define ltq_w32(val, reg)                   __raw_writel(val, reg)
#define ltq_w32_mask(clear, set, reg)       ltq_w32((ltq_r32(reg) & ~clear) | set, reg)
#define DFE_MEM_TEST#define DFE_PING_TESTCONFIG_AMAZON_S_MEI_FW_LOOPBACKDSL_DEV_MeiError_t DSL_BSP_AdslLedSet (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedMode_t);  holding swap pages*
 * Write a value to register
 * This function writes a value to danube register
 *
 * \param  	ul_address	The address to write
 * \param  	ul_data		The value to write
 * \ingroup	Internal
 *
 * Write a value to register
 * This function writes a value to danube register
 *
 * \param 	pDev		the device pointer
 * \param  	ul_address	The address to write
 * \param  	ul_data		The value to write
 * \ingroup	Internal
 *
 * Read the danube register
 * This function read the value from danube register
 *
 * \param  	ul_address	The address to write
 * \param  	pul_data	Pointer to the data
 * \ingroup	Internal
 *
 * Read the danube register
 * This function read the value from danube register
 *
 * \param 	pDev		the device pointer
 * \param  	ul_address	The address to write
 * \param  	pul_data	Pointer to the data
 * \ingroup	Internal
 *
 * Write several DWORD datas to ARC memory via ARC DMA interface
 * This function writes several DWORD datas to ARC memory via DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	destaddr	The address to write
 * \param  	databuff	Pointer to the data buffer
 * \param  	databuffsize	Number of DWORDs to write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Set the write transfer address      Write the data pushed across DMA*
 * Read several DWORD datas from ARC memory via ARC DMA interface
 * This function reads several DWORD datas from ARC memory via DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	srcaddr		The address to read
 * \param  	databuff	Pointer to the data buffer
 * \param  	databuffsize	Number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Set the read transfer address      Read the data popped across DMA swap half word*
 * Switch the ARC control mode
 * This function switchs the ARC control mode to JTAG mode or MEI mode
 *
 * \param 	pDev		the device pointer
 * \param  	mode		The mode want to switch: JTAG_MASTER_MODE or MEI_MASTER_MODE.
 * \ingroup	Internal
 *
 * Disable ARC to MEI interrupt
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
 *
 * Eable ARC to MEI interrupt
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
 *
 * Poll for transaction complete signal
 * This function polls and waits for transaction complete signal.
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
  to clear this interrupt*
 * ARC Debug Memory Access for a single DWORD reading.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	DEC_mode	ARC memory space to used
 * \param  	address	  	Address to read
 * \param  	data	  	Pointer to data
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * ARC Debug Memory Access for a single DWORD writing.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	DEC_mode	ARC memory space to used
 * \param  	address	  	The address to write
 * \param  	data	  	The data to write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * ARC Debug Memory Access for writing.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	destaddr	The address to read
 * \param  	databuffer  	Pointer to data
 * \param	databuffsize	The number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Open the debug port before DMP memory write      For the requested length, write the address and write the data      Close the debug port after DMP memory write*
 * ARC Debug Memory Access for reading.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	srcaddr	  	The address to read
 * \param  	databuffer  	Pointer to data
 * \param	databuffsize	The number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Open the debug port before DMP memory read      For the requested length, write the address and read the data      Close the debug port after DMP memory read*
 * Send a message to ARC MailBox.
 * This function sends a message to ARC Mailbox via ARC DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	msgsrcbuffer  	Pointer to message.
 * \param	msgsize		The number of words to write.
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Write to mailbox      Notify arc that mailbox write completed wait for ARC to clear the bit*
 * Read a message from ARC MailBox.
 * This function reads a message from ARC Mailbox via ARC DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	msgsrcbuffer  	Pointer to message.
 * \param	msgsize		The number of words to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Read from mailbox      Notify arc that mailbox read completed*
 * Download boot pages to ARC.
 * This function downloads boot pages to ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 
	 **     DMA the boot code page(s)
	 *
 * Initial efuse rar.
 **
 * efuse rar program
 * 0x4000 translate to  about 16 ms@111M, so should be enough  STEP a: Prepare memory for external accesses Write fuse_en bit24 PPE efuse*
 * Enable DFE Clock
 * This function enables DFE Clock
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 enable ac_clk signal*
 * Halt the ARC.
 * This function halts the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Switch arc control from JTAG mode to MEI mode      Switch arc control from MEI mode to JTAG mode*
 * Run the ARC.
 * This function runs the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Switch arc control from JTAG mode to MEI mode- write '1' to bit0      Write debug data reg with content ANDd with 0xFDFFFFFF (halt bit cleared)      Switch arc control from MEI mode to JTAG mode- write '0' to bit0      Enable mask for arc codeswap interrupts*
 * Reset the ARC.
 * This function resets the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
  reset ARC reset part of PPE*
 * Reset/halt/run the DFE.
 * This function provide operations to reset/halt/run the DFE.
 *
 * \param 	pDev		the device pointer
 * \param	mode		which operation want to do
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Accress DFE memory.
 * This function provide a way to access DFE memory;
 *
 * \param 	pDev		the device pointer
 * \param	type		read or write
 * \param	destaddr	destination address
 * \param	databuff	pointer to hold data
 * \param	databuffsize	size want to read/write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Download boot code to ARC.
 * This function downloads boot code to ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 program fuse rar*
 * Enable Jtag debugger interface
 * This function setups mips gpio to enable jtag debugger
 *
 * \param 	pDev		the device pointer
 * \param 	enable		enable or disable
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 
	int meierr=0;
	u32 reg_data;
	switch (enable) {
	case 1:
                //reserve gpio 9, 10, 11, 14, 19 for ARC JTAG
		ifxmips_port_reserve_pin (0, 9);
		ifxmips_port_reserve_pin (0, 10);
		ifxmips_port_reserve_pin (0, 11);
		ifxmips_port_reserve_pin (0, 14);
		ifxmips_port_reserve_pin (1, 3);

		ifxmips_port_set_dir_in(0, 11);
		ifxmips_port_clear_altsel0(0, 11);
		ifxmips_port_clear_altsel1(0, 11);
		ifxmips_port_set_open_drain(0, 11);
        //enable ARC JTAG
        IFX_MEI_LongWordRead ((u32) LTQ_RCU_RST, &reg_data);
        IFX_MEI_LongWordWrite ((u32) LTQ_RCU_RST, reg_data | LTQ_RCU_RST_REQ_ARC_JTAG);
		break;
	case 0:
	default:
		break;
	}
jtag_end:
	if (meierr)
		return DSL_DEV_MEI_ERR_FAILURE;
*
 * Enable DFE to MIPS interrupt
 * This function enable DFE to MIPS interrupt
 *
 * \param 	pDev		the device pointer
 * \param 	enable		enable or disable
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Get the modem status
 * This function return the modem status
 *
 * \param 	pDev		the device pointer
 * \return	1: modem ready 0: not ready
 * \ingroup	Internal
 DSL_LED_HD_CPU                bsp_led_config (&param);                bsp_led_config (&param); data data*
* Compose a message.
* This function compose a message from opcode, group, address, index, size, and data
*
* \param       opcode          The message opcode
* \param       group           The message group number
* \param       address         The message address.
* \param       index           The message index.
* \param       size            The number of words to read/write.
* \param       data            The pointer to data.
* \param       CMVMSG          The pointer to message buffer.
* \ingroup     Internal
*
 * Send a message to ARC and read the response
 * This function sends a message to arc, waits the response, and reads the responses.
 *
 * \param 	pDev		the device pointer
 * \param	request		Pointer to the request
 * \param	reply		Wait reply or not.
 * \param	response	Pointer to the response
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
  write cmv to arc, if reply needed, wait for replyCMV_timeout*
 * Reset the ARC, download boot codes, and run the ARC.
 * This function resets the ARC, downloads boot codes to ARC, and runs the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 	DSL_DEV_WinHost_Message_t m; check image size TODO: check crc/IFX_MEI_DMSG("Starting to meiDownloadBootCode\n"); Turn off irq  Re-enable irq *
 * Get the page's data pointer
 * This function caculats the data address from the firmware header.
 *
 * \param 	pDev		the device pointer
 * \param	Page		The page number.
 * \param	data		Data page or program page.
 * \param	MaxSize		The maximum size to read.
 * \param	Buffer		Pointer to data.
 * \param	Dest		Pointer to the destination address.
 * \return	The number of bytes to read.
 * \ingroup	Internal
 
	 **     Get program or data size, depending on "data" flag
	       Clear boot bit!
	 **     Get program or data offset, depending on "data" flag
	 
	 **     Copy data/program to buffer
	 
	 **     Pass back data/program destination address
	 *
 * Free the memory for ARC firmware
 *
 * \param 	pDev		the device pointer
 * \param	type	Free all memory or free the unused memory after showtime
 * \ingroup	Internal
 		DSL_DEV_PRIVATE(pDev)->adsl_mem_info; Alloc Swap Pages skip bar15 for XDATA usage. Pointer not 1k aligned, so free it and allocate a larger chunk
			 * for further alignment.
			 *
 * Program the BAR registers
 *
 * \param 	pDev		the device pointer
 * \param	nTotalBar	The number of bar to program.
 * \ingroup	Internal
 skip XDATA register These are for /proc/danube_mei/meminfo purpose  Prevent it from being freed  update MEI_XDATA_BASE_SH This copies the firmware from secondary storage to 64k memory segment in SDRAM  header of image_size and crc are not included. check if arc is haltfree allskip XDATA register Pointer not 1k aligned, so free it and allocate a larger chunk
			 * for further alignment.
			 
 * Register a callback event.
 * Return:
 * -1 if the event already has a callback function registered.
 *  0 success
 *
 * MEI Dying Gasp interrupt handler
 *
 * \param int1
 * \param void0
 * \param regs	Pointer to the structure of danube mips registers
 * \ingroup	Internal
 static irqreturn_t IFX_MEI_Dying_Gasp_IrqHandle (int int1, void *void0)
{
	DSL_DEV_Device_t *pDev = (DSL_DEV_Device_t *) void0;
        DSL_BSP_CB_Type_t event;

	if (pDev == NULL)
		IFX_MEI_EMSG("Error: Got Interrupt but pDev is NULL!!!!\n");

#ifndef CONFIG_SMP
	disable_irq (pDev->nIrq[IFX_DYING_GASP]);
#else
	disable_irq_nosync(pDev->nIrq[IFX_DYING_GASP]);
#endif
	event = DSL_BSP_CB_DYING_GASP;

	if (dsl_bsp_event_callback[event].function)
		(*dsl_bsp_event_callback[event].function)(pDev, event, dsl_bsp_event_callback[event].pData);

#ifdef CONFIG_USE_EMULATOR
    IFX_MEI_EMSG("Dying Gasp! Shutting Down... (Work around for Amazon-S Venus emulator)\n");
#else
	IFX_MEI_EMSG("Dying Gasp! Shutting Down...\n");
//	kill_proc (1, SIGINT, 1);   
#endif
        return IRQ_HANDLED;
}
*
 * MEI interrupt handler
 *
 * \param int1
 * \param void0
 * \param regs	Pointer to the structure of danube mips registers
 * \ingroup	Internal
 CONFIG_AMAZON_S_MEI_FW_LOOPBACK clear eoc message interrupt Reboot normal messagecheck ARC ready message Iridia Registers Address Constants *((volatile u32 *)(addr)) =  data; u32  rd_val;rd_val = *((volatile u32 *)(addr)); return rd_val; This routine writes the mailbox with the data in an input array  This routine reads the output mailbox and places the results into an array  Write address register  Write data register  wait until complete - timeout at 40  clear the flag printk("jt %X %08X %08X\n",i,jump_table[i*2+0],jump_table[i*2+1]);got_int = 1;printk("IFX_MEI_MailboxWrite ret=%d\n",i);schedule();mbox_read(&rd_mbox[0],6); start the clock WriteARCreg(AUX_XMEM_LTEST,0); WriteARCreg(AUX_XDMA_GAP,0);WriteARCreg(AUX_IC_CTRL,2);DFE_PING_TESTdefined( DFE_PING_TEST )|| defined( DFE_ATM_LOOPBACK)DFE_MEM_TESTTIMER_DELAY   - org: 1024TXFB_START0TXFB_END0     - org: 49TXFB_START1   - org: 80TXFB_END1     - org: 109RXFB_START0   - org: 0RXFB_END0     - org: 49RXFB_START1   - org: 256RXFB_END1     - org: 315 Start Iridia IT_AMODE (in dmp access) why is it required?DFE_ATM_LOOPBACKDFE_PING_TESTDFE_MEM_TESTCONFIG_AMAZON_S_MEI_FW_LOOPBACK Power up MEI  enable dsl enable AHB base for ARCMSGAV for arc modem ready semaphore initialization, mutexif (request_irq (pDev->nIrq[IFX_DYING_GASP], IFX_MEI_Dying_Gasp_IrqHandle, 0, "DYING_GASP", pDev) != 0) {
		IFX_MEI_EMSG ("request_irq %d failed!\n", pDev->nIrq[IFX_DYING_GASP]);
		return -1;
	}	IFX_MEI_DMSG("Device %d initialized. IER %#x\n", num, bsp_get_irq_ier(pDev->nIrq[IFX_DYING_GASP]));int maj = MAJOR(ino->i_rdev);*
 * Callback function for linux userspace program writing
 *
 * Callback function for linux userspace program ioctling
 	DSL_DEV_MeiDebug_t debugrdwr;	case DSL_FIO_BSP_DEBUG_READ:
	case DSL_FIO_BSP_DEBUG_WRITE:
		IFX_MEI_IoctlCopyFrom (from_kernel,
					     (char *) (&debugrdwr),
					     (char *) lon,
					     sizeof (debugrdwr));

		if (command == DSL_FIO_BSP_DEBUG_READ)
			meierr = DSL_BSP_MemoryDebugAccess (pDev,
								 DSL_BSP_MEMORY_READ,
								 debugrdwr.
								 iAddress,
								 debugrdwr.
								 buffer,
								 debugrdwr.
								 iCount);
		else
			meierr = DSL_BSP_MemoryDebugAccess (pDev,
								 DSL_BSP_MEMORY_WRITE,
								 debugrdwr.
								 iAddress,
								 debugrdwr.
								 buffer,
								 debugrdwr.
								 iCount);

		IFX_MEI_IoctlCopyTo (from_kernel, (char *) lon, (char *) (&debugrdwr), sizeof (debugrdwr));
		break;		IFX_MEI_EMSG("Invalid IOCTL command: %d\n");
 * Writing function for linux proc filesystem
  export function for DSL Driver  The functions of MEI_DriverHandleGet and MEI_DriverHandleDelete are
something like open/close in kernel space , where the open could be used
to register a callback for autonomous messages and returns a mei driver context pointer (comparable to the file descriptor in user space)
   The context will be required for the multi line chips future! EXPORT_SYMBOL (DSL_BSP_AdslLedSet); provide a register/unregister function for DSL driver to register a event callback function*****************************************************************************

                               Copyright (c) 2009
                            Infineon Technologies AG
                     Am Campeon 1-12; 81726 Munich, Germany

  For licensing information, see the file 'LICENSE' in the root folder of
  this software module.

*****************************************************************************!
  \defgroup AMAZON_S_MEI Amazon-S MEI Driver Module
  \brief Amazon-S MEI driver module
 !
  \defgroup Internal Compile Parametere
  \ingroup AMAZON_S_MEI
  \brief exported functions for other driver use
 !
  \file amazon_s_mei_bsp.c
  \ingroup AMAZON_S_MEI
  \brief Amazon-S MEI driver file
 #include "ifxmips_atm.h"#define LTQ_RCU_RST                   IFX_RCU_RST_REQ
#define LTQ_RCU_RST_REQ_ARC_JTAG      IFX_RCU_RST_REQ_ARC_JTAG
#define LTQ_RCU_RST_REQ_DFE		  IFX_RCU_RST_REQ_DFE
#define LTQ_RCU_RST_REQ_AFE		  IFX_RCU_RST_REQ_AFE
#define IFXMIPS_FUSE_BASE_ADDR            IFX_FUSE_BASE_ADDR
#define IFXMIPS_ICU_IM0_IER               IFX_ICU_IM0_IER
#define IFXMIPS_ICU_IM2_IER               IFX_ICU_IM2_IER
#define LTQ_MEI_INT                   IFX_MEI_INT
#define LTQ_MEI_DYING_GASP_INT        IFX_MEI_DYING_GASP_INT
#define LTQ_MEI_BASE_ADDR  		  IFX_MEI_SPACE_ACCESS
#define IFXMIPS_PMU_PWDCR		  IFX_PMU_PWDCR
#define IFXMIPS_MPS_CHIPID                IFX_MPS_CHIPID

#define ifxmips_port_reserve_pin 	  ifx_gpio_pin_reserve
#define ifxmips_port_set_dir_in		  ifx_gpio_dir_in_set
#define ifxmips_port_clear_altsel0        ifx_gpio_altsel0_set
#define ifxmips_port_clear_altsel1 	  ifx_gpio_altsel1_clear
#define ifxmips_port_set_open_drain       ifx_gpio_open_drain_clear
#define ifxmips_port_free_pin		  ifx_gpio_pin_free
#define ifxmips_mask_and_ack_irq	  bsp_mask_and_ack_irq
#define IFXMIPS_MPS_CHIPID_VERSION_GET    IFX_MCD_CHIPID_VERSION_GET
#define ltq_r32(reg)                        __raw_readl(reg)
#define ltq_w32(val, reg)                   __raw_writel(val, reg)
#define ltq_w32_mask(clear, set, reg)       ltq_w32((ltq_r32(reg) & ~clear) | set, reg)
#define DFE_MEM_TEST#define DFE_PING_TESTCONFIG_AMAZON_S_MEI_FW_LOOPBACKDSL_DEV_MeiError_t DSL_BSP_AdslLedSet (DSL_DEV_Device_t *, DSL_DEV_LedId_t, DSL_DEV_LedMode_t);  holding swap pages*
 * Write a value to register
 * This function writes a value to danube register
 *
 * \param  	ul_address	The address to write
 * \param  	ul_data		The value to write
 * \ingroup	Internal
 *
 * Write a value to register
 * This function writes a value to danube register
 *
 * \param 	pDev		the device pointer
 * \param  	ul_address	The address to write
 * \param  	ul_data		The value to write
 * \ingroup	Internal
 *
 * Read the danube register
 * This function read the value from danube register
 *
 * \param  	ul_address	The address to write
 * \param  	pul_data	Pointer to the data
 * \ingroup	Internal
 *
 * Read the danube register
 * This function read the value from danube register
 *
 * \param 	pDev		the device pointer
 * \param  	ul_address	The address to write
 * \param  	pul_data	Pointer to the data
 * \ingroup	Internal
 *
 * Write several DWORD datas to ARC memory via ARC DMA interface
 * This function writes several DWORD datas to ARC memory via DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	destaddr	The address to write
 * \param  	databuff	Pointer to the data buffer
 * \param  	databuffsize	Number of DWORDs to write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Set the write transfer address      Write the data pushed across DMA*
 * Read several DWORD datas from ARC memory via ARC DMA interface
 * This function reads several DWORD datas from ARC memory via DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	srcaddr		The address to read
 * \param  	databuff	Pointer to the data buffer
 * \param  	databuffsize	Number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Set the read transfer address      Read the data popped across DMA swap half word*
 * Switch the ARC control mode
 * This function switchs the ARC control mode to JTAG mode or MEI mode
 *
 * \param 	pDev		the device pointer
 * \param  	mode		The mode want to switch: JTAG_MASTER_MODE or MEI_MASTER_MODE.
 * \ingroup	Internal
 *
 * Disable ARC to MEI interrupt
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
 *
 * Eable ARC to MEI interrupt
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
 *
 * Poll for transaction complete signal
 * This function polls and waits for transaction complete signal.
 *
 * \param 	pDev		the device pointer
 * \ingroup	Internal
  to clear this interrupt*
 * ARC Debug Memory Access for a single DWORD reading.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	DEC_mode	ARC memory space to used
 * \param  	address	  	Address to read
 * \param  	data	  	Pointer to data
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * ARC Debug Memory Access for a single DWORD writing.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	DEC_mode	ARC memory space to used
 * \param  	address	  	The address to write
 * \param  	data	  	The data to write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * ARC Debug Memory Access for writing.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	destaddr	The address to read
 * \param  	databuffer  	Pointer to data
 * \param	databuffsize	The number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Open the debug port before DMP memory write      For the requested length, write the address and write the data      Close the debug port after DMP memory write*
 * ARC Debug Memory Access for reading.
 * This function used for direct, address-based access to ARC memory.
 *
 * \param 	pDev		the device pointer
 * \param  	srcaddr	  	The address to read
 * \param  	databuffer  	Pointer to data
 * \param	databuffsize	The number of DWORDs to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Open the debug port before DMP memory read      For the requested length, write the address and read the data      Close the debug port after DMP memory read*
 * Send a message to ARC MailBox.
 * This function sends a message to ARC Mailbox via ARC DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	msgsrcbuffer  	Pointer to message.
 * \param	msgsize		The number of words to write.
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Write to mailbox      Notify arc that mailbox write completed wait for ARC to clear the bit*
 * Read a message from ARC MailBox.
 * This function reads a message from ARC Mailbox via ARC DMA interface.
 *
 * \param 	pDev		the device pointer
 * \param  	msgsrcbuffer  	Pointer to message.
 * \param	msgsize		The number of words to read
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Read from mailbox      Notify arc that mailbox read completed*
 * Download boot pages to ARC.
 * This function downloads boot pages to ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 
	 **     DMA the boot code page(s)
	 *
 * Initial efuse rar.
 **
 * efuse rar program
 * 0x4000 translate to  about 16 ms@111M, so should be enough  STEP a: Prepare memory for external accesses Write fuse_en bit24 PPE efuse*
 * Enable DFE Clock
 * This function enables DFE Clock
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 enable ac_clk signal*
 * Halt the ARC.
 * This function halts the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Switch arc control from JTAG mode to MEI mode      Switch arc control from MEI mode to JTAG mode*
 * Run the ARC.
 * This function runs the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
       Switch arc control from JTAG mode to MEI mode- write '1' to bit0      Write debug data reg with content ANDd with 0xFDFFFFFF (halt bit cleared)      Switch arc control from MEI mode to JTAG mode- write '0' to bit0      Enable mask for arc codeswap interrupts*
 * Reset the ARC.
 * This function resets the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
  reset ARC reset part of PPE*
 * Reset/halt/run the DFE.
 * This function provide operations to reset/halt/run the DFE.
 *
 * \param 	pDev		the device pointer
 * \param	mode		which operation want to do
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Accress DFE memory.
 * This function provide a way to access DFE memory;
 *
 * \param 	pDev		the device pointer
 * \param	type		read or write
 * \param	destaddr	destination address
 * \param	databuff	pointer to hold data
 * \param	databuffsize	size want to read/write
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Download boot code to ARC.
 * This function downloads boot code to ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 program fuse rar*
 * Enable Jtag debugger interface
 * This function setups mips gpio to enable jtag debugger
 *
 * \param 	pDev		the device pointer
 * \param 	enable		enable or disable
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 
	int meierr=0;
	u32 reg_data;
	switch (enable) {
	case 1:
                //reserve gpio 9, 10, 11, 14, 19 for ARC JTAG
		ifxmips_port_reserve_pin (0, 9);
		ifxmips_port_reserve_pin (0, 10);
		ifxmips_port_reserve_pin (0, 11);
		ifxmips_port_reserve_pin (0, 14);
		ifxmips_port_reserve_pin (1, 3);

		ifxmips_port_set_dir_in(0, 11);
		ifxmips_port_clear_altsel0(0, 11);
		ifxmips_port_clear_altsel1(0, 11);
		ifxmips_port_set_open_drain(0, 11);
        //enable ARC JTAG
        IFX_MEI_LongWordRead ((u32) LTQ_RCU_RST, &reg_data);
        IFX_MEI_LongWordWrite ((u32) LTQ_RCU_RST, reg_data | LTQ_RCU_RST_REQ_ARC_JTAG);
		break;
	case 0:
	default:
		break;
	}
jtag_end:
	if (meierr)
		return DSL_DEV_MEI_ERR_FAILURE;
*
 * Enable DFE to MIPS interrupt
 * This function enable DFE to MIPS interrupt
 *
 * \param 	pDev		the device pointer
 * \param 	enable		enable or disable
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 *
 * Get the modem status
 * This function return the modem status
 *
 * \param 	pDev		the device pointer
 * \return	1: modem ready 0: not ready
 * \ingroup	Internal
 DSL_LED_HD_CPU                bsp_led_config (&param);                bsp_led_config (&param); data data*
* Compose a message.
* This function compose a message from opcode, group, address, index, size, and data
*
* \param       opcode          The message opcode
* \param       group           The message group number
* \param       address         The message address.
* \param       index           The message index.
* \param       size            The number of words to read/write.
* \param       data            The pointer to data.
* \param       CMVMSG          The pointer to message buffer.
* \ingroup     Internal
*
 * Send a message to ARC and read the response
 * This function sends a message to arc, waits the response, and reads the responses.
 *
 * \param 	pDev		the device pointer
 * \param	request		Pointer to the request
 * \param	reply		Wait reply or not.
 * \param	response	Pointer to the response
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
  write cmv to arc, if reply needed, wait for replyCMV_timeout*
 * Reset the ARC, download boot codes, and run the ARC.
 * This function resets the ARC, downloads boot codes to ARC, and runs the ARC.
 *
 * \param 	pDev		the device pointer
 * \return	DSL_DEV_MEI_ERR_SUCCESS or DSL_DEV_MEI_ERR_FAILURE
 * \ingroup	Internal
 	DSL_DEV_WinHost_Message_t m; check image size TODO: check crc/IFX_MEI_DMSG("Starting to meiDownloadBootCode\n"); Turn off irq  Re-enable irq *
 * Get the page's data pointer
 * This function caculats the data address from the firmware header.
 *
 * \param 	pDev		the device pointer
 * \param	Page		The page number.
 * \param	data		Data page or program page.
 * \param	MaxSize		The maximum size to read.
 * \param	Buffer		Pointer to data.
 * \param	Dest		Pointer to the destination address.
 * \return	The number of bytes to read.
 * \ingroup	Internal
 
	 **     Get program or data size, depending on "data" flag
	       Clear boot bit!
	 **     Get program or data offset, depending on "data" flag
	 
	 **     Copy data/program to buffer
	 
	 **     Pass back data/program destination address
	 *
 * Free the memory for ARC firmware
 *
 * \param 	pDev		the device pointer
 * \param	type	Free all memory or free the unused memory after showtime
 * \ingroup	Internal
 		DSL_DEV_PRIVATE(pDev)->adsl_mem_info; Alloc Swap Pages skip bar15 for XDATA usage. Pointer not 1k aligned, so free it and allocate a larger chunk
			 * for further alignment.
			 *
 * Program the BAR registers
 *
 * \param 	pDev		the device pointer
 * \param	nTotalBar	The number of bar to program.
 * \ingroup	Internal
 skip XDATA register These are for /proc/danube_mei/meminfo purpose  Prevent it from being freed  update MEI_XDATA_BASE_SH This copies the firmware from secondary storage to 64k memory segment in SDRAM  header of image_size and crc are not included. check if arc is haltfree allskip XDATA register Pointer not 1k aligned, so free it and allocate a larger chunk
			 * for further alignment.
			 
 * Register a callback event.
 * Return:
 * -1 if the event already has a callback function registered.
 *  0 success
 *
 * MEI Dying Gasp interrupt handler
 *
 * \param int1
 * \param void0
 * \param regs	Pointer to the structure of danube mips registers
 * \ingroup	Internal
 static irqreturn_t IFX_MEI_Dying_Gasp_IrqHandle (int int1, void *void0)
{
	DSL_DEV_Device_t *pDev = (DSL_DEV_Device_t *) void0;
        DSL_BSP_CB_Type_t event;

	if (pDev == NULL)
		IFX_MEI_EMSG("Error: Got Interrupt but pDev is NULL!!!!\n");

#ifndef CONFIG_SMP
	disable_irq (pDev->nIrq[IFX_DYING_GASP]);
#else
	disable_irq_nosync(pDev->nIrq[IFX_DYING_GASP]);
#endif
	event = DSL_BSP_CB_DYING_GASP;

	if (dsl_bsp_event_callback[event].function)
		(*dsl_bsp_event_callback[event].function)(pDev, event, dsl_bsp_event_callback[event].pData);

#ifdef CONFIG_USE_EMULATOR
    IFX_MEI_EMSG("Dying Gasp! Shutting Down... (Work around for Amazon-S Venus emulator)\n");
#else
	IFX_MEI_EMSG("Dying Gasp! Shutting Down...\n");
//	kill_proc (1, SIGINT, 1);   
#endif
        return IRQ_HANDLED;
}
*
 * MEI interrupt handler
 *
 * \param int1
 * \param void0
 * \param regs	Pointer to the structure of danube mips registers
 * \ingroup	Internal
 CONFIG_AMAZON_S_MEI_FW_LOOPBACK clear eoc message interrupt Reboot normal messagecheck ARC ready message Iridia Registers Address Constants *((volatile u32 *)(addr)) =  data; u32  rd_val;rd_val = *((volatile u32 *)(addr)); return rd_val; This routine writes the mailbox with the data in an input array  This routine reads the output mailbox and places the results into an array  Write address register  Write data register  wait until complete - timeout at 40  clear the flag printk("jt %X %08X %08X\n",i,jump_table[i*2+0],jump_table[i*2+1]);got_int = 1;printk("IFX_MEI_MailboxWrite ret=%d\n",i);schedule();mbox_read(&rd_mbox[0],6); start the clock WriteARCreg(AUX_XMEM_LTEST,0); WriteARCreg(AUX_XDMA_GAP,0);WriteARCreg(AUX_IC_CTRL,2);DFE_PING_TESTdefined( DFE_PING_TEST )|| defined( DFE_ATM_LOOPBACK)DFE_MEM_TESTTIMER_DELAY   - org: 1024TXFB_START0TXFB_END0     - org: 49TXFB_START1   - org: 80TXFB_END1     - org: 109RXFB_START0   - org: 0RXFB_END0     - org: 49RXFB_START1   - org: 256RXFB_END1     - org: 315 Start Iridia IT_AMODE (in dmp access) why is it required?DFE_ATM_LOOPBACKDFE_PING_TESTDFE_MEM_TESTCONFIG_AMAZON_S_MEI_FW_LOOPBACK Power up MEI  enable dsl enable AHB base for ARCMSGAV for arc modem ready semaphore initialization, mutexif (request_irq (pDev->nIrq[IFX_DYING_GASP], IFX_MEI_Dying_Gasp_IrqHandle, 0, "DYING_GASP", pDev) != 0) {
		IFX_MEI_EMSG ("request_irq %d failed!\n", pDev->nIrq[IFX_DYING_GASP]);
		return -1;
	}	IFX_MEI_DMSG("Device %d initialized. IER %#x\n", num, bsp_get_irq_ier(pDev->nIrq[IFX_DYING_GASP]));int maj = MAJOR(ino->i_rdev);*
 * Callback function for linux userspace program writing
 *
 * Callback function for linux userspace program ioctling
 	DSL_DEV_MeiDebug_t debugrdwr;	case DSL_FIO_BSP_DEBUG_READ:
	case DSL_FIO_BSP_DEBUG_WRITE:
		IFX_MEI_IoctlCopyFrom (from_kernel,
					     (char *) (&debugrdwr),
					     (char *) lon,
					     sizeof (debugrdwr));

		if (command == DSL_FIO_BSP_DEBUG_READ)
			meierr = DSL_BSP_MemoryDebugAccess (pDev,
								 DSL_BSP_MEMORY_READ,
								 debugrdwr.
								 iAddress,
								 debugrdwr.
								 buffer,
								 debugrdwr.
								 iCount);
		else
			meierr = DSL_BSP_MemoryDebugAccess (pDev,
								 DSL_BSP_MEMORY_WRITE,
								 debugrdwr.
								 iAddress,
								 debugrdwr.
								 buffer,
								 debugrdwr.
								 iCount);

		IFX_MEI_IoctlCopyTo (from_kernel, (char *) lon, (char *) (&debugrdwr), sizeof (debugrdwr));
		break;		IFX_MEI_EMSG("Invalid IOCTL command: %d\n");
 * Writing function for linux proc filesystem
  export function for DSL Driver  The functions of MEI_DriverHandleGet and MEI_DriverHandleDelete are
something like open/close in kernel space , where the open could be used
to register a callback for autonomous messages and returns a mei driver context pointer (comparable to the file descriptor in user space)
   The context will be required for the multi line chips future! EXPORT_SYMBOL (DSL_BSP_AdslLedSet); provide a register/unregister function for DSL driver to register a event callback function