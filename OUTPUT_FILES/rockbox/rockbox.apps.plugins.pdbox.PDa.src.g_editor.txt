 Copyright (c) 1997-2001 Miller Puckette and others.
* For information on usage and redistribution, and for a DISCLAIMER OF ALL
* WARRANTIES, see the file, "LICENSE.txt," in this distribution.   ROCKBOX  ROCKBOX  ------------------ forward declarations ---------------  ---------------- generic widget behavior -------------------------  ------------------------ managing the selection -----------------  call this for unselected objects only  LATER #ifdef out the following check  call this for selected objects only  get the index of a gobj in a glist.  If y is zero, return the
    total number of objects.  get the index of the object, among selected items, if "selected"
    is set; otherwise, among unselected ones.  If y is zero, just
    counts the selected or unselected objects.  ------------------- support for undo/redo  --------------------------  current undo function if any  whether we can now UNDO or REDO  data private to the undo function  which canvas we can undo on  blow away the old undo information.  In one special case the
	old undo info is re-used; if so we shouldn't free it here.  enable undo in menu  clear undo if it happens to be for the canvas x.
     (but if x is 0, clear it regardless of who owns it.)  post("undo");  enable redo in menu  post("redo");  enable undo in menu  ------- specific undo methods: 1. connect and disconnect --------  connect just calls disconnect actions backward...  ---------- ... 2. cut, clear, and typing into objects: --------  operation was a cut  .. a clear  text typed into a box  the object cleared or typed into  connections into and out of object  buffer to paste back for redo if TEXT  from flags above  store connections into/out of the selection  --------- 3. motion, including "tidy up" and stretching -----------  --------- 4. paste (also duplicate) -----------  index of first object pasted  if it was "duplicate" have to re-enact the displacement.  recursively check for abstractions to reload as result of a save. 
    Don't reload the one we just saved ("except") though.   LATER try to do the same trick for externs.  number of objects  we're going to remake the object, so "g" will go stale.
		Get its index here, and afterward restore g.  Also, the
		replacement will be at teh end of the list, so we don't
		do g = g->g_next in this case.  call canvas_doreload on everyone  find all root canvases  ------------------------ event handling ------------------------  CURSOR_RUNMODE_NOTHING  CURSOR_RUNMODE_NOTHING  CURSOR_RUNMODE_CLICKME  CURSOR_RUNMODE_THICKEN  CURSOR_RUNMODE_ADDPOINT  CURSOR_EDITMODE_NOTHING  CURSOR_EDITMODE_CONNECT  CURSOR_EDITMODE_DISCONNECT  check if a point lies in a gobj.   find the last gobj, if any, containing the point.  right-clicking on a canvas object pops up a menu.  ROCKBOX  ROCKBOX  tell GUI to create a properties dialog on the canvas.  We tell
    the user the negative of the "pixel" y scale to make it appear to grow
    naturally upward, whereas pixels grow downward.  ROCKBOX  ROCKBOX  if (x->gl_owner && glist_isvisible(x->gl_owner))
    	    canvas_vis(x, 1);  called from the gui when "OK" is selected on the canvas properties
    	dialog.  Again we negate "y" scale.  called from the gui when a popup menu comes back with "properties,"
    	"open," or "help."  properties  open  help  on one-button-mouse machines, you can use double click to
    mean right click (which gets the popup menu.)  Do this for Mac.  mouse click  if keyboard was grabbed, notify grabber and cancel the grab  post("click %d %d %d %d", xpos, ypos, which, mod);  check if the object wants to be clicked  if not a runmode left click, fall here.  check you're in the rectangle  look for an outlet  not in an outlet; select and move  check if the box is being text edited  otherwise select and drag to displace  if right click doesn't hit any boxes, call rightclick
	    routine anyway  if not an editing action, and if we didn't hit a
    	box, set cursor and return  having failed to find a box, we try lines now.  ROCKBOX  ROCKBOX  ROCKBOX  after motion, if there's only one item selected, activate it  GG misused the (unused) dbl parameter to tell if mouseup  check if the object wants to be clicked  displace the selection by (dx, dy) pixels  this routine is called whenever a key is pressed or released.  "x"
    may be zero if there's no current canvas.  The first argument is true or
    fals for down/up; the second one is either a symbolic key name (e.g.,
    "Right" or an Ascii key number.  nonzero if it's a key down  nonzero if shift-ed  ROCKBOX  ROCKBOX  if that 'invis'ed the window, we'd better stop.  if an object has "grabbed" keys just send them on  if a text editor is open send it on  check for backspace or clear  check for arrow keys  post("motion %d %d", xpos, ypos);  ----------------------------- window stuff -----------------------  ROCKBOX  ROCKBOX  put up a dialog which may call canvas_font back to do the work  ROCKBOX  ROCKBOX  find an atom or string of atoms  got it... now show it.  find all root canvases  split list to "selected" and "unselected" parts  move the selected part to the end  add connections to binbuf  if text is selected, deselecting it might remake the
    	object. So we deselect it and hunt for a "new" object on
    	the glist to reselect.  this is pretty wierd...  should rewrite it  ROCKBOX  ROCKBOX  bug fix thanks to Hannes  LATER might have to speed this up  ROCKBOX  ROCKBOX  if nobody is selected, this means do it to all boxes;
	othewise just the selection  tidy horizontally  tidy vertically.  First guess the user's favorite vertical spacing  canvas_editing can be zero; canvas_key checks for that  called by canvas_font below  canvas_menufont calls up a TK dialog which calls this back  ------------------------ events ----------------------------------  ------------------------ menu actions ----------------------------  -------------- connect method used in reading files ------------------  -------------- copy buffer ------------------  Copyright (c) 1997-2001 Miller Puckette and others.
* For information on usage and redistribution, and for a DISCLAIMER OF ALL
* WARRANTIES, see the file, "LICENSE.txt," in this distribution.   ROCKBOX  ROCKBOX  ------------------ forward declarations ---------------  ---------------- generic widget behavior -------------------------  ------------------------ managing the selection -----------------  call this for unselected objects only  LATER #ifdef out the following check  call this for selected objects only  get the index of a gobj in a glist.  If y is zero, return the
    total number of objects.  get the index of the object, among selected items, if "selected"
    is set; otherwise, among unselected ones.  If y is zero, just
    counts the selected or unselected objects.  ------------------- support for undo/redo  --------------------------  current undo function if any  whether we can now UNDO or REDO  data private to the undo function  which canvas we can undo on  blow away the old undo information.  In one special case the
	old undo info is re-used; if so we shouldn't free it here.  enable undo in menu  clear undo if it happens to be for the canvas x.
     (but if x is 0, clear it regardless of who owns it.)  post("undo");  enable redo in menu  post("redo");  enable undo in menu  ------- specific undo methods: 1. connect and disconnect --------  connect just calls disconnect actions backward...  ---------- ... 2. cut, clear, and typing into objects: --------  operation was a cut  .. a clear  text typed into a box  the object cleared or typed into  connections into and out of object  buffer to paste back for redo if TEXT  from flags above  store connections into/out of the selection  --------- 3. motion, including "tidy up" and stretching -----------  --------- 4. paste (also duplicate) -----------  index of first object pasted  if it was "duplicate" have to re-enact the displacement.  recursively check for abstractions to reload as result of a save. 
    Don't reload the one we just saved ("except") though.   LATER try to do the same trick for externs.  number of objects  we're going to remake the object, so "g" will go stale.
		Get its index here, and afterward restore g.  Also, the
		replacement will be at teh end of the list, so we don't
		do g = g->g_next in this case.  call canvas_doreload on everyone  find all root canvases  ------------------------ event handling ------------------------  CURSOR_RUNMODE_NOTHING  CURSOR_RUNMODE_NOTHING  CURSOR_RUNMODE_CLICKME  CURSOR_RUNMODE_THICKEN  CURSOR_RUNMODE_ADDPOINT  CURSOR_EDITMODE_NOTHING  CURSOR_EDITMODE_CONNECT  CURSOR_EDITMODE_DISCONNECT  check if a point lies in a gobj.   find the last gobj, if any, containing the point.  right-clicking on a canvas object pops up a menu.  ROCKBOX  ROCKBOX  tell GUI to create a properties dialog on the canvas.  We tell
    the user the negative of the "pixel" y scale to make it appear to grow
    naturally upward, whereas pixels grow downward.  ROCKBOX  ROCKBOX  if (x->gl_owner && glist_isvisible(x->gl_owner))
    	    canvas_vis(x, 1);  called from the gui when "OK" is selected on the canvas properties
    	dialog.  Again we negate "y" scale.  called from the gui when a popup menu comes back with "properties,"
    	"open," or "help."  properties  open  help  on one-button-mouse machines, you can use double click to
    mean right click (which gets the popup menu.)  Do this for Mac.  mouse click  if keyboard was grabbed, notify grabber and cancel the grab  post("click %d %d %d %d", xpos, ypos, which, mod);  check if the object wants to be clicked  if not a runmode left click, fall here.  check you're in the rectangle  look for an outlet  not in an outlet; select and move  check if the box is being text edited  otherwise select and drag to displace  if right click doesn't hit any boxes, call rightclick
	    routine anyway  if not an editing action, and if we didn't hit a
    	box, set cursor and return  having failed to find a box, we try lines now.  ROCKBOX  ROCKBOX  ROCKBOX  after motion, if there's only one item selected, activate it  GG misused the (unused) dbl parameter to tell if mouseup  check if the object wants to be clicked  displace the selection by (dx, dy) pixels  this routine is called whenever a key is pressed or released.  "x"
    may be zero if there's no current canvas.  The first argument is true or
    fals for down/up; the second one is either a symbolic key name (e.g.,
    "Right" or an Ascii key number.  nonzero if it's a key down  nonzero if shift-ed  ROCKBOX  ROCKBOX  if that 'invis'ed the window, we'd better stop.  if an object has "grabbed" keys just send them on  if a text editor is open send it on  check for backspace or clear  check for arrow keys  post("motion %d %d", xpos, ypos);  ----------------------------- window stuff -----------------------  ROCKBOX  ROCKBOX  put up a dialog which may call canvas_font back to do the work  ROCKBOX  ROCKBOX  find an atom or string of atoms  got it... now show it.  find all root canvases  split list to "selected" and "unselected" parts  move the selected part to the end  add connections to binbuf  if text is selected, deselecting it might remake the
    	object. So we deselect it and hunt for a "new" object on
    	the glist to reselect.  this is pretty wierd...  should rewrite it  ROCKBOX  ROCKBOX  bug fix thanks to Hannes  LATER might have to speed this up  ROCKBOX  ROCKBOX  if nobody is selected, this means do it to all boxes;
	othewise just the selection  tidy horizontally  tidy vertically.  First guess the user's favorite vertical spacing  canvas_editing can be zero; canvas_key checks for that  called by canvas_font below  canvas_menufont calls up a TK dialog which calls this back  ------------------------ events ----------------------------------  ------------------------ menu actions ----------------------------  -------------- connect method used in reading files ------------------  -------------- copy buffer ------------------  Copyright (c) 1997-2001 Miller Puckette and others.
* For information on usage and redistribution, and for a DISCLAIMER OF ALL
* WARRANTIES, see the file, "LICENSE.txt," in this distribution.   ROCKBOX  ROCKBOX  ------------------ forward declarations ---------------  ---------------- generic widget behavior -------------------------  ------------------------ managing the selection -----------------  call this for unselected objects only  LATER #ifdef out the following check  call this for selected objects only  get the index of a gobj in a glist.  If y is zero, return the
    total number of objects.  get the index of the object, among selected items, if "selected"
    is set; otherwise, among unselected ones.  If y is zero, just
    counts the selected or unselected objects.  ------------------- support for undo/redo  --------------------------  current undo function if any  whether we can now UNDO or REDO  data private to the undo function  which canvas we can undo on  blow away the old undo information.  In one special case the
	old undo info is re-used; if so we shouldn't free it here.  enable undo in menu  clear undo if it happens to be for the canvas x.
     (but if x is 0, clear it regardless of who owns it.)  post("undo");  enable redo in menu  post("redo");  enable undo in menu  ------- specific undo methods: 1. connect and disconnect --------  connect just calls disconnect actions backward...  ---------- ... 2. cut, clear, and typing into objects: --------  operation was a cut  .. a clear  text typed into a box  the object cleared or typed into  connections into and out of object  buffer to paste back for redo if TEXT  from flags above  store connections into/out of the selection  --------- 3. motion, including "tidy up" and stretching -----------  --------- 4. paste (also duplicate) -----------  index of first object pasted  if it was "duplicate" have to re-enact the displacement.  recursively check for abstractions to reload as result of a save. 
    Don't reload the one we just saved ("except") though.   LATER try to do the same trick for externs.  number of objects  we're going to remake the object, so "g" will go stale.
		Get its index here, and afterward restore g.  Also, the
		replacement will be at teh end of the list, so we don't
		do g = g->g_next in this case.  call canvas_doreload on everyone  find all root canvases  ------------------------ event handling ------------------------  CURSOR_RUNMODE_NOTHING  CURSOR_RUNMODE_NOTHING  CURSOR_RUNMODE_CLICKME  CURSOR_RUNMODE_THICKEN  CURSOR_RUNMODE_ADDPOINT  CURSOR_EDITMODE_NOTHING  CURSOR_EDITMODE_CONNECT  CURSOR_EDITMODE_DISCONNECT  check if a point lies in a gobj.   find the last gobj, if any, containing the point.  right-clicking on a canvas object pops up a menu.  ROCKBOX  ROCKBOX  tell GUI to create a properties dialog on the canvas.  We tell
    the user the negative of the "pixel" y scale to make it appear to grow
    naturally upward, whereas pixels grow downward.  ROCKBOX  ROCKBOX  if (x->gl_owner && glist_isvisible(x->gl_owner))
    	    canvas_vis(x, 1);  called from the gui when "OK" is selected on the canvas properties
    	dialog.  Again we negate "y" scale.  called from the gui when a popup menu comes back with "properties,"
    	"open," or "help."  properties  open  help  on one-button-mouse machines, you can use double click to
    mean right click (which gets the popup menu.)  Do this for Mac.  mouse click  if keyboard was grabbed, notify grabber and cancel the grab  post("click %d %d %d %d", xpos, ypos, which, mod);  check if the object wants to be clicked  if not a runmode left click, fall here.  check you're in the rectangle  look for an outlet  not in an outlet; select and move  check if the box is being text edited  otherwise select and drag to displace  if right click doesn't hit any boxes, call rightclick
	    routine anyway  if not an editing action, and if we didn't hit a
    	box, set cursor and return  having failed to find a box, we try lines now.  ROCKBOX  ROCKBOX  ROCKBOX  after motion, if there's only one item selected, activate it  GG misused the (unused) dbl parameter to tell if mouseup  check if the object wants to be clicked  displace the selection by (dx, dy) pixels  this routine is called whenever a key is pressed or released.  "x"
    may be zero if there's no current canvas.  The first argument is true or
    fals for down/up; the second one is either a symbolic key name (e.g.,
    "Right" or an Ascii key number.  nonzero if it's a key down  nonzero if shift-ed  ROCKBOX  ROCKBOX  if that 'invis'ed the window, we'd better stop.  if an object has "grabbed" keys just send them on  if a text editor is open send it on  check for backspace or clear  check for arrow keys  post("motion %d %d", xpos, ypos);  ----------------------------- window stuff -----------------------  ROCKBOX  ROCKBOX  put up a dialog which may call canvas_font back to do the work  ROCKBOX  ROCKBOX  find an atom or string of atoms  got it... now show it.  find all root canvases  split list to "selected" and "unselected" parts  move the selected part to the end  add connections to binbuf  if text is selected, deselecting it might remake the
    	object. So we deselect it and hunt for a "new" object on
    	the glist to reselect.  this is pretty wierd...  should rewrite it  ROCKBOX  ROCKBOX  bug fix thanks to Hannes  LATER might have to speed this up  ROCKBOX  ROCKBOX  if nobody is selected, this means do it to all boxes;
	othewise just the selection  tidy horizontally  tidy vertically.  First guess the user's favorite vertical spacing  canvas_editing can be zero; canvas_key checks for that  called by canvas_font below  canvas_menufont calls up a TK dialog which calls this back  ------------------------ events ----------------------------------  ------------------------ menu actions ----------------------------  -------------- connect method used in reading files ------------------  -------------- copy buffer ------------------ 