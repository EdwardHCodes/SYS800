*
	 * The max average rate that is "OK" to use in this app.  Should be configurable elsewhere?
	 *
	 * The "current" patient, used to determine if the patient has changed
	 How can we get "all oximetry devices"?  For now, just add all devices. TODO Auto-generated method stub TODO Auto-generated method stublog.info("udi " + c.unique_device_identifier + " is MRN=" + mrnPartition);
		            	 * The patient has definitely changed - even if the selected patient is "Unassigned",
		            	 * then that "Patient" has an ID
		            	 Nothing else to do.Patient has changeddeviceUdiToPatientMRN.put(c.unique_device_identifier, p);*
	 * Clear the current graph.  Refactored to allow invocation from a different event handler thread,
	 * using the standard check.  Which is possibly overkill (as we could likely just always call runLater
	 * even if we were on the GUI thread, but it does the job.
	 No chart yet - possibly/probably from an MDSEvent invocation.  Just return to avoid any exceptions.Also reset the backgroundsetInputFile(selected);else, cancelled...Mostly copied, to start with, from org.mdpnp.apps.testapps.chart.ChartMoved validation to the top, so we can avoid creating series etc. that we then don't useValidate the alarm thresholdValidate the smart alarm countSlightly different validation here, as this is not required.We will treat empty string as 0 and smartCount=0 as disabled.Any more validation?At start of run, reset and alarm condition from end of previous run        v.addListener(valueListener);        v.forEach((t)->add(t));Scan through y for upper and lower;Set y axis max to 100Slightly pad the lower limitUse round on the lower bound to force an integer value on the axis labelCreate a series that represents the alarm threshold.If we loop through our x and y values here, we can sleep or schedule an executor to do it later        ThreadLocal<Integer> i=new ThreadLocal<Integer>();        int i=0;Before possibly hitting an alarm condition, preserve the current backgroundTODO:  - Should we do "alarm condition detection" here or in a separate thread?Alarm handlingSmart alarms are disabled - simple alarm condition onlyThis is the transition pointSmart alarms are enabledDitch this later when we want alarm to stay on                			System.err.println("Calling unsetAlarmCondition with smart alarms enabled at point "+xx);UNCOMMENT THE NEXT LINE IF WE WANT SMART ALARM RESETS                			unsetAlarmCondition();                	if(yy<simpleThreshold) {                		//Simple alarm threshold - IF smart alarm is disabled                		if(smartCount==0) {                			//Smart alarms are disabled - just set the simple alarm condition                			if(inAlarm) {                				//Already alarm - remove nodes                				point.nodeProperty().set(null);                			}                			setAlarmCondition();                		} else {                			if(!dipped.get()) {                				//We were not previously below the threshold, now we are...                				dipped.set(true);	                			int currentSmart=timesBelowThreshold.incrementAndGet();//	                			System.err.println("currentSmart is "+currentSmart+" at index "+index);	                			if(currentSmart==smartCount) {	                				setAlarmCondition();	                				timesBelowThreshold.set(0);	//Reset the count	                			}                			}                		}                	} else {                		point.nodeProperty().set(null);                		if(inAlarm) {	                		unsetAlarmCondition();                		} else {                			                		}                		if(dipped.get()) {                			//We were in a possible alarm state, but now aren't                			dipped.set(false);//                			System.err.println("set dipped to false at index at index "+index);                		}                	}        for(int i=0;i<x.size();i++) {        	series.get(0).getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        	try {				Thread.sleep(100);			} catch (InterruptedException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}        	s.getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        }        lineChart.getData().addAll(series);        lineChart.getData().add(s);
        Series<Number, Number> fourSecRepeated=new Series<>();
        fourSecRepeated.setName("4 sec avg");
        int overFour=s.getData().size()/4;
        for(int i=0;i<overFour;i++) {
        	float nextAve= ( y.get((i*4)+0) + y.get((i*4)+1) + y.get((i*4)+2) + y.get((i*4)+3) ) / 4;
        	for(int j=0;j<4;j++) {
        		fourSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*4)+j, nextAve));
        	}
        }
        series.add(fourSecRepeated);
        
        Series<Number, Number> eightSecRepeated=new Series<>();
        eightSecRepeated.setName("8 sec avg");
        int overEight=s.getData().size()/8;
        for(int i=0;i<overEight;i++) {
        	float nextAve= ( y.get((i*8)+0) + y.get((i*8)+1) + y.get((i*8)+2) + y.get((i*8)+3) +
        			y.get((i*8)+4) + y.get((i*8)+5) + y.get((i*8)+6) + y.get((i*8)+7)) / 8;
        	for(int j=0;j<8;j++) {
        		eightSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*8)+j, nextAve));
        	}
        }
        series.add(eightSecRepeated);

        Series<Number, Number> sixteenSecRepeated=new Series<>();
        sixteenSecRepeated.setName("16 sec avg");
        int overSixteen=s.getData().size()/16;
        for(int i=0;i<overSixteen;i++) {
        	float nextAve= ( y.get((i*16)+0) + y.get((i*16)+1) + y.get((i*16)+2) + y.get((i*16)+3) +
        			y.get((i*16)+4) + y.get((i*16)+5) + y.get((i*16)+6) + y.get((i*16)+7) +
        			y.get((i*16)+8) + y.get((i*16)+9) + y.get((i*16)+10) + y.get((i*16)+11) +
        			y.get((i*16)+12) + y.get((i*16)+13) + y.get((i*16)+14) + y.get((i*16)+15)) / 16;
        	for(int j=0;j<16;j++) {
        		sixteenSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*16)+j, nextAve));
        	}
        }
        series.add(sixteenSecRepeated);
        		System.err.println("Alarm condition ON");		System.err.println("Alarm condition OFF");No device selected and/or available - can happen when patient is changed and no devices for that patientSome other deviceWhen we get here, we are looking at a property for the currently selected device						Thread.dumpStack();Case 2Great - this is OK.  Store it somewhere maybe?4 and 5 combined - should "can you get the average" and "is it 4 seconds or less" be separate questions?IN THIS LOGIC, WE DON'T FIND OUT IF IT'S SETTABLE OR NOT.19th July...Can the operator set the average.
						 * Operator says they have set the average to 4.  In this branch of the code,
						 * ice cannot get the average, so we must just assume they have
						 Case 3Alert alert=new Alert(Alert.AlertType.ERROR,"The average rate for this device is not known",ButtonType.OK);alert.showAndWait();This is case 1 - ICE can get the averaging rate.Case 5Here, we are at case 6 - average is over the limitCan we set it?Case 10Case 7 - ICE cannot set.			if()Case 9 - Operator can set it.Case 8 - Average can't be set.			requestedAverage.setText("");We can't set the average, so disable the controlscurrentAverage should not be editable		Thread.dumpStack();*
	 * The max average rate that is "OK" to use in this app.  Should be configurable elsewhere?
	 *
	 * The "current" patient, used to determine if the patient has changed
	 How can we get "all oximetry devices"?  For now, just add all devices. TODO Auto-generated method stub TODO Auto-generated method stublog.info("udi " + c.unique_device_identifier + " is MRN=" + mrnPartition);
		            	 * The patient has definitely changed - even if the selected patient is "Unassigned",
		            	 * then that "Patient" has an ID
		            	 Nothing else to do.Patient has changeddeviceUdiToPatientMRN.put(c.unique_device_identifier, p);*
	 * Clear the current graph.  Refactored to allow invocation from a different event handler thread,
	 * using the standard check.  Which is possibly overkill (as we could likely just always call runLater
	 * even if we were on the GUI thread, but it does the job.
	 No chart yet - possibly/probably from an MDSEvent invocation.  Just return to avoid any exceptions.Also reset the backgroundsetInputFile(selected);else, cancelled...Mostly copied, to start with, from org.mdpnp.apps.testapps.chart.ChartMoved validation to the top, so we can avoid creating series etc. that we then don't useValidate the alarm thresholdValidate the smart alarm countSlightly different validation here, as this is not required.We will treat empty string as 0 and smartCount=0 as disabled.Any more validation?At start of run, reset and alarm condition from end of previous run        v.addListener(valueListener);        v.forEach((t)->add(t));Scan through y for upper and lower;Set y axis max to 100Slightly pad the lower limitUse round on the lower bound to force an integer value on the axis labelCreate a series that represents the alarm threshold.If we loop through our x and y values here, we can sleep or schedule an executor to do it later        ThreadLocal<Integer> i=new ThreadLocal<Integer>();        int i=0;Before possibly hitting an alarm condition, preserve the current backgroundTODO:  - Should we do "alarm condition detection" here or in a separate thread?Alarm handlingSmart alarms are disabled - simple alarm condition onlyThis is the transition pointSmart alarms are enabledDitch this later when we want alarm to stay on                			System.err.println("Calling unsetAlarmCondition with smart alarms enabled at point "+xx);UNCOMMENT THE NEXT LINE IF WE WANT SMART ALARM RESETS                			unsetAlarmCondition();                	if(yy<simpleThreshold) {                		//Simple alarm threshold - IF smart alarm is disabled                		if(smartCount==0) {                			//Smart alarms are disabled - just set the simple alarm condition                			if(inAlarm) {                				//Already alarm - remove nodes                				point.nodeProperty().set(null);                			}                			setAlarmCondition();                		} else {                			if(!dipped.get()) {                				//We were not previously below the threshold, now we are...                				dipped.set(true);	                			int currentSmart=timesBelowThreshold.incrementAndGet();//	                			System.err.println("currentSmart is "+currentSmart+" at index "+index);	                			if(currentSmart==smartCount) {	                				setAlarmCondition();	                				timesBelowThreshold.set(0);	//Reset the count	                			}                			}                		}                	} else {                		point.nodeProperty().set(null);                		if(inAlarm) {	                		unsetAlarmCondition();                		} else {                			                		}                		if(dipped.get()) {                			//We were in a possible alarm state, but now aren't                			dipped.set(false);//                			System.err.println("set dipped to false at index at index "+index);                		}                	}        for(int i=0;i<x.size();i++) {        	series.get(0).getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        	try {				Thread.sleep(100);			} catch (InterruptedException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}        	s.getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        }        lineChart.getData().addAll(series);        lineChart.getData().add(s);
        Series<Number, Number> fourSecRepeated=new Series<>();
        fourSecRepeated.setName("4 sec avg");
        int overFour=s.getData().size()/4;
        for(int i=0;i<overFour;i++) {
        	float nextAve= ( y.get((i*4)+0) + y.get((i*4)+1) + y.get((i*4)+2) + y.get((i*4)+3) ) / 4;
        	for(int j=0;j<4;j++) {
        		fourSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*4)+j, nextAve));
        	}
        }
        series.add(fourSecRepeated);
        
        Series<Number, Number> eightSecRepeated=new Series<>();
        eightSecRepeated.setName("8 sec avg");
        int overEight=s.getData().size()/8;
        for(int i=0;i<overEight;i++) {
        	float nextAve= ( y.get((i*8)+0) + y.get((i*8)+1) + y.get((i*8)+2) + y.get((i*8)+3) +
        			y.get((i*8)+4) + y.get((i*8)+5) + y.get((i*8)+6) + y.get((i*8)+7)) / 8;
        	for(int j=0;j<8;j++) {
        		eightSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*8)+j, nextAve));
        	}
        }
        series.add(eightSecRepeated);

        Series<Number, Number> sixteenSecRepeated=new Series<>();
        sixteenSecRepeated.setName("16 sec avg");
        int overSixteen=s.getData().size()/16;
        for(int i=0;i<overSixteen;i++) {
        	float nextAve= ( y.get((i*16)+0) + y.get((i*16)+1) + y.get((i*16)+2) + y.get((i*16)+3) +
        			y.get((i*16)+4) + y.get((i*16)+5) + y.get((i*16)+6) + y.get((i*16)+7) +
        			y.get((i*16)+8) + y.get((i*16)+9) + y.get((i*16)+10) + y.get((i*16)+11) +
        			y.get((i*16)+12) + y.get((i*16)+13) + y.get((i*16)+14) + y.get((i*16)+15)) / 16;
        	for(int j=0;j<16;j++) {
        		sixteenSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*16)+j, nextAve));
        	}
        }
        series.add(sixteenSecRepeated);
        		System.err.println("Alarm condition ON");		System.err.println("Alarm condition OFF");No device selected and/or available - can happen when patient is changed and no devices for that patientSome other deviceWhen we get here, we are looking at a property for the currently selected device						Thread.dumpStack();Case 2Great - this is OK.  Store it somewhere maybe?4 and 5 combined - should "can you get the average" and "is it 4 seconds or less" be separate questions?IN THIS LOGIC, WE DON'T FIND OUT IF IT'S SETTABLE OR NOT.19th July...Can the operator set the average.
						 * Operator says they have set the average to 4.  In this branch of the code,
						 * ice cannot get the average, so we must just assume they have
						 Case 3Alert alert=new Alert(Alert.AlertType.ERROR,"The average rate for this device is not known",ButtonType.OK);alert.showAndWait();This is case 1 - ICE can get the averaging rate.Case 5Here, we are at case 6 - average is over the limitCan we set it?Case 10Case 7 - ICE cannot set.			if()Case 9 - Operator can set it.Case 8 - Average can't be set.			requestedAverage.setText("");We can't set the average, so disable the controlscurrentAverage should not be editable		Thread.dumpStack();*
	 * The max average rate that is "OK" to use in this app.  Should be configurable elsewhere?
	 *
	 * The "current" patient, used to determine if the patient has changed
	 How can we get "all oximetry devices"?  For now, just add all devices. TODO Auto-generated method stub TODO Auto-generated method stublog.info("udi " + c.unique_device_identifier + " is MRN=" + mrnPartition);
		            	 * The patient has definitely changed - even if the selected patient is "Unassigned",
		            	 * then that "Patient" has an ID
		            	 Nothing else to do.Patient has changeddeviceUdiToPatientMRN.put(c.unique_device_identifier, p);*
	 * Clear the current graph.  Refactored to allow invocation from a different event handler thread,
	 * using the standard check.  Which is possibly overkill (as we could likely just always call runLater
	 * even if we were on the GUI thread, but it does the job.
	 No chart yet - possibly/probably from an MDSEvent invocation.  Just return to avoid any exceptions.Also reset the backgroundsetInputFile(selected);else, cancelled...Mostly copied, to start with, from org.mdpnp.apps.testapps.chart.ChartMoved validation to the top, so we can avoid creating series etc. that we then don't useValidate the alarm thresholdValidate the smart alarm countSlightly different validation here, as this is not required.We will treat empty string as 0 and smartCount=0 as disabled.Any more validation?At start of run, reset and alarm condition from end of previous run        v.addListener(valueListener);        v.forEach((t)->add(t));Scan through y for upper and lower;Set y axis max to 100Slightly pad the lower limitUse round on the lower bound to force an integer value on the axis labelCreate a series that represents the alarm threshold.If we loop through our x and y values here, we can sleep or schedule an executor to do it later        ThreadLocal<Integer> i=new ThreadLocal<Integer>();        int i=0;Before possibly hitting an alarm condition, preserve the current backgroundTODO:  - Should we do "alarm condition detection" here or in a separate thread?Alarm handlingSmart alarms are disabled - simple alarm condition onlyThis is the transition pointSmart alarms are enabledDitch this later when we want alarm to stay on                			System.err.println("Calling unsetAlarmCondition with smart alarms enabled at point "+xx);UNCOMMENT THE NEXT LINE IF WE WANT SMART ALARM RESETS                			unsetAlarmCondition();                	if(yy<simpleThreshold) {                		//Simple alarm threshold - IF smart alarm is disabled                		if(smartCount==0) {                			//Smart alarms are disabled - just set the simple alarm condition                			if(inAlarm) {                				//Already alarm - remove nodes                				point.nodeProperty().set(null);                			}                			setAlarmCondition();                		} else {                			if(!dipped.get()) {                				//We were not previously below the threshold, now we are...                				dipped.set(true);	                			int currentSmart=timesBelowThreshold.incrementAndGet();//	                			System.err.println("currentSmart is "+currentSmart+" at index "+index);	                			if(currentSmart==smartCount) {	                				setAlarmCondition();	                				timesBelowThreshold.set(0);	//Reset the count	                			}                			}                		}                	} else {                		point.nodeProperty().set(null);                		if(inAlarm) {	                		unsetAlarmCondition();                		} else {                			                		}                		if(dipped.get()) {                			//We were in a possible alarm state, but now aren't                			dipped.set(false);//                			System.err.println("set dipped to false at index at index "+index);                		}                	}        for(int i=0;i<x.size();i++) {        	series.get(0).getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        	try {				Thread.sleep(100);			} catch (InterruptedException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}        	s.getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        }        lineChart.getData().addAll(series);        lineChart.getData().add(s);
        Series<Number, Number> fourSecRepeated=new Series<>();
        fourSecRepeated.setName("4 sec avg");
        int overFour=s.getData().size()/4;
        for(int i=0;i<overFour;i++) {
        	float nextAve= ( y.get((i*4)+0) + y.get((i*4)+1) + y.get((i*4)+2) + y.get((i*4)+3) ) / 4;
        	for(int j=0;j<4;j++) {
        		fourSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*4)+j, nextAve));
        	}
        }
        series.add(fourSecRepeated);
        
        Series<Number, Number> eightSecRepeated=new Series<>();
        eightSecRepeated.setName("8 sec avg");
        int overEight=s.getData().size()/8;
        for(int i=0;i<overEight;i++) {
        	float nextAve= ( y.get((i*8)+0) + y.get((i*8)+1) + y.get((i*8)+2) + y.get((i*8)+3) +
        			y.get((i*8)+4) + y.get((i*8)+5) + y.get((i*8)+6) + y.get((i*8)+7)) / 8;
        	for(int j=0;j<8;j++) {
        		eightSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*8)+j, nextAve));
        	}
        }
        series.add(eightSecRepeated);

        Series<Number, Number> sixteenSecRepeated=new Series<>();
        sixteenSecRepeated.setName("16 sec avg");
        int overSixteen=s.getData().size()/16;
        for(int i=0;i<overSixteen;i++) {
        	float nextAve= ( y.get((i*16)+0) + y.get((i*16)+1) + y.get((i*16)+2) + y.get((i*16)+3) +
        			y.get((i*16)+4) + y.get((i*16)+5) + y.get((i*16)+6) + y.get((i*16)+7) +
        			y.get((i*16)+8) + y.get((i*16)+9) + y.get((i*16)+10) + y.get((i*16)+11) +
        			y.get((i*16)+12) + y.get((i*16)+13) + y.get((i*16)+14) + y.get((i*16)+15)) / 16;
        	for(int j=0;j<16;j++) {
        		sixteenSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*16)+j, nextAve));
        	}
        }
        series.add(sixteenSecRepeated);
        		System.err.println("Alarm condition ON");		System.err.println("Alarm condition OFF");No device selected and/or available - can happen when patient is changed and no devices for that patientSome other deviceWhen we get here, we are looking at a property for the currently selected device						Thread.dumpStack();Case 2Great - this is OK.  Store it somewhere maybe?4 and 5 combined - should "can you get the average" and "is it 4 seconds or less" be separate questions?IN THIS LOGIC, WE DON'T FIND OUT IF IT'S SETTABLE OR NOT.19th July...Can the operator set the average.
						 * Operator says they have set the average to 4.  In this branch of the code,
						 * ice cannot get the average, so we must just assume they have
						 Case 3Alert alert=new Alert(Alert.AlertType.ERROR,"The average rate for this device is not known",ButtonType.OK);alert.showAndWait();This is case 1 - ICE can get the averaging rate.Case 5Here, we are at case 6 - average is over the limitCan we set it?Case 10Case 7 - ICE cannot set.			if()Case 9 - Operator can set it.Case 8 - Average can't be set.			requestedAverage.setText("");We can't set the average, so disable the controlscurrentAverage should not be editable		Thread.dumpStack();*
	 * The max average rate that is "OK" to use in this app.  Should be configurable elsewhere?
	 *
	 * The "current" patient, used to determine if the patient has changed
	 How can we get "all oximetry devices"?  For now, just add all devices. TODO Auto-generated method stub TODO Auto-generated method stublog.info("udi " + c.unique_device_identifier + " is MRN=" + mrnPartition);
		            	 * The patient has definitely changed - even if the selected patient is "Unassigned",
		            	 * then that "Patient" has an ID
		            	 Nothing else to do.Patient has changeddeviceUdiToPatientMRN.put(c.unique_device_identifier, p);*
	 * Clear the current graph.  Refactored to allow invocation from a different event handler thread,
	 * using the standard check.  Which is possibly overkill (as we could likely just always call runLater
	 * even if we were on the GUI thread, but it does the job.
	 No chart yet - possibly/probably from an MDSEvent invocation.  Just return to avoid any exceptions.Also reset the backgroundsetInputFile(selected);else, cancelled...Mostly copied, to start with, from org.mdpnp.apps.testapps.chart.ChartMoved validation to the top, so we can avoid creating series etc. that we then don't useValidate the alarm thresholdValidate the smart alarm countSlightly different validation here, as this is not required.We will treat empty string as 0 and smartCount=0 as disabled.Any more validation?At start of run, reset and alarm condition from end of previous run        v.addListener(valueListener);        v.forEach((t)->add(t));Scan through y for upper and lower;Set y axis max to 100Slightly pad the lower limitUse round on the lower bound to force an integer value on the axis labelCreate a series that represents the alarm threshold.If we loop through our x and y values here, we can sleep or schedule an executor to do it later        ThreadLocal<Integer> i=new ThreadLocal<Integer>();        int i=0;Before possibly hitting an alarm condition, preserve the current backgroundTODO:  - Should we do "alarm condition detection" here or in a separate thread?Alarm handlingSmart alarms are disabled - simple alarm condition onlyThis is the transition pointSmart alarms are enabledDitch this later when we want alarm to stay on                			System.err.println("Calling unsetAlarmCondition with smart alarms enabled at point "+xx);UNCOMMENT THE NEXT LINE IF WE WANT SMART ALARM RESETS                			unsetAlarmCondition();                	if(yy<simpleThreshold) {                		//Simple alarm threshold - IF smart alarm is disabled                		if(smartCount==0) {                			//Smart alarms are disabled - just set the simple alarm condition                			if(inAlarm) {                				//Already alarm - remove nodes                				point.nodeProperty().set(null);                			}                			setAlarmCondition();                		} else {                			if(!dipped.get()) {                				//We were not previously below the threshold, now we are...                				dipped.set(true);	                			int currentSmart=timesBelowThreshold.incrementAndGet();//	                			System.err.println("currentSmart is "+currentSmart+" at index "+index);	                			if(currentSmart==smartCount) {	                				setAlarmCondition();	                				timesBelowThreshold.set(0);	//Reset the count	                			}                			}                		}                	} else {                		point.nodeProperty().set(null);                		if(inAlarm) {	                		unsetAlarmCondition();                		} else {                			                		}                		if(dipped.get()) {                			//We were in a possible alarm state, but now aren't                			dipped.set(false);//                			System.err.println("set dipped to false at index at index "+index);                		}                	}        for(int i=0;i<x.size();i++) {        	series.get(0).getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        	try {				Thread.sleep(100);			} catch (InterruptedException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}        	s.getData().add(new XYChart.Data<Number, Number>(x.get(i), y.get(i)));        }        lineChart.getData().addAll(series);        lineChart.getData().add(s);
        Series<Number, Number> fourSecRepeated=new Series<>();
        fourSecRepeated.setName("4 sec avg");
        int overFour=s.getData().size()/4;
        for(int i=0;i<overFour;i++) {
        	float nextAve= ( y.get((i*4)+0) + y.get((i*4)+1) + y.get((i*4)+2) + y.get((i*4)+3) ) / 4;
        	for(int j=0;j<4;j++) {
        		fourSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*4)+j, nextAve));
        	}
        }
        series.add(fourSecRepeated);
        
        Series<Number, Number> eightSecRepeated=new Series<>();
        eightSecRepeated.setName("8 sec avg");
        int overEight=s.getData().size()/8;
        for(int i=0;i<overEight;i++) {
        	float nextAve= ( y.get((i*8)+0) + y.get((i*8)+1) + y.get((i*8)+2) + y.get((i*8)+3) +
        			y.get((i*8)+4) + y.get((i*8)+5) + y.get((i*8)+6) + y.get((i*8)+7)) / 8;
        	for(int j=0;j<8;j++) {
        		eightSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*8)+j, nextAve));
        	}
        }
        series.add(eightSecRepeated);

        Series<Number, Number> sixteenSecRepeated=new Series<>();
        sixteenSecRepeated.setName("16 sec avg");
        int overSixteen=s.getData().size()/16;
        for(int i=0;i<overSixteen;i++) {
        	float nextAve= ( y.get((i*16)+0) + y.get((i*16)+1) + y.get((i*16)+2) + y.get((i*16)+3) +
        			y.get((i*16)+4) + y.get((i*16)+5) + y.get((i*16)+6) + y.get((i*16)+7) +
        			y.get((i*16)+8) + y.get((i*16)+9) + y.get((i*16)+10) + y.get((i*16)+11) +
        			y.get((i*16)+12) + y.get((i*16)+13) + y.get((i*16)+14) + y.get((i*16)+15)) / 16;
        	for(int j=0;j<16;j++) {
        		sixteenSecRepeated.getData().add(new XYChart.Data<Number, Number>( (i*16)+j, nextAve));
        	}
        }
        series.add(sixteenSecRepeated);
        		System.err.println("Alarm condition ON");		System.err.println("Alarm condition OFF");No device selected and/or available - can happen when patient is changed and no devices for that patientSome other deviceWhen we get here, we are looking at a property for the currently selected device						Thread.dumpStack();Case 2Great - this is OK.  Store it somewhere maybe?4 and 5 combined - should "can you get the average" and "is it 4 seconds or less" be separate questions?IN THIS LOGIC, WE DON'T FIND OUT IF IT'S SETTABLE OR NOT.19th July...Can the operator set the average.
						 * Operator says they have set the average to 4.  In this branch of the code,
						 * ice cannot get the average, so we must just assume they have
						 Case 3Alert alert=new Alert(Alert.AlertType.ERROR,"The average rate for this device is not known",ButtonType.OK);alert.showAndWait();This is case 1 - ICE can get the averaging rate.Case 5Here, we are at case 6 - average is over the limitCan we set it?Case 10Case 7 - ICE cannot set.			if()Case 9 - Operator can set it.Case 8 - Average can't be set.			requestedAverage.setText("");We can't set the average, so disable the controlscurrentAverage should not be editable		Thread.dumpStack();