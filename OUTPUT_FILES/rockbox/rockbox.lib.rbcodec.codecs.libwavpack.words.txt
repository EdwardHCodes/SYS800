//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //////////////////////////////////////////////////////////////////////////// words.c This module provides entropy word encoding and decoding functions using a variation on the Rice method.  This was introduced in version 3.93 because it allows splitting the data into a "lossy" stream and a "correction" stream in a very efficient manner and is therefore ideal for the "hybrid" mode.  For 4.0, the efficiency of this method was significantly improved by moving away from the normal Rice restriction of using powers of two for the modulus divisions and now the method can be used for both hybrid and pure lossless encoding. Samples are divided by median probabilities at 5/7 (71.43%), 10/49 (20.41%), and 20/343 (5.83%). Each zone has 3.5 times fewer samples than the previous. Using standard Rice coding on this data would result in 1.4 bits per sample average (not counting sign bit). However, there is a very simple encoding that is over 99% efficient with this data and results in about 1.22 bits per sample.////////////////////////////// local macros ///////////////////////////////// maximum consecutive 1s sent for "div" data these control the time constant "slow_level" which is used for hybrid mode that controls bitrate as a function of residual level (HYBRID_BITRATE). these control the time constant of the 3 median level breakpoints 5/7 of samples 10/49 of samples 20/343 of samples this macro retrieves the specified median breakpoint (without frac; min = 1) These macros update the specified median breakpoints. Note that the median is incremented when the sample is higher than the median, else decremented. They are designed so that the median will never drop below 1 and the value is essentially stationary if there are 2 increments for every 5 decrements./////////////////////////// local table storage //////////////////////////// 0 - 15 16 - 31 32 - 47 48 - 63 64 - 79 80 - 95 96 - 111 112 - 127 128 - 143 144 - 159 160 - 175 176 - 191 192 - 207 208 - 223 224 - 239 240 - 255/////////////////////////// executable code //////////////////////////////// Read the median log2 values from the specifed metadata structure, convert them back to 32-bit unsigned values and store them. If length is not exactly correct then we flag and return an error. Allocates the correct space in the metadata structure and writes the current median values to it. Values are converted from 32-bit unsigned to our internal 16-bit mylog2 values, and read_entropy_vars () is called to read the values back because we must compensate for the loss through the log function. Read the hybrid related values from the specifed metadata structure, convert them back to their internal formats and store them. The extended profile stuff is not implemented yet, so return an error if we get more data than we know what to do with. This function is called during both encoding and decoding of hybrid data to update the "error_limit" variable which determines the maximum sample error allowed in the main bitstream. In the HYBRID_BITRATE mode (which is the only currently implemented) this is calculated from the slow_level values and the bitrate accumulators. Note that the bitrate accumulators can be changing. Read the next word from the bitstream "wvbits" and return the value. This function can be used for hybrid or lossless streams, but since an optimized version is available for lossless this function would normally be used for hybrid only. If a hybrid lossless stream is being read then the "correction" offset is written at the specified pointer. A return value of WORD_EOF indicates that the end of the bitstream was reached (all 1s) or some other error occurred. Read a single unsigned value from the specified bitstream with a value from 0 to maxcode. If there are exactly a power of two number of possible codes then this will read a fixed number of bits; otherwise it reads the minimum number of bits and then determines whether another bit is needed to define the code. Used by send_word() and send_word_lossless() to actually send most the accumulated data onto the bitstream. This is also called directly from clients when all words have been sent. The concept of a base 2 logarithm is used in many parts of WavPack. It is a way of sufficiently accurately representing 32-bit signed and unsigned values storing only 16 bits (actually fewer). It is also used in the hybrid mode for quickly comparing the relative magnitude of large values (i.e. division) and providing smooth exponentials using only addition. These are not strict logarithms in that they become linear around zero and can therefore represent both zero and negative values. They have 8 bits of precision and in "roundtrip" conversions the total error never exceeds 1 part in 225 except for the cases of +/-115 and +/-195 (which error by 1). This function returns the log2 for the specified 32-bit unsigned value. The maximum value allowed is about 0xff800000 and returns 8447. This function returns the log2 for the specified 32-bit signed value. All input values are valid and the return values are in the range of +/- 8192. This function returns the original integer represented by the supplied logarithm (at least within the provided accuracy). The log is signed, but since a full 32-bit value is returned this can be used for unsigned conversions as well (i.e. the input range is -8192 to +8447). These two functions convert internal weights (which are normally +/-1024) to and from an 8-bit signed character version for storage in metadata. The weights are clipped here in the case that they are outside that range.//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //////////////////////////////////////////////////////////////////////////// words.c This module provides entropy word encoding and decoding functions using a variation on the Rice method.  This was introduced in version 3.93 because it allows splitting the data into a "lossy" stream and a "correction" stream in a very efficient manner and is therefore ideal for the "hybrid" mode.  For 4.0, the efficiency of this method was significantly improved by moving away from the normal Rice restriction of using powers of two for the modulus divisions and now the method can be used for both hybrid and pure lossless encoding. Samples are divided by median probabilities at 5/7 (71.43%), 10/49 (20.41%), and 20/343 (5.83%). Each zone has 3.5 times fewer samples than the previous. Using standard Rice coding on this data would result in 1.4 bits per sample average (not counting sign bit). However, there is a very simple encoding that is over 99% efficient with this data and results in about 1.22 bits per sample.////////////////////////////// local macros ///////////////////////////////// maximum consecutive 1s sent for "div" data these control the time constant "slow_level" which is used for hybrid mode that controls bitrate as a function of residual level (HYBRID_BITRATE). these control the time constant of the 3 median level breakpoints 5/7 of samples 10/49 of samples 20/343 of samples this macro retrieves the specified median breakpoint (without frac; min = 1) These macros update the specified median breakpoints. Note that the median is incremented when the sample is higher than the median, else decremented. They are designed so that the median will never drop below 1 and the value is essentially stationary if there are 2 increments for every 5 decrements./////////////////////////// local table storage //////////////////////////// 0 - 15 16 - 31 32 - 47 48 - 63 64 - 79 80 - 95 96 - 111 112 - 127 128 - 143 144 - 159 160 - 175 176 - 191 192 - 207 208 - 223 224 - 239 240 - 255/////////////////////////// executable code //////////////////////////////// Read the median log2 values from the specifed metadata structure, convert them back to 32-bit unsigned values and store them. If length is not exactly correct then we flag and return an error. Allocates the correct space in the metadata structure and writes the current median values to it. Values are converted from 32-bit unsigned to our internal 16-bit mylog2 values, and read_entropy_vars () is called to read the values back because we must compensate for the loss through the log function. Read the hybrid related values from the specifed metadata structure, convert them back to their internal formats and store them. The extended profile stuff is not implemented yet, so return an error if we get more data than we know what to do with. This function is called during both encoding and decoding of hybrid data to update the "error_limit" variable which determines the maximum sample error allowed in the main bitstream. In the HYBRID_BITRATE mode (which is the only currently implemented) this is calculated from the slow_level values and the bitrate accumulators. Note that the bitrate accumulators can be changing. Read the next word from the bitstream "wvbits" and return the value. This function can be used for hybrid or lossless streams, but since an optimized version is available for lossless this function would normally be used for hybrid only. If a hybrid lossless stream is being read then the "correction" offset is written at the specified pointer. A return value of WORD_EOF indicates that the end of the bitstream was reached (all 1s) or some other error occurred. Read a single unsigned value from the specified bitstream with a value from 0 to maxcode. If there are exactly a power of two number of possible codes then this will read a fixed number of bits; otherwise it reads the minimum number of bits and then determines whether another bit is needed to define the code. Used by send_word() and send_word_lossless() to actually send most the accumulated data onto the bitstream. This is also called directly from clients when all words have been sent. The concept of a base 2 logarithm is used in many parts of WavPack. It is a way of sufficiently accurately representing 32-bit signed and unsigned values storing only 16 bits (actually fewer). It is also used in the hybrid mode for quickly comparing the relative magnitude of large values (i.e. division) and providing smooth exponentials using only addition. These are not strict logarithms in that they become linear around zero and can therefore represent both zero and negative values. They have 8 bits of precision and in "roundtrip" conversions the total error never exceeds 1 part in 225 except for the cases of +/-115 and +/-195 (which error by 1). This function returns the log2 for the specified 32-bit unsigned value. The maximum value allowed is about 0xff800000 and returns 8447. This function returns the log2 for the specified 32-bit signed value. All input values are valid and the return values are in the range of +/- 8192. This function returns the original integer represented by the supplied logarithm (at least within the provided accuracy). The log is signed, but since a full 32-bit value is returned this can be used for unsigned conversions as well (i.e. the input range is -8192 to +8447). These two functions convert internal weights (which are normally +/-1024) to and from an 8-bit signed character version for storage in metadata. The weights are clipped here in the case that they are outside that range.//////////////////////////////////////////////////////////////////////////                           **** WAVPACK ****                            //                  Hybrid Lossless Wavefile Compressor                   //              Copyright (c) 1998 - 2004 Conifer Software.               //                          All Rights Reserved.                          //////////////////////////////////////////////////////////////////////////// words.c This module provides entropy word encoding and decoding functions using a variation on the Rice method.  This was introduced in version 3.93 because it allows splitting the data into a "lossy" stream and a "correction" stream in a very efficient manner and is therefore ideal for the "hybrid" mode.  For 4.0, the efficiency of this method was significantly improved by moving away from the normal Rice restriction of using powers of two for the modulus divisions and now the method can be used for both hybrid and pure lossless encoding. Samples are divided by median probabilities at 5/7 (71.43%), 10/49 (20.41%), and 20/343 (5.83%). Each zone has 3.5 times fewer samples than the previous. Using standard Rice coding on this data would result in 1.4 bits per sample average (not counting sign bit). However, there is a very simple encoding that is over 99% efficient with this data and results in about 1.22 bits per sample.////////////////////////////// local macros ///////////////////////////////// maximum consecutive 1s sent for "div" data these control the time constant "slow_level" which is used for hybrid mode that controls bitrate as a function of residual level (HYBRID_BITRATE). these control the time constant of the 3 median level breakpoints 5/7 of samples 10/49 of samples 20/343 of samples this macro retrieves the specified median breakpoint (without frac; min = 1) These macros update the specified median breakpoints. Note that the median is incremented when the sample is higher than the median, else decremented. They are designed so that the median will never drop below 1 and the value is essentially stationary if there are 2 increments for every 5 decrements./////////////////////////// local table storage //////////////////////////// 0 - 15 16 - 31 32 - 47 48 - 63 64 - 79 80 - 95 96 - 111 112 - 127 128 - 143 144 - 159 160 - 175 176 - 191 192 - 207 208 - 223 224 - 239 240 - 255/////////////////////////// executable code //////////////////////////////// Read the median log2 values from the specifed metadata structure, convert them back to 32-bit unsigned values and store them. If length is not exactly correct then we flag and return an error. Allocates the correct space in the metadata structure and writes the current median values to it. Values are converted from 32-bit unsigned to our internal 16-bit mylog2 values, and read_entropy_vars () is called to read the values back because we must compensate for the loss through the log function. Read the hybrid related values from the specifed metadata structure, convert them back to their internal formats and store them. The extended profile stuff is not implemented yet, so return an error if we get more data than we know what to do with. This function is called during both encoding and decoding of hybrid data to update the "error_limit" variable which determines the maximum sample error allowed in the main bitstream. In the HYBRID_BITRATE mode (which is the only currently implemented) this is calculated from the slow_level values and the bitrate accumulators. Note that the bitrate accumulators can be changing. Read the next word from the bitstream "wvbits" and return the value. This function can be used for hybrid or lossless streams, but since an optimized version is available for lossless this function would normally be used for hybrid only. If a hybrid lossless stream is being read then the "correction" offset is written at the specified pointer. A return value of WORD_EOF indicates that the end of the bitstream was reached (all 1s) or some other error occurred. Read a single unsigned value from the specified bitstream with a value from 0 to maxcode. If there are exactly a power of two number of possible codes then this will read a fixed number of bits; otherwise it reads the minimum number of bits and then determines whether another bit is needed to define the code. Used by send_word() and send_word_lossless() to actually send most the accumulated data onto the bitstream. This is also called directly from clients when all words have been sent. The concept of a base 2 logarithm is used in many parts of WavPack. It is a way of sufficiently accurately representing 32-bit signed and unsigned values storing only 16 bits (actually fewer). It is also used in the hybrid mode for quickly comparing the relative magnitude of large values (i.e. division) and providing smooth exponentials using only addition. These are not strict logarithms in that they become linear around zero and can therefore represent both zero and negative values. They have 8 bits of precision and in "roundtrip" conversions the total error never exceeds 1 part in 225 except for the cases of +/-115 and +/-195 (which error by 1). This function returns the log2 for the specified 32-bit unsigned value. The maximum value allowed is about 0xff800000 and returns 8447. This function returns the log2 for the specified 32-bit signed value. All input values are valid and the return values are in the range of +/- 8192. This function returns the original integer represented by the supplied logarithm (at least within the provided accuracy). The log is signed, but since a full 32-bit value is returned this can be used for unsigned conversions as well (i.e. the input range is -8192 to +8447). These two functions convert internal weights (which are normally +/-1024) to and from an 8-bit signed character version for storage in metadata. The weights are clipped here in the case that they are outside that range.