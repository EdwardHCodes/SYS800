**************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * Copyright (C) 2002 by Linus Nielsen Feltzing
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 ***************************************************************************
2005-04-16 Tomas Salfischberger:
 - New BMP loader function, based on the old one (borrowed a lot of
   calculations and checks there.)
 - Conversion part needs some optimization, doing unneeded calulations now.
2006-11-18 Jens Arnold: complete rework
 - All canonical formats supported now (1, 4, 8, 15/16, 24 and 32 bit)
 - better protection against malformed / non-standard BMPs
 - code heavily optimised for both size and speed
 - dithering for 2 bit targets
2008-11-02 Akio Idehara: refactor for scaler frontend
2008-12-08 Andrew Mahone: partial-line reading, scaler frontend
 - read_part_line does the actual source BMP reading, return columns read
   and updates fields in a struct bmp_args with the new data and current
   reader state
 - skip_lines_bmp and store_part_bmp implement the scaler callbacks to skip
   ahead by whole lines, or read the next chunk of the current line
 BMP header structure  signature - 'BM'  file size in bytes  0  0  offset to bitmap  size of this struct (40)  bmap width in pixels  bmap height in pixels  num planes - always 1  bits per pixel  compression flag  image size in bytes  horz resolution  vert resolution  0 -> color table size  important color count  masks for supported BI_BITFIELDS encodings (16/32 bit)  15bit  16bit  32bit BGRA  32bit ABGR  the full 16x16 Bayer dither matrix may be calculated quickly with this table
*****************************************************************************
 * read_bmp_file()
 *
 * Reads a BMP file and puts the data in rockbox format in *bitmap.
 *
 **************************************************************************** Exit if file opening failed  only used for different types of 32bpp images  should be most common  generated by some GIMP versions  needs to be at least 2byte aligned for faster 16bit reads.
     * but aligning to cache should be even faster  as read_part_line() goes through the rows it'll set this to true
     * if it finds transparency. Initialize to 0 before calling  for checking transparency it checks the against the very first byte
     * of the bitmap. Initalize to 0x80 before calling  detect if the image has useful alpha information.
     * if all alpha bits are 0xff or 0x00 discard the information.
     * if it has other bits, or is mixed with 0x00 and 0xff then interpret
     * as alpha. assume no alpha until the opposite is proven. as mixed
     * is alpha, compare to the first byte instead of 0xff and 0x00 separately
      select different color orders within the switch-case to avoid
      * nested if/switch  greyscale iPods  iriver H1x0  iAudio M3  LCD_PIXELFORMAT  iriver h300, colour iPods, X5  setup alpha channel buffer  pack alpha channel for 2 pixels into 1 byte and negate
                         * according to the interal alpha channel format  LCD_DEPTH *****************************************************************************
 * read_bmp_fd()
 *
 * Reads a BMP file in an open file descriptor and puts the data in rockbox
 * format in *bitmap.
 *
 **************************************************************************** HAVE_REMOTE_LCD (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) && (LCD_REMOTE_DEPTH > 1) read fileheader  Top-down BMP file  normal BMP  4-byte boundary aligned (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) && (LCD_REMOTE_DEPTH > 1) keep aspect ratio..  returning image size  Top-down BMP file  normal BMP  need even rows (see lcd-16bit-common.c for details)  account for possible 4bit alpha per pixel  Check if this fits the buffer  forward to the color table  hdr_size == 52  read color tables. for BI_BITFIELDS this actually
     * reads the color masks  don't dither 16 bit BMP to LCD with same or larger depth  BI_RGB, i.e. 15 bit  else fall through  BI_BITFIELDS  (i == 0) is 15bit, (i == 1) is 16bit, (i == {2,3}) is 32bit  for 15bpp and higher numcolors has the number of color masks  15bit  32bit, ABGR bitmap  else fall through  not BI_RGB  Never dither 24/32 bit BMP to 24 bit LCDs  Search to the beginning of the image data  LCD_DEPTH  loop to read rows and put them to buffer  Convert to destination format  iAudio X5/M5 remote  LCD_REMOTE_DEPTH / LCD_REMOTE_PIXELFORMAT  defined(HAVE_REMOTE_LCD) && LCD_REMOTE_DEPTH > 1  (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) &&
    (LCD_REMOTE_DEPTH > 1)  if this has an alpha channel, totalsize accounts for it as well
         * subtract if no actual alpha information was found  return the used buffer size. **************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * Copyright (C) 2002 by Linus Nielsen Feltzing
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 ***************************************************************************
2005-04-16 Tomas Salfischberger:
 - New BMP loader function, based on the old one (borrowed a lot of
   calculations and checks there.)
 - Conversion part needs some optimization, doing unneeded calulations now.
2006-11-18 Jens Arnold: complete rework
 - All canonical formats supported now (1, 4, 8, 15/16, 24 and 32 bit)
 - better protection against malformed / non-standard BMPs
 - code heavily optimised for both size and speed
 - dithering for 2 bit targets
2008-11-02 Akio Idehara: refactor for scaler frontend
2008-12-08 Andrew Mahone: partial-line reading, scaler frontend
 - read_part_line does the actual source BMP reading, return columns read
   and updates fields in a struct bmp_args with the new data and current
   reader state
 - skip_lines_bmp and store_part_bmp implement the scaler callbacks to skip
   ahead by whole lines, or read the next chunk of the current line
 BMP header structure  signature - 'BM'  file size in bytes  0  0  offset to bitmap  size of this struct (40)  bmap width in pixels  bmap height in pixels  num planes - always 1  bits per pixel  compression flag  image size in bytes  horz resolution  vert resolution  0 -> color table size  important color count  masks for supported BI_BITFIELDS encodings (16/32 bit)  15bit  16bit  32bit BGRA  32bit ABGR  the full 16x16 Bayer dither matrix may be calculated quickly with this table
*****************************************************************************
 * read_bmp_file()
 *
 * Reads a BMP file and puts the data in rockbox format in *bitmap.
 *
 **************************************************************************** Exit if file opening failed  only used for different types of 32bpp images  should be most common  generated by some GIMP versions  needs to be at least 2byte aligned for faster 16bit reads.
     * but aligning to cache should be even faster  as read_part_line() goes through the rows it'll set this to true
     * if it finds transparency. Initialize to 0 before calling  for checking transparency it checks the against the very first byte
     * of the bitmap. Initalize to 0x80 before calling  detect if the image has useful alpha information.
     * if all alpha bits are 0xff or 0x00 discard the information.
     * if it has other bits, or is mixed with 0x00 and 0xff then interpret
     * as alpha. assume no alpha until the opposite is proven. as mixed
     * is alpha, compare to the first byte instead of 0xff and 0x00 separately
      select different color orders within the switch-case to avoid
      * nested if/switch  greyscale iPods  iriver H1x0  iAudio M3  LCD_PIXELFORMAT  iriver h300, colour iPods, X5  setup alpha channel buffer  pack alpha channel for 2 pixels into 1 byte and negate
                         * according to the interal alpha channel format  LCD_DEPTH *****************************************************************************
 * read_bmp_fd()
 *
 * Reads a BMP file in an open file descriptor and puts the data in rockbox
 * format in *bitmap.
 *
 **************************************************************************** HAVE_REMOTE_LCD (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) && (LCD_REMOTE_DEPTH > 1) read fileheader  Top-down BMP file  normal BMP  4-byte boundary aligned (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) && (LCD_REMOTE_DEPTH > 1) keep aspect ratio..  returning image size  Top-down BMP file  normal BMP  need even rows (see lcd-16bit-common.c for details)  account for possible 4bit alpha per pixel  Check if this fits the buffer  forward to the color table  hdr_size == 52  read color tables. for BI_BITFIELDS this actually
     * reads the color masks  don't dither 16 bit BMP to LCD with same or larger depth  BI_RGB, i.e. 15 bit  else fall through  BI_BITFIELDS  (i == 0) is 15bit, (i == 1) is 16bit, (i == {2,3}) is 32bit  for 15bpp and higher numcolors has the number of color masks  15bit  32bit, ABGR bitmap  else fall through  not BI_RGB  Never dither 24/32 bit BMP to 24 bit LCDs  Search to the beginning of the image data  LCD_DEPTH  loop to read rows and put them to buffer  Convert to destination format  iAudio X5/M5 remote  LCD_REMOTE_DEPTH / LCD_REMOTE_PIXELFORMAT  defined(HAVE_REMOTE_LCD) && LCD_REMOTE_DEPTH > 1  (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) &&
    (LCD_REMOTE_DEPTH > 1)  if this has an alpha channel, totalsize accounts for it as well
         * subtract if no actual alpha information was found  return the used buffer size. **************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * Copyright (C) 2002 by Linus Nielsen Feltzing
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 ***************************************************************************
2005-04-16 Tomas Salfischberger:
 - New BMP loader function, based on the old one (borrowed a lot of
   calculations and checks there.)
 - Conversion part needs some optimization, doing unneeded calulations now.
2006-11-18 Jens Arnold: complete rework
 - All canonical formats supported now (1, 4, 8, 15/16, 24 and 32 bit)
 - better protection against malformed / non-standard BMPs
 - code heavily optimised for both size and speed
 - dithering for 2 bit targets
2008-11-02 Akio Idehara: refactor for scaler frontend
2008-12-08 Andrew Mahone: partial-line reading, scaler frontend
 - read_part_line does the actual source BMP reading, return columns read
   and updates fields in a struct bmp_args with the new data and current
   reader state
 - skip_lines_bmp and store_part_bmp implement the scaler callbacks to skip
   ahead by whole lines, or read the next chunk of the current line
 BMP header structure  signature - 'BM'  file size in bytes  0  0  offset to bitmap  size of this struct (40)  bmap width in pixels  bmap height in pixels  num planes - always 1  bits per pixel  compression flag  image size in bytes  horz resolution  vert resolution  0 -> color table size  important color count  masks for supported BI_BITFIELDS encodings (16/32 bit)  15bit  16bit  32bit BGRA  32bit ABGR  the full 16x16 Bayer dither matrix may be calculated quickly with this table
*****************************************************************************
 * read_bmp_file()
 *
 * Reads a BMP file and puts the data in rockbox format in *bitmap.
 *
 **************************************************************************** Exit if file opening failed  only used for different types of 32bpp images  should be most common  generated by some GIMP versions  needs to be at least 2byte aligned for faster 16bit reads.
     * but aligning to cache should be even faster  as read_part_line() goes through the rows it'll set this to true
     * if it finds transparency. Initialize to 0 before calling  for checking transparency it checks the against the very first byte
     * of the bitmap. Initalize to 0x80 before calling  detect if the image has useful alpha information.
     * if all alpha bits are 0xff or 0x00 discard the information.
     * if it has other bits, or is mixed with 0x00 and 0xff then interpret
     * as alpha. assume no alpha until the opposite is proven. as mixed
     * is alpha, compare to the first byte instead of 0xff and 0x00 separately
      select different color orders within the switch-case to avoid
      * nested if/switch  greyscale iPods  iriver H1x0  iAudio M3  LCD_PIXELFORMAT  iriver h300, colour iPods, X5  setup alpha channel buffer  pack alpha channel for 2 pixels into 1 byte and negate
                         * according to the interal alpha channel format  LCD_DEPTH *****************************************************************************
 * read_bmp_fd()
 *
 * Reads a BMP file in an open file descriptor and puts the data in rockbox
 * format in *bitmap.
 *
 **************************************************************************** HAVE_REMOTE_LCD (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) && (LCD_REMOTE_DEPTH > 1) read fileheader  Top-down BMP file  normal BMP  4-byte boundary aligned (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) && (LCD_REMOTE_DEPTH > 1) keep aspect ratio..  returning image size  Top-down BMP file  normal BMP  need even rows (see lcd-16bit-common.c for details)  account for possible 4bit alpha per pixel  Check if this fits the buffer  forward to the color table  hdr_size == 52  read color tables. for BI_BITFIELDS this actually
     * reads the color masks  don't dither 16 bit BMP to LCD with same or larger depth  BI_RGB, i.e. 15 bit  else fall through  BI_BITFIELDS  (i == 0) is 15bit, (i == 1) is 16bit, (i == {2,3}) is 32bit  for 15bpp and higher numcolors has the number of color masks  15bit  32bit, ABGR bitmap  else fall through  not BI_RGB  Never dither 24/32 bit BMP to 24 bit LCDs  Search to the beginning of the image data  LCD_DEPTH  loop to read rows and put them to buffer  Convert to destination format  iAudio X5/M5 remote  LCD_REMOTE_DEPTH / LCD_REMOTE_PIXELFORMAT  defined(HAVE_REMOTE_LCD) && LCD_REMOTE_DEPTH > 1  (LCD_DEPTH > 1) || defined(HAVE_REMOTE_LCD) &&
    (LCD_REMOTE_DEPTH > 1)  if this has an alpha channel, totalsize accounts for it as well
         * subtract if no actual alpha information was found  return the used buffer size. 