
 * Windows Media Audio Voice decoder.
 * Copyright (c) 2009 Ronald S. Bultje
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * @file
 * @brief Windows Media Audio Voice compatible decoder
 * @author Ronald S. Bultje <rsbultje@gmail.com>
 /< maximum number of blocks per frame/< maximum filter order/< same as #MAX_LSPS; needs to be multiple/< of 16 for ASM input buffer alignment/< maximum number of frames per superframe/< maximum number of samples per frame/< maximum excitation signal history/< maximum number of samples per superframe/< maximum cache size for frame data that/< was split over two packets/< number of bits to read per VLC iteration*
 * Frame type VLC coding.
 *
 * Adaptive codebook types.
 /< no adaptive codebook (only hardcoded fixed)/< adaptive codebook with per-frame pitch, which/< we interpolate to get a per-sample pitch./< Signal is generated using an asymmetric sinc/< window function/< @note see #wmavoice_ipol1_coeffs/< Per-block pitch with signal generation using/< a Hamming sinc window function/< @note see #wmavoice_ipol2_coeffs*
 * Fixed codebook types.
 /< comfort noise during silence/< generated from a hardcoded (fixed) codebook/< with per-frame (low) gain values/< hardcoded (fixed) codebook with per-block/< gain values/< Pitch-adaptive window (AW) pulse signals,/< used in particular for low-bitrate streams/< Innovation (fixed) codebook pulse sets in/< combinations of either single pulses or/< pulse pairs*
 * Description of frame types.
 /< amount of blocks per frame (each block/< (contains 160/#n_blocks samples)/< log2(#n_blocks)/< Adaptive codebook type (ACB_TYPE_*)/< Fixed codebook type (FCB_TYPE_*)/< how many pulse vectors have pulse pairs/< (rather than just one single pulse)/< only if #fcb_type == #FCB_TYPE_EXC_PULSES/< the amount of bits that make up the block/< data (per frame)*
 * WMA Voice decoding context.
 *
     * @defgroup struct_global Global values
     * Global values, specified in the stream header / extradata or used
     * all over.
     * @{
     /< packet bitreader. During decoder init,/< it contains the extradata from the/< demuxer. During decoding, it contains/< packet data./< converts VLC codes to frame type/< number of bits used to specify/< #spillover_nbits in the packet header/< = ceil(log2(ctx->block_align << 3))/< number of samples in history for signal/< prediction (through ACB) postfilter specific values /< whether to apply the averaged/< projection filter (APF)/< strength of denoising in Wiener filter/< [0-11]/< Whether to apply tilt correction to the/< Wiener filter coefficients (postfilter)/< Predicted amount of DC noise, based/< on which a DC removal filter is used/< number of LSPs per frame [10 or 16]/< defines quantizer defaults [0, 1]/< defines different sets of LSP defaults/< [0, 1]/< size (in bits) of LSPs, when encoded/< per-frame (independent coding)/< size (in bits) of LSPs, when encoded/< per superframe (residual coding)/< base value for pitch parsing code/< max value + 1 for pitch parsing/< number of bits used to specify the/< pitch value in the frame header/< number of bits used to specify the/< first block's pitch value/< range of the block pitch/< number of bits used to specify the/< delta pitch between this and the last/< block's pitch value, used in all but/< first block/< 1/2 range of the delta (full range is/< from -this to +this-1)/< boundaries for block pitch unit/scale/< conversion*
     * @}
     * @defgroup struct_packet Packet values
     * Packet values, specified in the packet header or related to a packet.
     * A packet is considered to be a single unit of data provided to this
     * decoder by the demuxer.
     * @{
     /< number of bits of the previous packet's/< last superframe preceeding this/< packet's first full superframe (useful/< for re-synchronization also)/< if set, superframes contain one set of/< LSPs that cover all frames, encoded as/< independent and residual LSPs; if not/< set, each frame contains its own, fully/< independent, LSPs/< number of bits to skip at the next call/< to #wmavoice_decode_packet() (since/< they're part of the previous superframe)/< cache for superframe data split over/< multiple packets/< set to >0 if we have data from an/< (incomplete) superframe from a previous/< packet that spilled over in the current/< packet; specifies the amount of bits in/< #sframe_cache/< bitstream writer for #sframe_cache*
     * @}
     * @defgroup struct_frame Frame and superframe values
     * Superframe and frame data - these can change from frame to frame,
     * although some of them do in that case serve as a cache / history for
     * the next frame or superframe.
     * @{
     /< LSPs of the last frame of the previous/< superframe/< pitch value of the previous frame/< frame type [0-2] of the previous frame/< ((cur_pitch_val - #last_pitch_val)/< << 16) / #MAX_FRAMESIZE/< set for use in blocks if #ACB_TYPE_NONE/< whether the AW index was encoded in/< 8 bits (instead of 6)/< the range over which #aw_pulse_set1()/< can apply the pulse, relative to the/< value in aw_first_pulse_off. The exact/< position of the first AW-pulse is within/< [pulse_off, pulse_off + this], and/< depends on bitstream values; [16 or 24]/< number of AW-pulses in each block; note/< that this number can be negative (in/< which case it basically means "zero")/< index of first sample to which to/< apply AW-pulses, or -0xff if unset/< the position (relative to start of the/< second block) at which pulses should/< start to be positioned, serves as a/< cache for pitch-adaptive window pulses/< between blocks/< current frame index [0 - 0xFFFE]; is/< only used for comfort noise in #pRNG()/< cache for gain prediction/< cache of the signal of previous/< superframes, used as a history for/< signal generation/< see #excitation_history*
     * @}
     * @defgroup post_filter Postfilter values
     * Varibales used for postfilter implementation, mostly history for
     * smoothing and so on, and context variables for FFT/iFFT.
     * @{
     /< contexts for FFT-calculation in the/< postfilter (for denoise filter)/< contexts for phase shift (in Hilbert/< transform, part of postfilter)/< 8-bit cosine/sine windows over [-pi,pi]/< range/< gain control memory, used in/< #adaptive_gain_control()/< DC filter history/< zero filter output (i.e. excitation)/< by postfilter/< samples in #denoise_filter_cache/< aligned buffer for LPC tilting/< aligned buffer for denoise coefficients/< aligned buffer for postfilter speech/< synthesis*
     * @}
      global decode context *
 * Set up the variable bit mode (VBM) tree from container extradata.
 * @param gb bit I/O context.
 *           The bit context (s->gb) should be loaded with byte 23-46 of the
 *           container extradata (i.e. the ones containing the VBM tree).
 * @param vbm_tree pointer to array to which the decoded VBM tree will be
 *                 written.
 * @return 0 on success, <0 on error.
               00/01/10           11+00/01/10         1111+00/01/10       111111+00/01/10     11111111+00/01/10   1111111111+00/01/10 111111111111+xx should be >= 3 + (res == 7))*
 * Set up decoder with parameters from demuxer (extradata etc.).
 *
     * Extradata layout:
     * - byte  0-18: WMAPro-in-WMAVoice extradata (see wmaprodec.c),
     * - byte 19-22: flags field (annoyingly in LE; see below for known
     *               values),
     * - byte 23-46: variable bitmode tree (really just 17 * 3 bits,
     *               rest is 0).
      322-22097 Hz*
 * @defgroup postfilter Postfilter functions
 * Postfilter functions (gain control, wiener denoise filter, DC filter,
 * kalman smoothening, plus surrounding code to wrap it)
 * @{
 *
 * Adaptive gain control (as used in postfilter).
 *
 * Identical to #ff_adaptive_gain_control() in acelp_vectors.c, except
 * that the energy here is calculated using sum(abs(...)), whereas the
 * other codecs (e.g. AMR-NB, SIPRO) use sqrt(dotproduct(...)).
 *
 * @param out output buffer for filtered samples
 * @param in input buffer containing the samples as they are after the
 *           postfilter steps so far
 * @param speech_synth input buffer containing speech synth before postfilter
 * @param size input buffer size
 * @param alpha exponential filter factor
 * @param gain_mem pointer to filter memory (single float)
 *
 * Kalman smoothing function.
 *
 * This function looks back pitch +/- 3 samples back into history to find
 * the best fitting curve (that one giving the optimal gain of the two
 * signals, i.e. the highest dot product between the two), and then
 * uses that signal history to smoothen the output of the speech synthesis
 * filter.
 *
 * @param s WMA Voice decoding context
 * @param pitch pitch of the speech signal
 * @param in input speech signal
 * @param out output pointer for smoothened signal
 * @param size input/output buffer size
 *
 * @returns -1 if no smoothening took place, e.g. because no optimal
 *          fit could be found, or 0 on success.
  find best fitting point in history  would be 1.0 0.625-1.000 actual smoothing *
 * Get the tilt factor of a formant filter from its transfer function
 * @see #tilt_factor() in amrnbdec.c, which does essentially the same,
 *      but somehow (??) it does a speech synthesis filter in the
 *      middle, which is missing here
 *
 * @param lpcs LPC coefficients
 * @param n_lpcs Size of LPC buffer
 * @returns the tilt factor
 *
 * Derive denoise filter coefficients (in real domain) from the LPCs.
  Create frequency power spectrum of speech input (i.e. RDFT of LPCs)  Now, use this spectrum to pick out these frequencies with higher
     * (relative) power/energy (which we then take to be "not noise"),
     * and set up a table (still in lpc[]) of (relative) gains per frequency.
     * These frequencies will be maintained, while others ("noise") will be
     * decreased in the filter output.  so irange*(max-value) is in the range [0, 63] 70.57 =~ 1/log10(1.0331663)  fallback if index falls outside table range calculate the Hilbert transform of the gains, which we do (since this
     * is a sinus input) by doing a phase shift (in theory, H(sin())=cos()).
     * Hilbert_Transform(RDFT(x)) = Laplace_Transform(x), which calculates the
     * "moment" of the LPCs in this filter.  Split out the coefficient indexes into phase/magnitude pairs  move into real domain  tilt correction and normalize scale *
 * This function applies a Wiener filter on the (noisy) speech signal as
 * a means to denoise it.
 *
 * - take RDFT of LPCs to get the power spectrum of the noise + speech;
 * - using this power spectrum, calculate (for each frequency) the Wiener
 *    filter gain, which depends on the frequency power and desired level
 *    of noise subtraction (when set too high, this leads to artifacts)
 *    We can do this symmetrically over the X-axis (so 0-4kHz is the inverse
 *    of 4-8kHz);
 * - by doing a phase shift, calculate the Hilbert transform of this array
 *    of per-frequency filter-gains to get the filtering coefficients;
 * - smoothen/normalize/de-tilt these filter coefficients as desired;
 * - take RDFT of noisy sound, apply the coefficients and take its IRDFT
 *    to get the denoised speech signal;
 * - the leftover (i.e. output of the IRDFT on denoised speech data beyond
 *    the frame boundary) are saved and applied to subsequent frames by an
 *    overlap-add method (otherwise you get clicking-artifacts).
 *
 * @param s WMA Voice decoding context
 * @param fcb_type Frame (codebook) type
 * @param synth_pf input: the noisy speech signal, output: denoised speech
 *                 data; should be 16-byte aligned (for ASM purposes)
 * @param size size of the speech data
 * @param lpcs LPCs used to synthesize this frame's speech data
  The IRDFT output (127 samples for 7-bit filter) beyond the frame
         * size is applied to the next frame. All input beyond this is zero,
         * and thus all output beyond this will go towards zero, hence we can
         * limit to min(size-1, 127-size) as a performance consideration.  apply coefficients (in frequency spectrum domain), i.e. complex
         * number multiplication  merge filter output with the history of previous runs  move remainder of filter output into a cache for future runs *
 * Averaging projection filter, the postfilter used in WMAVoice.
 *
 * This uses the following steps:
 * - A zero-synthesis filter (generate excitation from synth signal)
 * - Kalman smoothing on excitation, based on pitch
 * - Re-synthesized smoothened output
 * - Iterative Wiener denoise filter
 * - Adaptive gain filter
 * - DC filter
 *
 * @param s WMAVoice decoding context
 * @param synth Speech synthesis output (before postfilter)
 * @param samples Output buffer for filtered samples
 * @param size Buffer size of synth & samples
 * @param lpcs Generated LPCs used for speech synthesis
 * @param zero_exc_pf destination for zero synthesis filter (16-byte aligned)
 * @param fcb_type Frame type (silence, hardcoded, AW-pulses or FCB-pulses)
 * @param pitch Pitch of the input signal
  generate excitation from input signal  re-synthesize speech after smoothening, and keep history  remove ultra-low frequency DC noise / highpass filter;
         * coefficients are identical to those used in SIPR decoding,
         * and very closely resemble those used in AMR-NB decoding. *
 * @}
 *
 * Dequantize LSPs
 * @param lsps output pointer to the array that will hold the LSPs
 * @param num number of LSPs to be dequantized
 * @param values quantized values, contains n_stages values
 * @param sizes range (i.e. max value) of each quantized value
 * @param n_stages number of dequantization runs
 * @param table dequantization table to be used
 * @param mul_q LSF multiplier
 * @param base_q base (lowest) LSF values
 *
 * @defgroup lsp_dequant LSP dequantization routines
 * LSP dequantization routines, for 10/16LSPs and independent/residual coding.
 * @note we assume enough bits are available, caller should check.
 * lsp10i() consumes 24 bits; lsp10r() consumes an additional 24 bits;
 * lsp16i() consumes 34 bits; lsp16r() consumes an additional 26 bits.
 * @{
 *
 * Parse 10 independently-coded LSPs.
 *
 * Parse 10 independently-coded LSPs, and then derive the tables to
 * generate LSPs for the other frames from them (residual coding).
 *
 * Parse 16 independently-coded LSPs.
 *
 * Parse 16 independently-coded LSPs, and then derive the tables to
 * generate LSPs for the other frames from them (residual coding).
 *
 * @}
 * @defgroup aw Pitch-adaptive window coding functions
 * The next few functions are for pitch-adaptive window coding.
 * @{
 *
 * Parse the offset of the first pitch-adaptive window pulses, and
 * the distribution of pulses between the two blocks in this frame.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param pitch pitch for each block in this frame
  position of pulse  for a repeated pulse at pulse_off with a pitch_lag of pitch[], count
     * the distribution of the pulses in each block contained in this frame.  if continuing from a position before the block, reset position to
     * start of block (when corrected for the range over which it can be
     * spread in aw_pulse_set1()). *
 * Apply second set of pitch-adaptive window pulses.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx block index in frame [0, 1]
 * @param fcb structure containing fixed codebook vector info
  only 5 are used, rest is padding in this function, idx is the index in the 80-bit (+ padding) use_mask
     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits
     * of idx are the position of the bit within a particular item in the
     * array (0 being the most significant bit, and 15 being the least
     * significant bit), and the remainder (>> 4) is the index in the
     * use_mask[]-array. This is faster and uses less memory than using a
     * 80-byte/80-int array.  set offset of first pulse to within this block  find range per pulse  block_idx = 1  aw_pulse_set1() already applies pulses around pulse_off (to be exactly,
     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus
     * we exclude that range from being pulsed again in this function.  always 16 or 24 find the 'aidx'th offset that is not excluded  find from zero set offset for next block, relative to start of that block *
 * Apply first set of pitch-adaptive window pulses.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx block index in frame [0, 1]
 * @param fcb storage location for fixed codebook pulse info
  3 pulses, 1:sign + 3:index each 4 pulses, 1:sign + 2:index each*
 * @}
 *
 * Generate a random number from frame_cntr and block_idx, which will lief
 * in the range [0, 1000 - block_size] (so it can be used as an index in a
 * table of size 1000 of which you want to read block_size entries).
 *
 * @param frame_cntr current frame number
 * @param block_num current block index
 * @param block_size amount of entries we want to read from a table
 *                   that has 1000 entries
 * @return a (non-)random number in the [0, 1000 - block_size] range.
  array to simplify the calculation of z:
     * y = (x % 9) * 5 + 6;
     * z = (49995 * x) / y;
     * Since y only has 9 values, we can remove the division by using a
     * LUT and using FASTDIV-style divisions. For each of the 9 values
     * of y, we can rewrite z as:
     * z = x * (49995 / y) + x * ((49995 % y) / y)
     * In this table, each col represents one possible value of y, the
     * first number is 49995 / y, and the second is the FASTDIV variant
     * of 49995 % y / y.  y =  6 y = 11 y = 16 y = 21 y = 26 y = 31 y = 36 y = 41 y = 46 max value of x is 8*1877+0xFFFE=0x13AA6, so this is effectively a modulo (%) x % 9 z = x * 49995 / (y * 5 + 6)*
 * Parse hardcoded signal for a single block.
 * @note see #synth_block().
  Set the offset from which we start reading wmavoice_std_codebook  FCB_TYPE_HARDCODED  Clear gain prediction parameters  Apply gain to hardcoded codebook and use that as excitation signal *
 * Parse FCB/ACB signal for a single block.
 * @note see #synth_block().
  For the other frame types, this is where we apply the innovation
     * (fixed) codebook pulses of the speech signal.  FCB_TYPE_EXC_PULSES  similar to ff_decode_10_pulses_35bits(), but with single pulses
         * (instead of double) for a subset of pulses  Calculate gain for adaptive & fixed codebook signal.
     * see ff_amr_set_fixed_gain().  log(0.05)  log(5.0)   Calculation of adaptive codebook  ACB_TYPE_HAMMING  Interpolate ACB/FCB and use as excitation signal *
 * Parse data in a single block.
 * @note we assume enough bits are available, caller should check.
 *
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx index of the to-be-read block
 * @param size amount of samples to be read in this block
 * @param block_pitch_sh2 pitch for this block << 2
 * @param lsps LSPs for (the end of) this frame
 * @param prev_lsps LSPs for the last frame
 * @param frame_desc frame type descriptor
 * @param excitation target memory for the ACB+FCB interpolated signal
 * @param synth target memory for the speech synthesis filter output
 * @return 0 on success, <0 on error.
  convert interpolated LSPs to LPCs  LSF -> LSP Speech synthesis *
 * Synthesize output samples for a single frame.
 * @note we assume enough bits are available, caller should check.
 *
 * @param ctx WMA Voice decoder context
 * @param gb bit I/O context (s->gb or one for cross-packet superframes)
 * @param frame_idx Frame number within superframe [0-2]
 * @param samples pointer to output sample buffer, has space for at least 160
 *                samples
 * @param lsps LSP array
 * @param prev_lsps array of previous frame's LSPs
 * @param excitation target buffer for excitation signal
 * @param synth target buffer for synthesized speech data
 * @return 0 on success, <0 on error.
  Parse frame type ("frame header"), see frame_descs  Pitch calculation for ACB_TYPE_ASYMMETRIC ("pitch-per-frame")  Pitch is provided per frame, which is interpreted as the pitch of
         * the last sample of the last block of this frame. We can interpolate
         * the pitch of other blocks (and even pitch-per-sample) by gradually
         * incrementing/decrementing prev_frame_pitch to cur_pitch_val.  pitch per block  "pitch-diff-per-sample" for calculation of pitch per sample  Global gain (if silence) and pitch-adaptive window coordinates  Pitch calculation for ACB_TYPE_HAMMING ("pitch-per-block")  Pitch is given per block. Per-block pitches are encoded as an
             * absolute value for the first block, and then delta values
             * relative to this value) for all subsequent blocks. The scale of
             * this pitch value is semi-logaritmic compared to its use in the
             * decoder, so we convert it to normal scale also.  Convert last_ so that any next delta is within _range  Convert semi-log-style scale back to normal scale  ACB_TYPE_NONE has no pitch Averaging projection filter, if applicable. Else, just copy samples
     * from synthesis buffer  LSF -> LSP LSF -> LSP Cache values for next frame  i.e. modulo (%)*
 * Ensure minimum value for first item, maximum value for last value,
 * proper spacing between each value and proper ordering.
 *
 * @param lsps array of LSPs
 * @param num size of LSP array
 *
 * @note basically a double version of #ff_acelp_reorder_lsf(), might be
 *       useful to put in a generic location later on. Parts are also
 *       present in #ff_set_min_dist_lsf() + #ff_sort_nearly_sorted_floats(),
 *       which is in float.
  set minimum value for first, maximum value for last and minimum
     * spacing between LSF values.
     * Very similar to ff_set_min_dist_lsf(), but in double.  reorder (looks like one-time / non-recursed bubblesort).
     * Very similar to ff_sort_nearly_sorted_floats(), but in double. *
 * Test if there's enough bits to read 1 superframe.
 *
 * @param orig_gb bit I/O context used for reading. This function
 *                does not modify the state of the bitreader; it
 *                only uses it to copy the current stream position
 * @param s WMA Voice decoding context private data
 * @return -1 if unsupported, 1 on not enough bits or 0 if OK.
  initialize a copy  superframe header  WMAPro-in-WMAVoice superframe number of  samples in superframe residual LSPs (for all frames) frames  independent LSPs (per-frame) invalid frame type VLC code blocks *
 * Synthesize output samples for a single superframe. If we have any data
 * cached in s->sframe_cache, that will be used instead of whatever is loaded
 * in s->gb.
 *
 * WMA Voice superframes contain 3 frames, each containing 160 audio samples,
 * to give a total of 480 samples per frame. See #synth_frame() for frame
 * parsing. In addition to 3 frames, superframes can also contain the LSPs
 * (if these are globally specified for all frames (residually); they can
 * also be specified individually per-frame. See the s->has_residual_lsps
 * option), and can specify the number of samples encoded in this superframe
 * (if less than 480), usually used to prevent blanks at track boundaries.
 *
 * @param ctx WMA Voice decoder context
 * @param samples pointer to output buffer for voice samples
 * @param data_size pointer containing the size of #samples on input, and the
 *                  amount of #samples filled on output
 * @return 0 on success, <0 on error or 1 if there was not enough data to
 *         fully parse the superframe
  First bit is speech/music bit, it differentiates between WMAVoice
     * speech samples (the actual codec) and WMAVoice music samples, which
     * are really WMAPro-in-WMAVoice-superframes. I've never seen those in
     * the wild yet.  (optional) nr. of samples in superframe; always <= 480 and >= 0  Parse LSPs, if global for the superframe (can also be per-frame).  s->lsps == 16  Parse frames, optionally preceeded by per-frame (independent) LSPs.  s->lsps == 16  Statistics? FIXME - we don't check for length, a slight overrun
     * will be caught by internal buffer padding, and anything else
     * will be skipped, not read.  Specify nr. of output samples  Update history *
 * Parse the packet header at the start of each packet (input data to this
 * decoder).
 *
 * @param s WMA Voice decoding context private data
 * @return 1 if not enough bits were available, or 0 on success.
  packet sequence number number of superframes per packet (minus first one if there is spillover)*
 * Copy (unaligned) bits from gb/data/size to pb.
 *
 * @param pb target buffer to copy bits into
 * @param data source buffer to copy bits from
 * @param size size of the source data, in bytes
 * @param gb bit I/O context specifying the current position in the source.
 *           data. This function might use this to align the bit position to
 *           a whole-byte boundary before calling #ff_copy_bits() on aligned
 *           source data
 * @param nbits the amount of bits to copy from source to target
 *
 * @note after calling this function, the current position in the input bit
 *       I/O context is undefined.
 *
 * Packet decoding: a packet is anything that the (ASF) demuxer contains,
 * and we expect that the demuxer / application provides it to us as such
 * (else you'll probably get garbage as output). Every packet has a size of
 * ctx->block_align bytes, starts with a packet header (see
 * #parse_packet_header()), and then a series of superframes. Superframe
 * boundaries may exceed packets, i.e. superframes can split data over
 * multiple (two) packets.
 *
 * For more information about frames, see #synth_superframe().
  Packets are sometimes a multiple of ctx->block_align, with a packet
     * header at each ctx->block_align bytes. However, FFmpeg's ASF demuxer
     * feeds us ASF packets, which may concatenate multiple "codec" packets
     * in a single "muxer" packet, so we artificially emulate that by
     * capping the packet size at ctx->block_align.  size == ctx->block_align is used to indicate whether we are dealing with
     * a new packet or a packet of which we already read the packet header
     * previously.  new packet header If the packet header specifies a s->spillover_nbits, then we want
         * to push out all data of the previous packet (+ spillover) before
         * continuing to parse new superframes in the current packet.  convert the float values to int32 for rockbox  resync resync Try parsing superframes in current packet  convert the float values to int32 for rockbox  rewind bit reader to start of last (incomplete) superframe... assert(get_bits_left(gb) == pos); ...and cache it for spillover in next packet  FIXME bad - just copy bytes as whole and add use the skip_bits_next field
 * Windows Media Audio Voice decoder.
 * Copyright (c) 2009 Ronald S. Bultje
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * @file
 * @brief Windows Media Audio Voice compatible decoder
 * @author Ronald S. Bultje <rsbultje@gmail.com>
 /< maximum number of blocks per frame/< maximum filter order/< same as #MAX_LSPS; needs to be multiple/< of 16 for ASM input buffer alignment/< maximum number of frames per superframe/< maximum number of samples per frame/< maximum excitation signal history/< maximum number of samples per superframe/< maximum cache size for frame data that/< was split over two packets/< number of bits to read per VLC iteration*
 * Frame type VLC coding.
 *
 * Adaptive codebook types.
 /< no adaptive codebook (only hardcoded fixed)/< adaptive codebook with per-frame pitch, which/< we interpolate to get a per-sample pitch./< Signal is generated using an asymmetric sinc/< window function/< @note see #wmavoice_ipol1_coeffs/< Per-block pitch with signal generation using/< a Hamming sinc window function/< @note see #wmavoice_ipol2_coeffs*
 * Fixed codebook types.
 /< comfort noise during silence/< generated from a hardcoded (fixed) codebook/< with per-frame (low) gain values/< hardcoded (fixed) codebook with per-block/< gain values/< Pitch-adaptive window (AW) pulse signals,/< used in particular for low-bitrate streams/< Innovation (fixed) codebook pulse sets in/< combinations of either single pulses or/< pulse pairs*
 * Description of frame types.
 /< amount of blocks per frame (each block/< (contains 160/#n_blocks samples)/< log2(#n_blocks)/< Adaptive codebook type (ACB_TYPE_*)/< Fixed codebook type (FCB_TYPE_*)/< how many pulse vectors have pulse pairs/< (rather than just one single pulse)/< only if #fcb_type == #FCB_TYPE_EXC_PULSES/< the amount of bits that make up the block/< data (per frame)*
 * WMA Voice decoding context.
 *
     * @defgroup struct_global Global values
     * Global values, specified in the stream header / extradata or used
     * all over.
     * @{
     /< packet bitreader. During decoder init,/< it contains the extradata from the/< demuxer. During decoding, it contains/< packet data./< converts VLC codes to frame type/< number of bits used to specify/< #spillover_nbits in the packet header/< = ceil(log2(ctx->block_align << 3))/< number of samples in history for signal/< prediction (through ACB) postfilter specific values /< whether to apply the averaged/< projection filter (APF)/< strength of denoising in Wiener filter/< [0-11]/< Whether to apply tilt correction to the/< Wiener filter coefficients (postfilter)/< Predicted amount of DC noise, based/< on which a DC removal filter is used/< number of LSPs per frame [10 or 16]/< defines quantizer defaults [0, 1]/< defines different sets of LSP defaults/< [0, 1]/< size (in bits) of LSPs, when encoded/< per-frame (independent coding)/< size (in bits) of LSPs, when encoded/< per superframe (residual coding)/< base value for pitch parsing code/< max value + 1 for pitch parsing/< number of bits used to specify the/< pitch value in the frame header/< number of bits used to specify the/< first block's pitch value/< range of the block pitch/< number of bits used to specify the/< delta pitch between this and the last/< block's pitch value, used in all but/< first block/< 1/2 range of the delta (full range is/< from -this to +this-1)/< boundaries for block pitch unit/scale/< conversion*
     * @}
     * @defgroup struct_packet Packet values
     * Packet values, specified in the packet header or related to a packet.
     * A packet is considered to be a single unit of data provided to this
     * decoder by the demuxer.
     * @{
     /< number of bits of the previous packet's/< last superframe preceeding this/< packet's first full superframe (useful/< for re-synchronization also)/< if set, superframes contain one set of/< LSPs that cover all frames, encoded as/< independent and residual LSPs; if not/< set, each frame contains its own, fully/< independent, LSPs/< number of bits to skip at the next call/< to #wmavoice_decode_packet() (since/< they're part of the previous superframe)/< cache for superframe data split over/< multiple packets/< set to >0 if we have data from an/< (incomplete) superframe from a previous/< packet that spilled over in the current/< packet; specifies the amount of bits in/< #sframe_cache/< bitstream writer for #sframe_cache*
     * @}
     * @defgroup struct_frame Frame and superframe values
     * Superframe and frame data - these can change from frame to frame,
     * although some of them do in that case serve as a cache / history for
     * the next frame or superframe.
     * @{
     /< LSPs of the last frame of the previous/< superframe/< pitch value of the previous frame/< frame type [0-2] of the previous frame/< ((cur_pitch_val - #last_pitch_val)/< << 16) / #MAX_FRAMESIZE/< set for use in blocks if #ACB_TYPE_NONE/< whether the AW index was encoded in/< 8 bits (instead of 6)/< the range over which #aw_pulse_set1()/< can apply the pulse, relative to the/< value in aw_first_pulse_off. The exact/< position of the first AW-pulse is within/< [pulse_off, pulse_off + this], and/< depends on bitstream values; [16 or 24]/< number of AW-pulses in each block; note/< that this number can be negative (in/< which case it basically means "zero")/< index of first sample to which to/< apply AW-pulses, or -0xff if unset/< the position (relative to start of the/< second block) at which pulses should/< start to be positioned, serves as a/< cache for pitch-adaptive window pulses/< between blocks/< current frame index [0 - 0xFFFE]; is/< only used for comfort noise in #pRNG()/< cache for gain prediction/< cache of the signal of previous/< superframes, used as a history for/< signal generation/< see #excitation_history*
     * @}
     * @defgroup post_filter Postfilter values
     * Varibales used for postfilter implementation, mostly history for
     * smoothing and so on, and context variables for FFT/iFFT.
     * @{
     /< contexts for FFT-calculation in the/< postfilter (for denoise filter)/< contexts for phase shift (in Hilbert/< transform, part of postfilter)/< 8-bit cosine/sine windows over [-pi,pi]/< range/< gain control memory, used in/< #adaptive_gain_control()/< DC filter history/< zero filter output (i.e. excitation)/< by postfilter/< samples in #denoise_filter_cache/< aligned buffer for LPC tilting/< aligned buffer for denoise coefficients/< aligned buffer for postfilter speech/< synthesis*
     * @}
      global decode context *
 * Set up the variable bit mode (VBM) tree from container extradata.
 * @param gb bit I/O context.
 *           The bit context (s->gb) should be loaded with byte 23-46 of the
 *           container extradata (i.e. the ones containing the VBM tree).
 * @param vbm_tree pointer to array to which the decoded VBM tree will be
 *                 written.
 * @return 0 on success, <0 on error.
               00/01/10           11+00/01/10         1111+00/01/10       111111+00/01/10     11111111+00/01/10   1111111111+00/01/10 111111111111+xx should be >= 3 + (res == 7))*
 * Set up decoder with parameters from demuxer (extradata etc.).
 *
     * Extradata layout:
     * - byte  0-18: WMAPro-in-WMAVoice extradata (see wmaprodec.c),
     * - byte 19-22: flags field (annoyingly in LE; see below for known
     *               values),
     * - byte 23-46: variable bitmode tree (really just 17 * 3 bits,
     *               rest is 0).
      322-22097 Hz*
 * @defgroup postfilter Postfilter functions
 * Postfilter functions (gain control, wiener denoise filter, DC filter,
 * kalman smoothening, plus surrounding code to wrap it)
 * @{
 *
 * Adaptive gain control (as used in postfilter).
 *
 * Identical to #ff_adaptive_gain_control() in acelp_vectors.c, except
 * that the energy here is calculated using sum(abs(...)), whereas the
 * other codecs (e.g. AMR-NB, SIPRO) use sqrt(dotproduct(...)).
 *
 * @param out output buffer for filtered samples
 * @param in input buffer containing the samples as they are after the
 *           postfilter steps so far
 * @param speech_synth input buffer containing speech synth before postfilter
 * @param size input buffer size
 * @param alpha exponential filter factor
 * @param gain_mem pointer to filter memory (single float)
 *
 * Kalman smoothing function.
 *
 * This function looks back pitch +/- 3 samples back into history to find
 * the best fitting curve (that one giving the optimal gain of the two
 * signals, i.e. the highest dot product between the two), and then
 * uses that signal history to smoothen the output of the speech synthesis
 * filter.
 *
 * @param s WMA Voice decoding context
 * @param pitch pitch of the speech signal
 * @param in input speech signal
 * @param out output pointer for smoothened signal
 * @param size input/output buffer size
 *
 * @returns -1 if no smoothening took place, e.g. because no optimal
 *          fit could be found, or 0 on success.
  find best fitting point in history  would be 1.0 0.625-1.000 actual smoothing *
 * Get the tilt factor of a formant filter from its transfer function
 * @see #tilt_factor() in amrnbdec.c, which does essentially the same,
 *      but somehow (??) it does a speech synthesis filter in the
 *      middle, which is missing here
 *
 * @param lpcs LPC coefficients
 * @param n_lpcs Size of LPC buffer
 * @returns the tilt factor
 *
 * Derive denoise filter coefficients (in real domain) from the LPCs.
  Create frequency power spectrum of speech input (i.e. RDFT of LPCs)  Now, use this spectrum to pick out these frequencies with higher
     * (relative) power/energy (which we then take to be "not noise"),
     * and set up a table (still in lpc[]) of (relative) gains per frequency.
     * These frequencies will be maintained, while others ("noise") will be
     * decreased in the filter output.  so irange*(max-value) is in the range [0, 63] 70.57 =~ 1/log10(1.0331663)  fallback if index falls outside table range calculate the Hilbert transform of the gains, which we do (since this
     * is a sinus input) by doing a phase shift (in theory, H(sin())=cos()).
     * Hilbert_Transform(RDFT(x)) = Laplace_Transform(x), which calculates the
     * "moment" of the LPCs in this filter.  Split out the coefficient indexes into phase/magnitude pairs  move into real domain  tilt correction and normalize scale *
 * This function applies a Wiener filter on the (noisy) speech signal as
 * a means to denoise it.
 *
 * - take RDFT of LPCs to get the power spectrum of the noise + speech;
 * - using this power spectrum, calculate (for each frequency) the Wiener
 *    filter gain, which depends on the frequency power and desired level
 *    of noise subtraction (when set too high, this leads to artifacts)
 *    We can do this symmetrically over the X-axis (so 0-4kHz is the inverse
 *    of 4-8kHz);
 * - by doing a phase shift, calculate the Hilbert transform of this array
 *    of per-frequency filter-gains to get the filtering coefficients;
 * - smoothen/normalize/de-tilt these filter coefficients as desired;
 * - take RDFT of noisy sound, apply the coefficients and take its IRDFT
 *    to get the denoised speech signal;
 * - the leftover (i.e. output of the IRDFT on denoised speech data beyond
 *    the frame boundary) are saved and applied to subsequent frames by an
 *    overlap-add method (otherwise you get clicking-artifacts).
 *
 * @param s WMA Voice decoding context
 * @param fcb_type Frame (codebook) type
 * @param synth_pf input: the noisy speech signal, output: denoised speech
 *                 data; should be 16-byte aligned (for ASM purposes)
 * @param size size of the speech data
 * @param lpcs LPCs used to synthesize this frame's speech data
  The IRDFT output (127 samples for 7-bit filter) beyond the frame
         * size is applied to the next frame. All input beyond this is zero,
         * and thus all output beyond this will go towards zero, hence we can
         * limit to min(size-1, 127-size) as a performance consideration.  apply coefficients (in frequency spectrum domain), i.e. complex
         * number multiplication  merge filter output with the history of previous runs  move remainder of filter output into a cache for future runs *
 * Averaging projection filter, the postfilter used in WMAVoice.
 *
 * This uses the following steps:
 * - A zero-synthesis filter (generate excitation from synth signal)
 * - Kalman smoothing on excitation, based on pitch
 * - Re-synthesized smoothened output
 * - Iterative Wiener denoise filter
 * - Adaptive gain filter
 * - DC filter
 *
 * @param s WMAVoice decoding context
 * @param synth Speech synthesis output (before postfilter)
 * @param samples Output buffer for filtered samples
 * @param size Buffer size of synth & samples
 * @param lpcs Generated LPCs used for speech synthesis
 * @param zero_exc_pf destination for zero synthesis filter (16-byte aligned)
 * @param fcb_type Frame type (silence, hardcoded, AW-pulses or FCB-pulses)
 * @param pitch Pitch of the input signal
  generate excitation from input signal  re-synthesize speech after smoothening, and keep history  remove ultra-low frequency DC noise / highpass filter;
         * coefficients are identical to those used in SIPR decoding,
         * and very closely resemble those used in AMR-NB decoding. *
 * @}
 *
 * Dequantize LSPs
 * @param lsps output pointer to the array that will hold the LSPs
 * @param num number of LSPs to be dequantized
 * @param values quantized values, contains n_stages values
 * @param sizes range (i.e. max value) of each quantized value
 * @param n_stages number of dequantization runs
 * @param table dequantization table to be used
 * @param mul_q LSF multiplier
 * @param base_q base (lowest) LSF values
 *
 * @defgroup lsp_dequant LSP dequantization routines
 * LSP dequantization routines, for 10/16LSPs and independent/residual coding.
 * @note we assume enough bits are available, caller should check.
 * lsp10i() consumes 24 bits; lsp10r() consumes an additional 24 bits;
 * lsp16i() consumes 34 bits; lsp16r() consumes an additional 26 bits.
 * @{
 *
 * Parse 10 independently-coded LSPs.
 *
 * Parse 10 independently-coded LSPs, and then derive the tables to
 * generate LSPs for the other frames from them (residual coding).
 *
 * Parse 16 independently-coded LSPs.
 *
 * Parse 16 independently-coded LSPs, and then derive the tables to
 * generate LSPs for the other frames from them (residual coding).
 *
 * @}
 * @defgroup aw Pitch-adaptive window coding functions
 * The next few functions are for pitch-adaptive window coding.
 * @{
 *
 * Parse the offset of the first pitch-adaptive window pulses, and
 * the distribution of pulses between the two blocks in this frame.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param pitch pitch for each block in this frame
  position of pulse  for a repeated pulse at pulse_off with a pitch_lag of pitch[], count
     * the distribution of the pulses in each block contained in this frame.  if continuing from a position before the block, reset position to
     * start of block (when corrected for the range over which it can be
     * spread in aw_pulse_set1()). *
 * Apply second set of pitch-adaptive window pulses.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx block index in frame [0, 1]
 * @param fcb structure containing fixed codebook vector info
  only 5 are used, rest is padding in this function, idx is the index in the 80-bit (+ padding) use_mask
     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits
     * of idx are the position of the bit within a particular item in the
     * array (0 being the most significant bit, and 15 being the least
     * significant bit), and the remainder (>> 4) is the index in the
     * use_mask[]-array. This is faster and uses less memory than using a
     * 80-byte/80-int array.  set offset of first pulse to within this block  find range per pulse  block_idx = 1  aw_pulse_set1() already applies pulses around pulse_off (to be exactly,
     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus
     * we exclude that range from being pulsed again in this function.  always 16 or 24 find the 'aidx'th offset that is not excluded  find from zero set offset for next block, relative to start of that block *
 * Apply first set of pitch-adaptive window pulses.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx block index in frame [0, 1]
 * @param fcb storage location for fixed codebook pulse info
  3 pulses, 1:sign + 3:index each 4 pulses, 1:sign + 2:index each*
 * @}
 *
 * Generate a random number from frame_cntr and block_idx, which will lief
 * in the range [0, 1000 - block_size] (so it can be used as an index in a
 * table of size 1000 of which you want to read block_size entries).
 *
 * @param frame_cntr current frame number
 * @param block_num current block index
 * @param block_size amount of entries we want to read from a table
 *                   that has 1000 entries
 * @return a (non-)random number in the [0, 1000 - block_size] range.
  array to simplify the calculation of z:
     * y = (x % 9) * 5 + 6;
     * z = (49995 * x) / y;
     * Since y only has 9 values, we can remove the division by using a
     * LUT and using FASTDIV-style divisions. For each of the 9 values
     * of y, we can rewrite z as:
     * z = x * (49995 / y) + x * ((49995 % y) / y)
     * In this table, each col represents one possible value of y, the
     * first number is 49995 / y, and the second is the FASTDIV variant
     * of 49995 % y / y.  y =  6 y = 11 y = 16 y = 21 y = 26 y = 31 y = 36 y = 41 y = 46 max value of x is 8*1877+0xFFFE=0x13AA6, so this is effectively a modulo (%) x % 9 z = x * 49995 / (y * 5 + 6)*
 * Parse hardcoded signal for a single block.
 * @note see #synth_block().
  Set the offset from which we start reading wmavoice_std_codebook  FCB_TYPE_HARDCODED  Clear gain prediction parameters  Apply gain to hardcoded codebook and use that as excitation signal *
 * Parse FCB/ACB signal for a single block.
 * @note see #synth_block().
  For the other frame types, this is where we apply the innovation
     * (fixed) codebook pulses of the speech signal.  FCB_TYPE_EXC_PULSES  similar to ff_decode_10_pulses_35bits(), but with single pulses
         * (instead of double) for a subset of pulses  Calculate gain for adaptive & fixed codebook signal.
     * see ff_amr_set_fixed_gain().  log(0.05)  log(5.0)   Calculation of adaptive codebook  ACB_TYPE_HAMMING  Interpolate ACB/FCB and use as excitation signal *
 * Parse data in a single block.
 * @note we assume enough bits are available, caller should check.
 *
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx index of the to-be-read block
 * @param size amount of samples to be read in this block
 * @param block_pitch_sh2 pitch for this block << 2
 * @param lsps LSPs for (the end of) this frame
 * @param prev_lsps LSPs for the last frame
 * @param frame_desc frame type descriptor
 * @param excitation target memory for the ACB+FCB interpolated signal
 * @param synth target memory for the speech synthesis filter output
 * @return 0 on success, <0 on error.
  convert interpolated LSPs to LPCs  LSF -> LSP Speech synthesis *
 * Synthesize output samples for a single frame.
 * @note we assume enough bits are available, caller should check.
 *
 * @param ctx WMA Voice decoder context
 * @param gb bit I/O context (s->gb or one for cross-packet superframes)
 * @param frame_idx Frame number within superframe [0-2]
 * @param samples pointer to output sample buffer, has space for at least 160
 *                samples
 * @param lsps LSP array
 * @param prev_lsps array of previous frame's LSPs
 * @param excitation target buffer for excitation signal
 * @param synth target buffer for synthesized speech data
 * @return 0 on success, <0 on error.
  Parse frame type ("frame header"), see frame_descs  Pitch calculation for ACB_TYPE_ASYMMETRIC ("pitch-per-frame")  Pitch is provided per frame, which is interpreted as the pitch of
         * the last sample of the last block of this frame. We can interpolate
         * the pitch of other blocks (and even pitch-per-sample) by gradually
         * incrementing/decrementing prev_frame_pitch to cur_pitch_val.  pitch per block  "pitch-diff-per-sample" for calculation of pitch per sample  Global gain (if silence) and pitch-adaptive window coordinates  Pitch calculation for ACB_TYPE_HAMMING ("pitch-per-block")  Pitch is given per block. Per-block pitches are encoded as an
             * absolute value for the first block, and then delta values
             * relative to this value) for all subsequent blocks. The scale of
             * this pitch value is semi-logaritmic compared to its use in the
             * decoder, so we convert it to normal scale also.  Convert last_ so that any next delta is within _range  Convert semi-log-style scale back to normal scale  ACB_TYPE_NONE has no pitch Averaging projection filter, if applicable. Else, just copy samples
     * from synthesis buffer  LSF -> LSP LSF -> LSP Cache values for next frame  i.e. modulo (%)*
 * Ensure minimum value for first item, maximum value for last value,
 * proper spacing between each value and proper ordering.
 *
 * @param lsps array of LSPs
 * @param num size of LSP array
 *
 * @note basically a double version of #ff_acelp_reorder_lsf(), might be
 *       useful to put in a generic location later on. Parts are also
 *       present in #ff_set_min_dist_lsf() + #ff_sort_nearly_sorted_floats(),
 *       which is in float.
  set minimum value for first, maximum value for last and minimum
     * spacing between LSF values.
     * Very similar to ff_set_min_dist_lsf(), but in double.  reorder (looks like one-time / non-recursed bubblesort).
     * Very similar to ff_sort_nearly_sorted_floats(), but in double. *
 * Test if there's enough bits to read 1 superframe.
 *
 * @param orig_gb bit I/O context used for reading. This function
 *                does not modify the state of the bitreader; it
 *                only uses it to copy the current stream position
 * @param s WMA Voice decoding context private data
 * @return -1 if unsupported, 1 on not enough bits or 0 if OK.
  initialize a copy  superframe header  WMAPro-in-WMAVoice superframe number of  samples in superframe residual LSPs (for all frames) frames  independent LSPs (per-frame) invalid frame type VLC code blocks *
 * Synthesize output samples for a single superframe. If we have any data
 * cached in s->sframe_cache, that will be used instead of whatever is loaded
 * in s->gb.
 *
 * WMA Voice superframes contain 3 frames, each containing 160 audio samples,
 * to give a total of 480 samples per frame. See #synth_frame() for frame
 * parsing. In addition to 3 frames, superframes can also contain the LSPs
 * (if these are globally specified for all frames (residually); they can
 * also be specified individually per-frame. See the s->has_residual_lsps
 * option), and can specify the number of samples encoded in this superframe
 * (if less than 480), usually used to prevent blanks at track boundaries.
 *
 * @param ctx WMA Voice decoder context
 * @param samples pointer to output buffer for voice samples
 * @param data_size pointer containing the size of #samples on input, and the
 *                  amount of #samples filled on output
 * @return 0 on success, <0 on error or 1 if there was not enough data to
 *         fully parse the superframe
  First bit is speech/music bit, it differentiates between WMAVoice
     * speech samples (the actual codec) and WMAVoice music samples, which
     * are really WMAPro-in-WMAVoice-superframes. I've never seen those in
     * the wild yet.  (optional) nr. of samples in superframe; always <= 480 and >= 0  Parse LSPs, if global for the superframe (can also be per-frame).  s->lsps == 16  Parse frames, optionally preceeded by per-frame (independent) LSPs.  s->lsps == 16  Statistics? FIXME - we don't check for length, a slight overrun
     * will be caught by internal buffer padding, and anything else
     * will be skipped, not read.  Specify nr. of output samples  Update history *
 * Parse the packet header at the start of each packet (input data to this
 * decoder).
 *
 * @param s WMA Voice decoding context private data
 * @return 1 if not enough bits were available, or 0 on success.
  packet sequence number number of superframes per packet (minus first one if there is spillover)*
 * Copy (unaligned) bits from gb/data/size to pb.
 *
 * @param pb target buffer to copy bits into
 * @param data source buffer to copy bits from
 * @param size size of the source data, in bytes
 * @param gb bit I/O context specifying the current position in the source.
 *           data. This function might use this to align the bit position to
 *           a whole-byte boundary before calling #ff_copy_bits() on aligned
 *           source data
 * @param nbits the amount of bits to copy from source to target
 *
 * @note after calling this function, the current position in the input bit
 *       I/O context is undefined.
 *
 * Packet decoding: a packet is anything that the (ASF) demuxer contains,
 * and we expect that the demuxer / application provides it to us as such
 * (else you'll probably get garbage as output). Every packet has a size of
 * ctx->block_align bytes, starts with a packet header (see
 * #parse_packet_header()), and then a series of superframes. Superframe
 * boundaries may exceed packets, i.e. superframes can split data over
 * multiple (two) packets.
 *
 * For more information about frames, see #synth_superframe().
  Packets are sometimes a multiple of ctx->block_align, with a packet
     * header at each ctx->block_align bytes. However, FFmpeg's ASF demuxer
     * feeds us ASF packets, which may concatenate multiple "codec" packets
     * in a single "muxer" packet, so we artificially emulate that by
     * capping the packet size at ctx->block_align.  size == ctx->block_align is used to indicate whether we are dealing with
     * a new packet or a packet of which we already read the packet header
     * previously.  new packet header If the packet header specifies a s->spillover_nbits, then we want
         * to push out all data of the previous packet (+ spillover) before
         * continuing to parse new superframes in the current packet.  convert the float values to int32 for rockbox  resync resync Try parsing superframes in current packet  convert the float values to int32 for rockbox  rewind bit reader to start of last (incomplete) superframe... assert(get_bits_left(gb) == pos); ...and cache it for spillover in next packet  FIXME bad - just copy bytes as whole and add use the skip_bits_next field
 * Windows Media Audio Voice decoder.
 * Copyright (c) 2009 Ronald S. Bultje
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * @file
 * @brief Windows Media Audio Voice compatible decoder
 * @author Ronald S. Bultje <rsbultje@gmail.com>
 /< maximum number of blocks per frame/< maximum filter order/< same as #MAX_LSPS; needs to be multiple/< of 16 for ASM input buffer alignment/< maximum number of frames per superframe/< maximum number of samples per frame/< maximum excitation signal history/< maximum number of samples per superframe/< maximum cache size for frame data that/< was split over two packets/< number of bits to read per VLC iteration*
 * Frame type VLC coding.
 *
 * Adaptive codebook types.
 /< no adaptive codebook (only hardcoded fixed)/< adaptive codebook with per-frame pitch, which/< we interpolate to get a per-sample pitch./< Signal is generated using an asymmetric sinc/< window function/< @note see #wmavoice_ipol1_coeffs/< Per-block pitch with signal generation using/< a Hamming sinc window function/< @note see #wmavoice_ipol2_coeffs*
 * Fixed codebook types.
 /< comfort noise during silence/< generated from a hardcoded (fixed) codebook/< with per-frame (low) gain values/< hardcoded (fixed) codebook with per-block/< gain values/< Pitch-adaptive window (AW) pulse signals,/< used in particular for low-bitrate streams/< Innovation (fixed) codebook pulse sets in/< combinations of either single pulses or/< pulse pairs*
 * Description of frame types.
 /< amount of blocks per frame (each block/< (contains 160/#n_blocks samples)/< log2(#n_blocks)/< Adaptive codebook type (ACB_TYPE_*)/< Fixed codebook type (FCB_TYPE_*)/< how many pulse vectors have pulse pairs/< (rather than just one single pulse)/< only if #fcb_type == #FCB_TYPE_EXC_PULSES/< the amount of bits that make up the block/< data (per frame)*
 * WMA Voice decoding context.
 *
     * @defgroup struct_global Global values
     * Global values, specified in the stream header / extradata or used
     * all over.
     * @{
     /< packet bitreader. During decoder init,/< it contains the extradata from the/< demuxer. During decoding, it contains/< packet data./< converts VLC codes to frame type/< number of bits used to specify/< #spillover_nbits in the packet header/< = ceil(log2(ctx->block_align << 3))/< number of samples in history for signal/< prediction (through ACB) postfilter specific values /< whether to apply the averaged/< projection filter (APF)/< strength of denoising in Wiener filter/< [0-11]/< Whether to apply tilt correction to the/< Wiener filter coefficients (postfilter)/< Predicted amount of DC noise, based/< on which a DC removal filter is used/< number of LSPs per frame [10 or 16]/< defines quantizer defaults [0, 1]/< defines different sets of LSP defaults/< [0, 1]/< size (in bits) of LSPs, when encoded/< per-frame (independent coding)/< size (in bits) of LSPs, when encoded/< per superframe (residual coding)/< base value for pitch parsing code/< max value + 1 for pitch parsing/< number of bits used to specify the/< pitch value in the frame header/< number of bits used to specify the/< first block's pitch value/< range of the block pitch/< number of bits used to specify the/< delta pitch between this and the last/< block's pitch value, used in all but/< first block/< 1/2 range of the delta (full range is/< from -this to +this-1)/< boundaries for block pitch unit/scale/< conversion*
     * @}
     * @defgroup struct_packet Packet values
     * Packet values, specified in the packet header or related to a packet.
     * A packet is considered to be a single unit of data provided to this
     * decoder by the demuxer.
     * @{
     /< number of bits of the previous packet's/< last superframe preceeding this/< packet's first full superframe (useful/< for re-synchronization also)/< if set, superframes contain one set of/< LSPs that cover all frames, encoded as/< independent and residual LSPs; if not/< set, each frame contains its own, fully/< independent, LSPs/< number of bits to skip at the next call/< to #wmavoice_decode_packet() (since/< they're part of the previous superframe)/< cache for superframe data split over/< multiple packets/< set to >0 if we have data from an/< (incomplete) superframe from a previous/< packet that spilled over in the current/< packet; specifies the amount of bits in/< #sframe_cache/< bitstream writer for #sframe_cache*
     * @}
     * @defgroup struct_frame Frame and superframe values
     * Superframe and frame data - these can change from frame to frame,
     * although some of them do in that case serve as a cache / history for
     * the next frame or superframe.
     * @{
     /< LSPs of the last frame of the previous/< superframe/< pitch value of the previous frame/< frame type [0-2] of the previous frame/< ((cur_pitch_val - #last_pitch_val)/< << 16) / #MAX_FRAMESIZE/< set for use in blocks if #ACB_TYPE_NONE/< whether the AW index was encoded in/< 8 bits (instead of 6)/< the range over which #aw_pulse_set1()/< can apply the pulse, relative to the/< value in aw_first_pulse_off. The exact/< position of the first AW-pulse is within/< [pulse_off, pulse_off + this], and/< depends on bitstream values; [16 or 24]/< number of AW-pulses in each block; note/< that this number can be negative (in/< which case it basically means "zero")/< index of first sample to which to/< apply AW-pulses, or -0xff if unset/< the position (relative to start of the/< second block) at which pulses should/< start to be positioned, serves as a/< cache for pitch-adaptive window pulses/< between blocks/< current frame index [0 - 0xFFFE]; is/< only used for comfort noise in #pRNG()/< cache for gain prediction/< cache of the signal of previous/< superframes, used as a history for/< signal generation/< see #excitation_history*
     * @}
     * @defgroup post_filter Postfilter values
     * Varibales used for postfilter implementation, mostly history for
     * smoothing and so on, and context variables for FFT/iFFT.
     * @{
     /< contexts for FFT-calculation in the/< postfilter (for denoise filter)/< contexts for phase shift (in Hilbert/< transform, part of postfilter)/< 8-bit cosine/sine windows over [-pi,pi]/< range/< gain control memory, used in/< #adaptive_gain_control()/< DC filter history/< zero filter output (i.e. excitation)/< by postfilter/< samples in #denoise_filter_cache/< aligned buffer for LPC tilting/< aligned buffer for denoise coefficients/< aligned buffer for postfilter speech/< synthesis*
     * @}
      global decode context *
 * Set up the variable bit mode (VBM) tree from container extradata.
 * @param gb bit I/O context.
 *           The bit context (s->gb) should be loaded with byte 23-46 of the
 *           container extradata (i.e. the ones containing the VBM tree).
 * @param vbm_tree pointer to array to which the decoded VBM tree will be
 *                 written.
 * @return 0 on success, <0 on error.
               00/01/10           11+00/01/10         1111+00/01/10       111111+00/01/10     11111111+00/01/10   1111111111+00/01/10 111111111111+xx should be >= 3 + (res == 7))*
 * Set up decoder with parameters from demuxer (extradata etc.).
 *
     * Extradata layout:
     * - byte  0-18: WMAPro-in-WMAVoice extradata (see wmaprodec.c),
     * - byte 19-22: flags field (annoyingly in LE; see below for known
     *               values),
     * - byte 23-46: variable bitmode tree (really just 17 * 3 bits,
     *               rest is 0).
      322-22097 Hz*
 * @defgroup postfilter Postfilter functions
 * Postfilter functions (gain control, wiener denoise filter, DC filter,
 * kalman smoothening, plus surrounding code to wrap it)
 * @{
 *
 * Adaptive gain control (as used in postfilter).
 *
 * Identical to #ff_adaptive_gain_control() in acelp_vectors.c, except
 * that the energy here is calculated using sum(abs(...)), whereas the
 * other codecs (e.g. AMR-NB, SIPRO) use sqrt(dotproduct(...)).
 *
 * @param out output buffer for filtered samples
 * @param in input buffer containing the samples as they are after the
 *           postfilter steps so far
 * @param speech_synth input buffer containing speech synth before postfilter
 * @param size input buffer size
 * @param alpha exponential filter factor
 * @param gain_mem pointer to filter memory (single float)
 *
 * Kalman smoothing function.
 *
 * This function looks back pitch +/- 3 samples back into history to find
 * the best fitting curve (that one giving the optimal gain of the two
 * signals, i.e. the highest dot product between the two), and then
 * uses that signal history to smoothen the output of the speech synthesis
 * filter.
 *
 * @param s WMA Voice decoding context
 * @param pitch pitch of the speech signal
 * @param in input speech signal
 * @param out output pointer for smoothened signal
 * @param size input/output buffer size
 *
 * @returns -1 if no smoothening took place, e.g. because no optimal
 *          fit could be found, or 0 on success.
  find best fitting point in history  would be 1.0 0.625-1.000 actual smoothing *
 * Get the tilt factor of a formant filter from its transfer function
 * @see #tilt_factor() in amrnbdec.c, which does essentially the same,
 *      but somehow (??) it does a speech synthesis filter in the
 *      middle, which is missing here
 *
 * @param lpcs LPC coefficients
 * @param n_lpcs Size of LPC buffer
 * @returns the tilt factor
 *
 * Derive denoise filter coefficients (in real domain) from the LPCs.
  Create frequency power spectrum of speech input (i.e. RDFT of LPCs)  Now, use this spectrum to pick out these frequencies with higher
     * (relative) power/energy (which we then take to be "not noise"),
     * and set up a table (still in lpc[]) of (relative) gains per frequency.
     * These frequencies will be maintained, while others ("noise") will be
     * decreased in the filter output.  so irange*(max-value) is in the range [0, 63] 70.57 =~ 1/log10(1.0331663)  fallback if index falls outside table range calculate the Hilbert transform of the gains, which we do (since this
     * is a sinus input) by doing a phase shift (in theory, H(sin())=cos()).
     * Hilbert_Transform(RDFT(x)) = Laplace_Transform(x), which calculates the
     * "moment" of the LPCs in this filter.  Split out the coefficient indexes into phase/magnitude pairs  move into real domain  tilt correction and normalize scale *
 * This function applies a Wiener filter on the (noisy) speech signal as
 * a means to denoise it.
 *
 * - take RDFT of LPCs to get the power spectrum of the noise + speech;
 * - using this power spectrum, calculate (for each frequency) the Wiener
 *    filter gain, which depends on the frequency power and desired level
 *    of noise subtraction (when set too high, this leads to artifacts)
 *    We can do this symmetrically over the X-axis (so 0-4kHz is the inverse
 *    of 4-8kHz);
 * - by doing a phase shift, calculate the Hilbert transform of this array
 *    of per-frequency filter-gains to get the filtering coefficients;
 * - smoothen/normalize/de-tilt these filter coefficients as desired;
 * - take RDFT of noisy sound, apply the coefficients and take its IRDFT
 *    to get the denoised speech signal;
 * - the leftover (i.e. output of the IRDFT on denoised speech data beyond
 *    the frame boundary) are saved and applied to subsequent frames by an
 *    overlap-add method (otherwise you get clicking-artifacts).
 *
 * @param s WMA Voice decoding context
 * @param fcb_type Frame (codebook) type
 * @param synth_pf input: the noisy speech signal, output: denoised speech
 *                 data; should be 16-byte aligned (for ASM purposes)
 * @param size size of the speech data
 * @param lpcs LPCs used to synthesize this frame's speech data
  The IRDFT output (127 samples for 7-bit filter) beyond the frame
         * size is applied to the next frame. All input beyond this is zero,
         * and thus all output beyond this will go towards zero, hence we can
         * limit to min(size-1, 127-size) as a performance consideration.  apply coefficients (in frequency spectrum domain), i.e. complex
         * number multiplication  merge filter output with the history of previous runs  move remainder of filter output into a cache for future runs *
 * Averaging projection filter, the postfilter used in WMAVoice.
 *
 * This uses the following steps:
 * - A zero-synthesis filter (generate excitation from synth signal)
 * - Kalman smoothing on excitation, based on pitch
 * - Re-synthesized smoothened output
 * - Iterative Wiener denoise filter
 * - Adaptive gain filter
 * - DC filter
 *
 * @param s WMAVoice decoding context
 * @param synth Speech synthesis output (before postfilter)
 * @param samples Output buffer for filtered samples
 * @param size Buffer size of synth & samples
 * @param lpcs Generated LPCs used for speech synthesis
 * @param zero_exc_pf destination for zero synthesis filter (16-byte aligned)
 * @param fcb_type Frame type (silence, hardcoded, AW-pulses or FCB-pulses)
 * @param pitch Pitch of the input signal
  generate excitation from input signal  re-synthesize speech after smoothening, and keep history  remove ultra-low frequency DC noise / highpass filter;
         * coefficients are identical to those used in SIPR decoding,
         * and very closely resemble those used in AMR-NB decoding. *
 * @}
 *
 * Dequantize LSPs
 * @param lsps output pointer to the array that will hold the LSPs
 * @param num number of LSPs to be dequantized
 * @param values quantized values, contains n_stages values
 * @param sizes range (i.e. max value) of each quantized value
 * @param n_stages number of dequantization runs
 * @param table dequantization table to be used
 * @param mul_q LSF multiplier
 * @param base_q base (lowest) LSF values
 *
 * @defgroup lsp_dequant LSP dequantization routines
 * LSP dequantization routines, for 10/16LSPs and independent/residual coding.
 * @note we assume enough bits are available, caller should check.
 * lsp10i() consumes 24 bits; lsp10r() consumes an additional 24 bits;
 * lsp16i() consumes 34 bits; lsp16r() consumes an additional 26 bits.
 * @{
 *
 * Parse 10 independently-coded LSPs.
 *
 * Parse 10 independently-coded LSPs, and then derive the tables to
 * generate LSPs for the other frames from them (residual coding).
 *
 * Parse 16 independently-coded LSPs.
 *
 * Parse 16 independently-coded LSPs, and then derive the tables to
 * generate LSPs for the other frames from them (residual coding).
 *
 * @}
 * @defgroup aw Pitch-adaptive window coding functions
 * The next few functions are for pitch-adaptive window coding.
 * @{
 *
 * Parse the offset of the first pitch-adaptive window pulses, and
 * the distribution of pulses between the two blocks in this frame.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param pitch pitch for each block in this frame
  position of pulse  for a repeated pulse at pulse_off with a pitch_lag of pitch[], count
     * the distribution of the pulses in each block contained in this frame.  if continuing from a position before the block, reset position to
     * start of block (when corrected for the range over which it can be
     * spread in aw_pulse_set1()). *
 * Apply second set of pitch-adaptive window pulses.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx block index in frame [0, 1]
 * @param fcb structure containing fixed codebook vector info
  only 5 are used, rest is padding in this function, idx is the index in the 80-bit (+ padding) use_mask
     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits
     * of idx are the position of the bit within a particular item in the
     * array (0 being the most significant bit, and 15 being the least
     * significant bit), and the remainder (>> 4) is the index in the
     * use_mask[]-array. This is faster and uses less memory than using a
     * 80-byte/80-int array.  set offset of first pulse to within this block  find range per pulse  block_idx = 1  aw_pulse_set1() already applies pulses around pulse_off (to be exactly,
     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus
     * we exclude that range from being pulsed again in this function.  always 16 or 24 find the 'aidx'th offset that is not excluded  find from zero set offset for next block, relative to start of that block *
 * Apply first set of pitch-adaptive window pulses.
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx block index in frame [0, 1]
 * @param fcb storage location for fixed codebook pulse info
  3 pulses, 1:sign + 3:index each 4 pulses, 1:sign + 2:index each*
 * @}
 *
 * Generate a random number from frame_cntr and block_idx, which will lief
 * in the range [0, 1000 - block_size] (so it can be used as an index in a
 * table of size 1000 of which you want to read block_size entries).
 *
 * @param frame_cntr current frame number
 * @param block_num current block index
 * @param block_size amount of entries we want to read from a table
 *                   that has 1000 entries
 * @return a (non-)random number in the [0, 1000 - block_size] range.
  array to simplify the calculation of z:
     * y = (x % 9) * 5 + 6;
     * z = (49995 * x) / y;
     * Since y only has 9 values, we can remove the division by using a
     * LUT and using FASTDIV-style divisions. For each of the 9 values
     * of y, we can rewrite z as:
     * z = x * (49995 / y) + x * ((49995 % y) / y)
     * In this table, each col represents one possible value of y, the
     * first number is 49995 / y, and the second is the FASTDIV variant
     * of 49995 % y / y.  y =  6 y = 11 y = 16 y = 21 y = 26 y = 31 y = 36 y = 41 y = 46 max value of x is 8*1877+0xFFFE=0x13AA6, so this is effectively a modulo (%) x % 9 z = x * 49995 / (y * 5 + 6)*
 * Parse hardcoded signal for a single block.
 * @note see #synth_block().
  Set the offset from which we start reading wmavoice_std_codebook  FCB_TYPE_HARDCODED  Clear gain prediction parameters  Apply gain to hardcoded codebook and use that as excitation signal *
 * Parse FCB/ACB signal for a single block.
 * @note see #synth_block().
  For the other frame types, this is where we apply the innovation
     * (fixed) codebook pulses of the speech signal.  FCB_TYPE_EXC_PULSES  similar to ff_decode_10_pulses_35bits(), but with single pulses
         * (instead of double) for a subset of pulses  Calculate gain for adaptive & fixed codebook signal.
     * see ff_amr_set_fixed_gain().  log(0.05)  log(5.0)   Calculation of adaptive codebook  ACB_TYPE_HAMMING  Interpolate ACB/FCB and use as excitation signal *
 * Parse data in a single block.
 * @note we assume enough bits are available, caller should check.
 *
 * @param s WMA Voice decoding context private data
 * @param gb bit I/O context
 * @param block_idx index of the to-be-read block
 * @param size amount of samples to be read in this block
 * @param block_pitch_sh2 pitch for this block << 2
 * @param lsps LSPs for (the end of) this frame
 * @param prev_lsps LSPs for the last frame
 * @param frame_desc frame type descriptor
 * @param excitation target memory for the ACB+FCB interpolated signal
 * @param synth target memory for the speech synthesis filter output
 * @return 0 on success, <0 on error.
  convert interpolated LSPs to LPCs  LSF -> LSP Speech synthesis *
 * Synthesize output samples for a single frame.
 * @note we assume enough bits are available, caller should check.
 *
 * @param ctx WMA Voice decoder context
 * @param gb bit I/O context (s->gb or one for cross-packet superframes)
 * @param frame_idx Frame number within superframe [0-2]
 * @param samples pointer to output sample buffer, has space for at least 160
 *                samples
 * @param lsps LSP array
 * @param prev_lsps array of previous frame's LSPs
 * @param excitation target buffer for excitation signal
 * @param synth target buffer for synthesized speech data
 * @return 0 on success, <0 on error.
  Parse frame type ("frame header"), see frame_descs  Pitch calculation for ACB_TYPE_ASYMMETRIC ("pitch-per-frame")  Pitch is provided per frame, which is interpreted as the pitch of
         * the last sample of the last block of this frame. We can interpolate
         * the pitch of other blocks (and even pitch-per-sample) by gradually
         * incrementing/decrementing prev_frame_pitch to cur_pitch_val.  pitch per block  "pitch-diff-per-sample" for calculation of pitch per sample  Global gain (if silence) and pitch-adaptive window coordinates  Pitch calculation for ACB_TYPE_HAMMING ("pitch-per-block")  Pitch is given per block. Per-block pitches are encoded as an
             * absolute value for the first block, and then delta values
             * relative to this value) for all subsequent blocks. The scale of
             * this pitch value is semi-logaritmic compared to its use in the
             * decoder, so we convert it to normal scale also.  Convert last_ so that any next delta is within _range  Convert semi-log-style scale back to normal scale  ACB_TYPE_NONE has no pitch Averaging projection filter, if applicable. Else, just copy samples
     * from synthesis buffer  LSF -> LSP LSF -> LSP Cache values for next frame  i.e. modulo (%)*
 * Ensure minimum value for first item, maximum value for last value,
 * proper spacing between each value and proper ordering.
 *
 * @param lsps array of LSPs
 * @param num size of LSP array
 *
 * @note basically a double version of #ff_acelp_reorder_lsf(), might be
 *       useful to put in a generic location later on. Parts are also
 *       present in #ff_set_min_dist_lsf() + #ff_sort_nearly_sorted_floats(),
 *       which is in float.
  set minimum value for first, maximum value for last and minimum
     * spacing between LSF values.
     * Very similar to ff_set_min_dist_lsf(), but in double.  reorder (looks like one-time / non-recursed bubblesort).
     * Very similar to ff_sort_nearly_sorted_floats(), but in double. *
 * Test if there's enough bits to read 1 superframe.
 *
 * @param orig_gb bit I/O context used for reading. This function
 *                does not modify the state of the bitreader; it
 *                only uses it to copy the current stream position
 * @param s WMA Voice decoding context private data
 * @return -1 if unsupported, 1 on not enough bits or 0 if OK.
  initialize a copy  superframe header  WMAPro-in-WMAVoice superframe number of  samples in superframe residual LSPs (for all frames) frames  independent LSPs (per-frame) invalid frame type VLC code blocks *
 * Synthesize output samples for a single superframe. If we have any data
 * cached in s->sframe_cache, that will be used instead of whatever is loaded
 * in s->gb.
 *
 * WMA Voice superframes contain 3 frames, each containing 160 audio samples,
 * to give a total of 480 samples per frame. See #synth_frame() for frame
 * parsing. In addition to 3 frames, superframes can also contain the LSPs
 * (if these are globally specified for all frames (residually); they can
 * also be specified individually per-frame. See the s->has_residual_lsps
 * option), and can specify the number of samples encoded in this superframe
 * (if less than 480), usually used to prevent blanks at track boundaries.
 *
 * @param ctx WMA Voice decoder context
 * @param samples pointer to output buffer for voice samples
 * @param data_size pointer containing the size of #samples on input, and the
 *                  amount of #samples filled on output
 * @return 0 on success, <0 on error or 1 if there was not enough data to
 *         fully parse the superframe
  First bit is speech/music bit, it differentiates between WMAVoice
     * speech samples (the actual codec) and WMAVoice music samples, which
     * are really WMAPro-in-WMAVoice-superframes. I've never seen those in
     * the wild yet.  (optional) nr. of samples in superframe; always <= 480 and >= 0  Parse LSPs, if global for the superframe (can also be per-frame).  s->lsps == 16  Parse frames, optionally preceeded by per-frame (independent) LSPs.  s->lsps == 16  Statistics? FIXME - we don't check for length, a slight overrun
     * will be caught by internal buffer padding, and anything else
     * will be skipped, not read.  Specify nr. of output samples  Update history *
 * Parse the packet header at the start of each packet (input data to this
 * decoder).
 *
 * @param s WMA Voice decoding context private data
 * @return 1 if not enough bits were available, or 0 on success.
  packet sequence number number of superframes per packet (minus first one if there is spillover)*
 * Copy (unaligned) bits from gb/data/size to pb.
 *
 * @param pb target buffer to copy bits into
 * @param data source buffer to copy bits from
 * @param size size of the source data, in bytes
 * @param gb bit I/O context specifying the current position in the source.
 *           data. This function might use this to align the bit position to
 *           a whole-byte boundary before calling #ff_copy_bits() on aligned
 *           source data
 * @param nbits the amount of bits to copy from source to target
 *
 * @note after calling this function, the current position in the input bit
 *       I/O context is undefined.
 *
 * Packet decoding: a packet is anything that the (ASF) demuxer contains,
 * and we expect that the demuxer / application provides it to us as such
 * (else you'll probably get garbage as output). Every packet has a size of
 * ctx->block_align bytes, starts with a packet header (see
 * #parse_packet_header()), and then a series of superframes. Superframe
 * boundaries may exceed packets, i.e. superframes can split data over
 * multiple (two) packets.
 *
 * For more information about frames, see #synth_superframe().
  Packets are sometimes a multiple of ctx->block_align, with a packet
     * header at each ctx->block_align bytes. However, FFmpeg's ASF demuxer
     * feeds us ASF packets, which may concatenate multiple "codec" packets
     * in a single "muxer" packet, so we artificially emulate that by
     * capping the packet size at ctx->block_align.  size == ctx->block_align is used to indicate whether we are dealing with
     * a new packet or a packet of which we already read the packet header
     * previously.  new packet header If the packet header specifies a s->spillover_nbits, then we want
         * to push out all data of the previous packet (+ spillover) before
         * continuing to parse new superframes in the current packet.  convert the float values to int32 for rockbox  resync resync Try parsing superframes in current packet  convert the float values to int32 for rockbox  rewind bit reader to start of last (incomplete) superframe... assert(get_bits_left(gb) == pos); ...and cache it for spillover in next packet  FIXME bad - just copy bytes as whole and add use the skip_bits_next field