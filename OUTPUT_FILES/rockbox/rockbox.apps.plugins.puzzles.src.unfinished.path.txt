
 * Experimental grid generator for Nikoli's `Number Link' puzzle.
 
 * 2005-07-08: This is currently a Path grid generator which will
 * construct valid grids at a plausible speed. However, the grids
 * are not of suitable quality to be used directly as puzzles.
 * 
 * The basic strategy is to start with an empty grid, and
 * repeatedly either (a) add a new path to it, or (b) extend one
 * end of a path by one square in some direction and push other
 * paths into new shapes in the process. The effect of this is that
 * we are able to construct a set of paths which between them fill
 * the entire grid.
 * 
 * Quality issues: if we set the main loop to do (a) where possible
 * and (b) only where necessary, we end up with a grid containing a
 * few too many small paths, which therefore doesn't make for an
 * interesting puzzle. If we reverse the priority so that we do (b)
 * where possible and (a) only where necessary, we end up with some
 * staggeringly interwoven grids with very very few separate paths,
 * but the result of this is that there's invariably a solution
 * other than the intended one which leaves many grid squares
 * unfilled. There's also a separate problem which is that many
 * grids have really boring and obvious paths in them, such as the
 * entire bottom row of the grid being taken up by a single path.
 * 
 * It's not impossible that a few tweaks might eliminate or reduce
 * the incidence of boring paths, and might also find a happy
 * medium between too many and too few. There remains the question
 * of unique solutions, however. I fear there is no alternative but
 * to write - somehow! - a solver.
 * 
 * While I'm here, some notes on UI strategy for the parts of the
 * puzzle implementation that _aren't_ the generator:
 * 
 *  - data model is to track connections between adjacent squares,
 *    so that you aren't limited to extending a path out from each
 *    number but can also mark sections of path which you know
 *    _will_ come in handy later.
 * 
 *  - user interface is to click in one square and drag to an
 *    adjacent one, thus creating a link between them. We can
 *    probably tolerate rapid mouse motion causing a drag directly
 *    to a square which is a rook move away, but any other rapid
 *    motion is ambiguous and probably the best option is to wait
 *    until the mouse returns to a square we know how to reach.
 * 
 *  - a drag causing the current path to backtrack has the effect
 *    of removing bits of it.
 * 
 *  - the UI should enforce at all times the constraint that at
 *    most two links can come into any square.
 * 
 *  - my Cunning Plan for actually implementing this: the game_ui
 *    contains a grid-sized array, which is copied from the current
 *    game_state on starting a drag. While a drag is active, the
 *    contents of the game_ui is adjusted with every mouse motion,
 *    and is displayed _in place_ of the game_state itself. On
 *    termination of a drag, the game_ui array is copied back into
 *    the new game_state (or rather, a string move is encoded which
 *    has precisely the set of link changes to cause that effect).
 
 * 2020-05-11: some thoughts on a solver.
 *
 * Consider this example puzzle, from Wikipedia:
 *
 *     ---4---
 *     -3--25-
 *     ---31--
 *     ---5---
 *     -------
 *     --1----
 *     2---4--
 *
 * The kind of deduction that a human wants to make here is: which way
 * does the path between the 4s go? In particular, does it go round
 * the left of the W-shaped cluster of endpoints, or round the right
 * of it? It's clear at a glance that it must go to the right, because
 * _any_ path between the 4s that goes to the left of that cluster, no
 * matter what detailed direction it takes, will disconnect the
 * remaining grid squares into two components, with the two 2s not in
 * the same component. So we immediately know that the path between
 * the 4s _must_ go round the right-hand side of the grid.
 *
 * How do you model that global and topological reasoning in a
 * computer?
 *
 * The most plausible idea I've seen so far is to use fundamental
 * groups. The fundamental group of loops based at a given point in a
 * space is a free group, under loop concatenation and up to homotopy,
 * generated by the loops that go in each direction around each hole
 * in the space. In this case, the 'holes' are clues, or connected
 * groups of clues.
 *
 * So you might be able to enumerate all the homotopy classes of paths
 * between (say) the two 4s as follows. Start with any old path
 * between them (say, find the first one that breadth-first search
 * will give you). Choose one of the 4s to regard as the base point
 * (arbitrarily). Then breadth-first search among the space of _paths_
 * by the following procedure. Given a candidate path, append to it
 * each of the possible loops that starts from the base point,
 * circumnavigates one clue cluster, and returns to the base point.
 * The result will typically be a path that retraces its steps and
 * self-intersects. Now adjust it homotopically so that it doesn't. If
 * that can't be done, then we haven't generated a fresh candidate
 * path; if it can, then we've got a new path that is not homotopic to
 * any path we already had, so add it to our list and queue it up to
 * become the starting point of this search later.
 *
 * The idea is that this should exhaustively enumerate, up to
 * homotopy, the different ways in which the two 4s can connect to
 * each other within the constraint that you have to actually fit the
 * path non-self-intersectingly into this grid. Then you can keep a
 * list of those homotopy classes in mind, and start ruling them out
 * by techniques like the connectivity approach described above.
 * Hopefully you end up narrowing down to few enough homotopy classes
 * that you can deduce something concrete about actual squares of the
 * grid - for example, here, that if the path between 4s has to go
 * round the right, then we know some specific squares it must go
 * through, so we can fill those in. And then, having filled in a
 * piece of the middle of a path, you can now regard connecting the
 * ultimate endpoints to that mid-section as two separate subproblems,
 * so you've reduced to a simpler instance of the same puzzle.
 *
 * But I don't know whether all of this actually works. I more or less
 * believe the process for enumerating elements of the free group; but
 * I'm not as confident that when you find a group element that won't
 * fit in the grid, you'll never have to consider its descendants in
 * the BFS either. And I'm assuming that 'unwind the self-intersection
 * homotopically' is a thing that can actually be turned into a
 * sensible algorithm.
 *
 * --------
 *
 * Another thing that might be needed is to characterise _which_
 * homotopy class a given path is in.
 *
 * For this I think it's sufficient to choose a collection of paths
 * along the _edges_ of the square grid, each of which connects two of
 * the holes in the grid (including the grid exterior, which counts as
 * a huge hole), such that they form a spanning tree between the
 * holes. Then assign each of those paths an orientation, so that
 * crossing it in one direction counts as 'positive' and the other
 * 'negative'. Now analyse a candidate path from one square to another
 * by following it and noting down which of those paths it crosses in
 * which direction, then simplifying the result like a free group word
 * (i.e. adjacent + and - crossings of the same path cancel out).
 *
 * --------
 *
 * If we choose those paths to be of minimal length, then we can get
 * an upper bound on the number of homotopy classes by observing that
 * you can't traverse any of those barriers more times than will fit
 * non-self-intersectingly in the grid. That might be an alternative
 * method of bounding the search through the fundamental group to only
 * finitely many possibilities.
 
 * Standard notation for directions.
 
 * Perform a breadth-first search over a grid of squares with the
 * colour of square (X,Y) given by grid[Y*w+X]. The search begins
 * at (x,y), and finds all squares which are the same colour as
 * (x,y) and reachable from it by orthogonal moves. On return:
 *  - dist[Y*w+X] gives the distance of (X,Y) from (x,y), or -1 if
 *    unreachable or a different colour
 *  - the returned value is the number of reachable squares,
 *    including (x,y) itself
 *  - list[0] up to list[returned value - 1] list those squares, in
 *    increasing order of distance from (x,y) (and in arbitrary
 *    order within that).
 
     * Start by clearing the output arrays.
     
     * Set up the initial list.
     
     * Repeatedly process a square and add any extra squares to the
     * end of list.
      2*npaths entries  npaths entries  8*npaths entries  empty square is not an endpoint! 
 * Tries to extend a path by one square in the given direction,
 * pushing other paths around if necessary. Returns true on success
 * or false on failure.
 
     * Find the endpoint of the path and the point we plan to
     * extend it into.
      could not extend in this direction 
     * We don't extend paths _directly_ into endpoints of other
     * paths, although we don't mind too much if a knock-on effect
     * of an extension is to push part of another path into a third
     * path's endpoint.
     
     * We can't extend a path back the way it came.
     
     * Paths may not double back on themselves. Check if the new
     * point is adjacent to any point of this path other than (x,y).
     
     * Now we're convinced it's valid to _attempt_ the extension.
     * It may still fail if we run out of space to push other paths
     * into.
     *
     * So now we can set up our temporary data structures. We will
     * need:
     * 
     * 	- a spare copy of the grid on which to gradually move paths
     * 	  around (sparegrid)
     * 
     * 	- a second spare copy with which to remember how paths
     * 	  looked just before being cut (sparegrid2). FIXME: is
     * 	  sparegrid2 necessary? right now it's never different from
     * 	  grid itself
     * 
     * 	- a third spare copy with which to do the internal
     * 	  calculations involved in reconstituting a cut path
     * 	  (sparegrid3)
     * 
     * 	- something to track which paths currently need
     * 	  reconstituting after being cut, and which have already
     * 	  been cut (pathspare)
     * 
     * 	- a spare copy of pathends to store the altered states in
     * 	  (sparepathends)
      0=untouched, 1=broken, 2=fixed 
     * Working in sparegrid, actually extend the path. If it cuts
     * another, begin a loop in which we restore any cut path by
     * moving it out of the way.
      this one is sacrosanct  broken  we're done 
	     * Path i needs restoring. So walk along its original
	     * track (as given in sparegrid2) and see where it's
	     * been cut. Where it has, surround the cut points in
	     * the same colour, without overwriting already-fixed
	     * paths.
	      FIXME 
		 * Wipe out the original path in sparegrid.
		 
		 * Be prepared to shorten the path at either end if
		 * the endpoints have been stomped on.
		  central square  out of range  can't use this square  path is completely wiped out! 
	     * Now we've covered sparegrid3 in possible squares for
	     * the new layout of path i. Find the actual layout
	     * we're going to use by bfs: we want the shortest path
	     * from one endpoint to the other.
	     
		 * Either there is no way to get between the path's
		 * endpoints, or the remaining endpoints simply
		 * aren't far enough apart to make the path viable
		 * any more. This means the entire push operation
		 * has failed.
		 
	     * Write the new path into sparegrid. Also save the new
	     * endpoint locations, in case they've changed.
	      somehow we've hit a fixed path  broken 
		 * Now look at the neighbours of jp to find one
		 * which has dist[] one less.
		 printf("new ends of path %d: %d,%d\n", i, first, last); fixed 
     * If we got here, the extension was successful!
     
 * Tries to add a new path to the grid.
 
     * Our strategy is:
     *  - randomly choose an empty square in the grid
     * 	- do a BFS from that point to find a long path starting
     * 	  from it
     *  - if we run out of viable empty squares, return failure.
     
     * Use `sparegrid' to collect a list of empty squares.
     
     * Shuffle the grid.
     
     * Loop over it trying to add paths. This looks like a
     * horrifying N^4 algorithm (that is, (w*h)^2), but I predict
     * that in fact the worst case will very rarely arise because
     * when there's lots of grid space an attempt will succeed very
     * quickly.
     
	 * BFS from here to find long paths.
	 
	 * If there aren't any long enough, give up immediately.
	  must be the start square at least! 
	 * Find the first viable endpoint in ctx->list (i.e. the
	 * first point with distance at least three). I could
	 * binary-search for this, but that would be O(log N)
	 * whereas in fact I can get a constant time bound by just
	 * searching up from the start - after all, there can be at
	 * most 13 points at _less_ than distance 3 from the
	 * starting one!
	  we tested above that there was one 
	 * Now we know that any element of `list' between j and nsq
	 * would be valid in principle. However, we want a few long
	 * paths rather than many small ones, so select only those
	 * elements which are either the maximum length or one
	 * below it.
	 
	 * And that's our endpoint. Mark the new path on the grid.
	 
 * The main grid generation loop.
 
     * The generation algorithm doesn't always converge. Loop round
     * until it does.
     
	     * See if the grid is full.
	     
	     * Try adding a path.
	     
	     * Try extending a path. First list all the possible
	     * extensions.
	     
	     * Then shuffle the list.
	     
	     * Now try each one in turn until one works.
	     
 * Wrapper function which deals with the boring bits such as
 * removing the solution from the generated grid, shuffling the
 * numeric labels and creating/disposing of the context structure.
 
     * There is likely to be an ordering bias in the numbers
     * (longer paths on lower numbers due to there having been more
     * grid space when laying them down). So we must shuffle the
     * numbers. We use ctx->pathspare for this.
     * 
     * This is also as good a time as any to shift to numbering
     * from 1, for display to the user.
      FIXME: remove this at some point! 
     * Clear the grid, and write in just the endpoints.
     
 * Experimental grid generator for Nikoli's `Number Link' puzzle.
 
 * 2005-07-08: This is currently a Path grid generator which will
 * construct valid grids at a plausible speed. However, the grids
 * are not of suitable quality to be used directly as puzzles.
 * 
 * The basic strategy is to start with an empty grid, and
 * repeatedly either (a) add a new path to it, or (b) extend one
 * end of a path by one square in some direction and push other
 * paths into new shapes in the process. The effect of this is that
 * we are able to construct a set of paths which between them fill
 * the entire grid.
 * 
 * Quality issues: if we set the main loop to do (a) where possible
 * and (b) only where necessary, we end up with a grid containing a
 * few too many small paths, which therefore doesn't make for an
 * interesting puzzle. If we reverse the priority so that we do (b)
 * where possible and (a) only where necessary, we end up with some
 * staggeringly interwoven grids with very very few separate paths,
 * but the result of this is that there's invariably a solution
 * other than the intended one which leaves many grid squares
 * unfilled. There's also a separate problem which is that many
 * grids have really boring and obvious paths in them, such as the
 * entire bottom row of the grid being taken up by a single path.
 * 
 * It's not impossible that a few tweaks might eliminate or reduce
 * the incidence of boring paths, and might also find a happy
 * medium between too many and too few. There remains the question
 * of unique solutions, however. I fear there is no alternative but
 * to write - somehow! - a solver.
 * 
 * While I'm here, some notes on UI strategy for the parts of the
 * puzzle implementation that _aren't_ the generator:
 * 
 *  - data model is to track connections between adjacent squares,
 *    so that you aren't limited to extending a path out from each
 *    number but can also mark sections of path which you know
 *    _will_ come in handy later.
 * 
 *  - user interface is to click in one square and drag to an
 *    adjacent one, thus creating a link between them. We can
 *    probably tolerate rapid mouse motion causing a drag directly
 *    to a square which is a rook move away, but any other rapid
 *    motion is ambiguous and probably the best option is to wait
 *    until the mouse returns to a square we know how to reach.
 * 
 *  - a drag causing the current path to backtrack has the effect
 *    of removing bits of it.
 * 
 *  - the UI should enforce at all times the constraint that at
 *    most two links can come into any square.
 * 
 *  - my Cunning Plan for actually implementing this: the game_ui
 *    contains a grid-sized array, which is copied from the current
 *    game_state on starting a drag. While a drag is active, the
 *    contents of the game_ui is adjusted with every mouse motion,
 *    and is displayed _in place_ of the game_state itself. On
 *    termination of a drag, the game_ui array is copied back into
 *    the new game_state (or rather, a string move is encoded which
 *    has precisely the set of link changes to cause that effect).
 
 * 2020-05-11: some thoughts on a solver.
 *
 * Consider this example puzzle, from Wikipedia:
 *
 *     ---4---
 *     -3--25-
 *     ---31--
 *     ---5---
 *     -------
 *     --1----
 *     2---4--
 *
 * The kind of deduction that a human wants to make here is: which way
 * does the path between the 4s go? In particular, does it go round
 * the left of the W-shaped cluster of endpoints, or round the right
 * of it? It's clear at a glance that it must go to the right, because
 * _any_ path between the 4s that goes to the left of that cluster, no
 * matter what detailed direction it takes, will disconnect the
 * remaining grid squares into two components, with the two 2s not in
 * the same component. So we immediately know that the path between
 * the 4s _must_ go round the right-hand side of the grid.
 *
 * How do you model that global and topological reasoning in a
 * computer?
 *
 * The most plausible idea I've seen so far is to use fundamental
 * groups. The fundamental group of loops based at a given point in a
 * space is a free group, under loop concatenation and up to homotopy,
 * generated by the loops that go in each direction around each hole
 * in the space. In this case, the 'holes' are clues, or connected
 * groups of clues.
 *
 * So you might be able to enumerate all the homotopy classes of paths
 * between (say) the two 4s as follows. Start with any old path
 * between them (say, find the first one that breadth-first search
 * will give you). Choose one of the 4s to regard as the base point
 * (arbitrarily). Then breadth-first search among the space of _paths_
 * by the following procedure. Given a candidate path, append to it
 * each of the possible loops that starts from the base point,
 * circumnavigates one clue cluster, and returns to the base point.
 * The result will typically be a path that retraces its steps and
 * self-intersects. Now adjust it homotopically so that it doesn't. If
 * that can't be done, then we haven't generated a fresh candidate
 * path; if it can, then we've got a new path that is not homotopic to
 * any path we already had, so add it to our list and queue it up to
 * become the starting point of this search later.
 *
 * The idea is that this should exhaustively enumerate, up to
 * homotopy, the different ways in which the two 4s can connect to
 * each other within the constraint that you have to actually fit the
 * path non-self-intersectingly into this grid. Then you can keep a
 * list of those homotopy classes in mind, and start ruling them out
 * by techniques like the connectivity approach described above.
 * Hopefully you end up narrowing down to few enough homotopy classes
 * that you can deduce something concrete about actual squares of the
 * grid - for example, here, that if the path between 4s has to go
 * round the right, then we know some specific squares it must go
 * through, so we can fill those in. And then, having filled in a
 * piece of the middle of a path, you can now regard connecting the
 * ultimate endpoints to that mid-section as two separate subproblems,
 * so you've reduced to a simpler instance of the same puzzle.
 *
 * But I don't know whether all of this actually works. I more or less
 * believe the process for enumerating elements of the free group; but
 * I'm not as confident that when you find a group element that won't
 * fit in the grid, you'll never have to consider its descendants in
 * the BFS either. And I'm assuming that 'unwind the self-intersection
 * homotopically' is a thing that can actually be turned into a
 * sensible algorithm.
 *
 * --------
 *
 * Another thing that might be needed is to characterise _which_
 * homotopy class a given path is in.
 *
 * For this I think it's sufficient to choose a collection of paths
 * along the _edges_ of the square grid, each of which connects two of
 * the holes in the grid (including the grid exterior, which counts as
 * a huge hole), such that they form a spanning tree between the
 * holes. Then assign each of those paths an orientation, so that
 * crossing it in one direction counts as 'positive' and the other
 * 'negative'. Now analyse a candidate path from one square to another
 * by following it and noting down which of those paths it crosses in
 * which direction, then simplifying the result like a free group word
 * (i.e. adjacent + and - crossings of the same path cancel out).
 *
 * --------
 *
 * If we choose those paths to be of minimal length, then we can get
 * an upper bound on the number of homotopy classes by observing that
 * you can't traverse any of those barriers more times than will fit
 * non-self-intersectingly in the grid. That might be an alternative
 * method of bounding the search through the fundamental group to only
 * finitely many possibilities.
 
 * Standard notation for directions.
 
 * Perform a breadth-first search over a grid of squares with the
 * colour of square (X,Y) given by grid[Y*w+X]. The search begins
 * at (x,y), and finds all squares which are the same colour as
 * (x,y) and reachable from it by orthogonal moves. On return:
 *  - dist[Y*w+X] gives the distance of (X,Y) from (x,y), or -1 if
 *    unreachable or a different colour
 *  - the returned value is the number of reachable squares,
 *    including (x,y) itself
 *  - list[0] up to list[returned value - 1] list those squares, in
 *    increasing order of distance from (x,y) (and in arbitrary
 *    order within that).
 
     * Start by clearing the output arrays.
     
     * Set up the initial list.
     
     * Repeatedly process a square and add any extra squares to the
     * end of list.
      2*npaths entries  npaths entries  8*npaths entries  empty square is not an endpoint! 
 * Tries to extend a path by one square in the given direction,
 * pushing other paths around if necessary. Returns true on success
 * or false on failure.
 
     * Find the endpoint of the path and the point we plan to
     * extend it into.
      could not extend in this direction 
     * We don't extend paths _directly_ into endpoints of other
     * paths, although we don't mind too much if a knock-on effect
     * of an extension is to push part of another path into a third
     * path's endpoint.
     
     * We can't extend a path back the way it came.
     
     * Paths may not double back on themselves. Check if the new
     * point is adjacent to any point of this path other than (x,y).
     
     * Now we're convinced it's valid to _attempt_ the extension.
     * It may still fail if we run out of space to push other paths
     * into.
     *
     * So now we can set up our temporary data structures. We will
     * need:
     * 
     * 	- a spare copy of the grid on which to gradually move paths
     * 	  around (sparegrid)
     * 
     * 	- a second spare copy with which to remember how paths
     * 	  looked just before being cut (sparegrid2). FIXME: is
     * 	  sparegrid2 necessary? right now it's never different from
     * 	  grid itself
     * 
     * 	- a third spare copy with which to do the internal
     * 	  calculations involved in reconstituting a cut path
     * 	  (sparegrid3)
     * 
     * 	- something to track which paths currently need
     * 	  reconstituting after being cut, and which have already
     * 	  been cut (pathspare)
     * 
     * 	- a spare copy of pathends to store the altered states in
     * 	  (sparepathends)
      0=untouched, 1=broken, 2=fixed 
     * Working in sparegrid, actually extend the path. If it cuts
     * another, begin a loop in which we restore any cut path by
     * moving it out of the way.
      this one is sacrosanct  broken  we're done 
	     * Path i needs restoring. So walk along its original
	     * track (as given in sparegrid2) and see where it's
	     * been cut. Where it has, surround the cut points in
	     * the same colour, without overwriting already-fixed
	     * paths.
	      FIXME 
		 * Wipe out the original path in sparegrid.
		 
		 * Be prepared to shorten the path at either end if
		 * the endpoints have been stomped on.
		  central square  out of range  can't use this square  path is completely wiped out! 
	     * Now we've covered sparegrid3 in possible squares for
	     * the new layout of path i. Find the actual layout
	     * we're going to use by bfs: we want the shortest path
	     * from one endpoint to the other.
	     
		 * Either there is no way to get between the path's
		 * endpoints, or the remaining endpoints simply
		 * aren't far enough apart to make the path viable
		 * any more. This means the entire push operation
		 * has failed.
		 
	     * Write the new path into sparegrid. Also save the new
	     * endpoint locations, in case they've changed.
	      somehow we've hit a fixed path  broken 
		 * Now look at the neighbours of jp to find one
		 * which has dist[] one less.
		 printf("new ends of path %d: %d,%d\n", i, first, last); fixed 
     * If we got here, the extension was successful!
     
 * Tries to add a new path to the grid.
 
     * Our strategy is:
     *  - randomly choose an empty square in the grid
     * 	- do a BFS from that point to find a long path starting
     * 	  from it
     *  - if we run out of viable empty squares, return failure.
     
     * Use `sparegrid' to collect a list of empty squares.
     
     * Shuffle the grid.
     
     * Loop over it trying to add paths. This looks like a
     * horrifying N^4 algorithm (that is, (w*h)^2), but I predict
     * that in fact the worst case will very rarely arise because
     * when there's lots of grid space an attempt will succeed very
     * quickly.
     
	 * BFS from here to find long paths.
	 
	 * If there aren't any long enough, give up immediately.
	  must be the start square at least! 
	 * Find the first viable endpoint in ctx->list (i.e. the
	 * first point with distance at least three). I could
	 * binary-search for this, but that would be O(log N)
	 * whereas in fact I can get a constant time bound by just
	 * searching up from the start - after all, there can be at
	 * most 13 points at _less_ than distance 3 from the
	 * starting one!
	  we tested above that there was one 
	 * Now we know that any element of `list' between j and nsq
	 * would be valid in principle. However, we want a few long
	 * paths rather than many small ones, so select only those
	 * elements which are either the maximum length or one
	 * below it.
	 
	 * And that's our endpoint. Mark the new path on the grid.
	 
 * The main grid generation loop.
 
     * The generation algorithm doesn't always converge. Loop round
     * until it does.
     
	     * See if the grid is full.
	     
	     * Try adding a path.
	     
	     * Try extending a path. First list all the possible
	     * extensions.
	     
	     * Then shuffle the list.
	     
	     * Now try each one in turn until one works.
	     
 * Wrapper function which deals with the boring bits such as
 * removing the solution from the generated grid, shuffling the
 * numeric labels and creating/disposing of the context structure.
 
     * There is likely to be an ordering bias in the numbers
     * (longer paths on lower numbers due to there having been more
     * grid space when laying them down). So we must shuffle the
     * numbers. We use ctx->pathspare for this.
     * 
     * This is also as good a time as any to shift to numbering
     * from 1, for display to the user.
      FIXME: remove this at some point! 
     * Clear the grid, and write in just the endpoints.
     
 * Experimental grid generator for Nikoli's `Number Link' puzzle.
 
 * 2005-07-08: This is currently a Path grid generator which will
 * construct valid grids at a plausible speed. However, the grids
 * are not of suitable quality to be used directly as puzzles.
 * 
 * The basic strategy is to start with an empty grid, and
 * repeatedly either (a) add a new path to it, or (b) extend one
 * end of a path by one square in some direction and push other
 * paths into new shapes in the process. The effect of this is that
 * we are able to construct a set of paths which between them fill
 * the entire grid.
 * 
 * Quality issues: if we set the main loop to do (a) where possible
 * and (b) only where necessary, we end up with a grid containing a
 * few too many small paths, which therefore doesn't make for an
 * interesting puzzle. If we reverse the priority so that we do (b)
 * where possible and (a) only where necessary, we end up with some
 * staggeringly interwoven grids with very very few separate paths,
 * but the result of this is that there's invariably a solution
 * other than the intended one which leaves many grid squares
 * unfilled. There's also a separate problem which is that many
 * grids have really boring and obvious paths in them, such as the
 * entire bottom row of the grid being taken up by a single path.
 * 
 * It's not impossible that a few tweaks might eliminate or reduce
 * the incidence of boring paths, and might also find a happy
 * medium between too many and too few. There remains the question
 * of unique solutions, however. I fear there is no alternative but
 * to write - somehow! - a solver.
 * 
 * While I'm here, some notes on UI strategy for the parts of the
 * puzzle implementation that _aren't_ the generator:
 * 
 *  - data model is to track connections between adjacent squares,
 *    so that you aren't limited to extending a path out from each
 *    number but can also mark sections of path which you know
 *    _will_ come in handy later.
 * 
 *  - user interface is to click in one square and drag to an
 *    adjacent one, thus creating a link between them. We can
 *    probably tolerate rapid mouse motion causing a drag directly
 *    to a square which is a rook move away, but any other rapid
 *    motion is ambiguous and probably the best option is to wait
 *    until the mouse returns to a square we know how to reach.
 * 
 *  - a drag causing the current path to backtrack has the effect
 *    of removing bits of it.
 * 
 *  - the UI should enforce at all times the constraint that at
 *    most two links can come into any square.
 * 
 *  - my Cunning Plan for actually implementing this: the game_ui
 *    contains a grid-sized array, which is copied from the current
 *    game_state on starting a drag. While a drag is active, the
 *    contents of the game_ui is adjusted with every mouse motion,
 *    and is displayed _in place_ of the game_state itself. On
 *    termination of a drag, the game_ui array is copied back into
 *    the new game_state (or rather, a string move is encoded which
 *    has precisely the set of link changes to cause that effect).
 
 * 2020-05-11: some thoughts on a solver.
 *
 * Consider this example puzzle, from Wikipedia:
 *
 *     ---4---
 *     -3--25-
 *     ---31--
 *     ---5---
 *     -------
 *     --1----
 *     2---4--
 *
 * The kind of deduction that a human wants to make here is: which way
 * does the path between the 4s go? In particular, does it go round
 * the left of the W-shaped cluster of endpoints, or round the right
 * of it? It's clear at a glance that it must go to the right, because
 * _any_ path between the 4s that goes to the left of that cluster, no
 * matter what detailed direction it takes, will disconnect the
 * remaining grid squares into two components, with the two 2s not in
 * the same component. So we immediately know that the path between
 * the 4s _must_ go round the right-hand side of the grid.
 *
 * How do you model that global and topological reasoning in a
 * computer?
 *
 * The most plausible idea I've seen so far is to use fundamental
 * groups. The fundamental group of loops based at a given point in a
 * space is a free group, under loop concatenation and up to homotopy,
 * generated by the loops that go in each direction around each hole
 * in the space. In this case, the 'holes' are clues, or connected
 * groups of clues.
 *
 * So you might be able to enumerate all the homotopy classes of paths
 * between (say) the two 4s as follows. Start with any old path
 * between them (say, find the first one that breadth-first search
 * will give you). Choose one of the 4s to regard as the base point
 * (arbitrarily). Then breadth-first search among the space of _paths_
 * by the following procedure. Given a candidate path, append to it
 * each of the possible loops that starts from the base point,
 * circumnavigates one clue cluster, and returns to the base point.
 * The result will typically be a path that retraces its steps and
 * self-intersects. Now adjust it homotopically so that it doesn't. If
 * that can't be done, then we haven't generated a fresh candidate
 * path; if it can, then we've got a new path that is not homotopic to
 * any path we already had, so add it to our list and queue it up to
 * become the starting point of this search later.
 *
 * The idea is that this should exhaustively enumerate, up to
 * homotopy, the different ways in which the two 4s can connect to
 * each other within the constraint that you have to actually fit the
 * path non-self-intersectingly into this grid. Then you can keep a
 * list of those homotopy classes in mind, and start ruling them out
 * by techniques like the connectivity approach described above.
 * Hopefully you end up narrowing down to few enough homotopy classes
 * that you can deduce something concrete about actual squares of the
 * grid - for example, here, that if the path between 4s has to go
 * round the right, then we know some specific squares it must go
 * through, so we can fill those in. And then, having filled in a
 * piece of the middle of a path, you can now regard connecting the
 * ultimate endpoints to that mid-section as two separate subproblems,
 * so you've reduced to a simpler instance of the same puzzle.
 *
 * But I don't know whether all of this actually works. I more or less
 * believe the process for enumerating elements of the free group; but
 * I'm not as confident that when you find a group element that won't
 * fit in the grid, you'll never have to consider its descendants in
 * the BFS either. And I'm assuming that 'unwind the self-intersection
 * homotopically' is a thing that can actually be turned into a
 * sensible algorithm.
 *
 * --------
 *
 * Another thing that might be needed is to characterise _which_
 * homotopy class a given path is in.
 *
 * For this I think it's sufficient to choose a collection of paths
 * along the _edges_ of the square grid, each of which connects two of
 * the holes in the grid (including the grid exterior, which counts as
 * a huge hole), such that they form a spanning tree between the
 * holes. Then assign each of those paths an orientation, so that
 * crossing it in one direction counts as 'positive' and the other
 * 'negative'. Now analyse a candidate path from one square to another
 * by following it and noting down which of those paths it crosses in
 * which direction, then simplifying the result like a free group word
 * (i.e. adjacent + and - crossings of the same path cancel out).
 *
 * --------
 *
 * If we choose those paths to be of minimal length, then we can get
 * an upper bound on the number of homotopy classes by observing that
 * you can't traverse any of those barriers more times than will fit
 * non-self-intersectingly in the grid. That might be an alternative
 * method of bounding the search through the fundamental group to only
 * finitely many possibilities.
 
 * Standard notation for directions.
 
 * Perform a breadth-first search over a grid of squares with the
 * colour of square (X,Y) given by grid[Y*w+X]. The search begins
 * at (x,y), and finds all squares which are the same colour as
 * (x,y) and reachable from it by orthogonal moves. On return:
 *  - dist[Y*w+X] gives the distance of (X,Y) from (x,y), or -1 if
 *    unreachable or a different colour
 *  - the returned value is the number of reachable squares,
 *    including (x,y) itself
 *  - list[0] up to list[returned value - 1] list those squares, in
 *    increasing order of distance from (x,y) (and in arbitrary
 *    order within that).
 
     * Start by clearing the output arrays.
     
     * Set up the initial list.
     
     * Repeatedly process a square and add any extra squares to the
     * end of list.
      2*npaths entries  npaths entries  8*npaths entries  empty square is not an endpoint! 
 * Tries to extend a path by one square in the given direction,
 * pushing other paths around if necessary. Returns true on success
 * or false on failure.
 
     * Find the endpoint of the path and the point we plan to
     * extend it into.
      could not extend in this direction 
     * We don't extend paths _directly_ into endpoints of other
     * paths, although we don't mind too much if a knock-on effect
     * of an extension is to push part of another path into a third
     * path's endpoint.
     
     * We can't extend a path back the way it came.
     
     * Paths may not double back on themselves. Check if the new
     * point is adjacent to any point of this path other than (x,y).
     
     * Now we're convinced it's valid to _attempt_ the extension.
     * It may still fail if we run out of space to push other paths
     * into.
     *
     * So now we can set up our temporary data structures. We will
     * need:
     * 
     * 	- a spare copy of the grid on which to gradually move paths
     * 	  around (sparegrid)
     * 
     * 	- a second spare copy with which to remember how paths
     * 	  looked just before being cut (sparegrid2). FIXME: is
     * 	  sparegrid2 necessary? right now it's never different from
     * 	  grid itself
     * 
     * 	- a third spare copy with which to do the internal
     * 	  calculations involved in reconstituting a cut path
     * 	  (sparegrid3)
     * 
     * 	- something to track which paths currently need
     * 	  reconstituting after being cut, and which have already
     * 	  been cut (pathspare)
     * 
     * 	- a spare copy of pathends to store the altered states in
     * 	  (sparepathends)
      0=untouched, 1=broken, 2=fixed 
     * Working in sparegrid, actually extend the path. If it cuts
     * another, begin a loop in which we restore any cut path by
     * moving it out of the way.
      this one is sacrosanct  broken  we're done 
	     * Path i needs restoring. So walk along its original
	     * track (as given in sparegrid2) and see where it's
	     * been cut. Where it has, surround the cut points in
	     * the same colour, without overwriting already-fixed
	     * paths.
	      FIXME 
		 * Wipe out the original path in sparegrid.
		 
		 * Be prepared to shorten the path at either end if
		 * the endpoints have been stomped on.
		  central square  out of range  can't use this square  path is completely wiped out! 
	     * Now we've covered sparegrid3 in possible squares for
	     * the new layout of path i. Find the actual layout
	     * we're going to use by bfs: we want the shortest path
	     * from one endpoint to the other.
	     
		 * Either there is no way to get between the path's
		 * endpoints, or the remaining endpoints simply
		 * aren't far enough apart to make the path viable
		 * any more. This means the entire push operation
		 * has failed.
		 
	     * Write the new path into sparegrid. Also save the new
	     * endpoint locations, in case they've changed.
	      somehow we've hit a fixed path  broken 
		 * Now look at the neighbours of jp to find one
		 * which has dist[] one less.
		 printf("new ends of path %d: %d,%d\n", i, first, last); fixed 
     * If we got here, the extension was successful!
     
 * Tries to add a new path to the grid.
 
     * Our strategy is:
     *  - randomly choose an empty square in the grid
     * 	- do a BFS from that point to find a long path starting
     * 	  from it
     *  - if we run out of viable empty squares, return failure.
     
     * Use `sparegrid' to collect a list of empty squares.
     
     * Shuffle the grid.
     
     * Loop over it trying to add paths. This looks like a
     * horrifying N^4 algorithm (that is, (w*h)^2), but I predict
     * that in fact the worst case will very rarely arise because
     * when there's lots of grid space an attempt will succeed very
     * quickly.
     
	 * BFS from here to find long paths.
	 
	 * If there aren't any long enough, give up immediately.
	  must be the start square at least! 
	 * Find the first viable endpoint in ctx->list (i.e. the
	 * first point with distance at least three). I could
	 * binary-search for this, but that would be O(log N)
	 * whereas in fact I can get a constant time bound by just
	 * searching up from the start - after all, there can be at
	 * most 13 points at _less_ than distance 3 from the
	 * starting one!
	  we tested above that there was one 
	 * Now we know that any element of `list' between j and nsq
	 * would be valid in principle. However, we want a few long
	 * paths rather than many small ones, so select only those
	 * elements which are either the maximum length or one
	 * below it.
	 
	 * And that's our endpoint. Mark the new path on the grid.
	 
 * The main grid generation loop.
 
     * The generation algorithm doesn't always converge. Loop round
     * until it does.
     
	     * See if the grid is full.
	     
	     * Try adding a path.
	     
	     * Try extending a path. First list all the possible
	     * extensions.
	     
	     * Then shuffle the list.
	     
	     * Now try each one in turn until one works.
	     
 * Wrapper function which deals with the boring bits such as
 * removing the solution from the generated grid, shuffling the
 * numeric labels and creating/disposing of the context structure.
 
     * There is likely to be an ordering bias in the numbers
     * (longer paths on lower numbers due to there having been more
     * grid space when laying them down). So we must shuffle the
     * numbers. We use ctx->pathspare for this.
     * 
     * This is also as good a time as any to shift to numbering
     * from 1, for display to the user.
      FIXME: remove this at some point! 
     * Clear the grid, and write in just the endpoints.
     