
 * tree234.c: reasonably generic counted 2-3-4 tree routines.
 * 
 * This file is copyright 1999-2001 Simon Tatham.
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL SIMON TATHAM BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
  for smalloc/sfree 
 * Create a 2-3-4 tree.
 
 * Free a 2-3-4 tree (not including freeing the elements).
 
 * Internal function to count a node.
 
 * Count the elements in a tree.
 
 * Propagate a node overflow up a tree until it stops. Returns 0 or
 * 1, depending on whether the root had to be split or not.
 
     * We need to insert the new left/element/right set in n at
     * child position ki.
     
	     * Insert in a 2-node; simple.
	      ki == 1 
	     * Insert in a 3-node; simple.
	      ki == 2 
	     * Insert in a 4-node; split into a 2-node and a
	     * 3-node, and move focus up a level.
	     * 
	     * I don't think it matters which way round we put the
	     * 2 and the 3. For simplicity, we'll put the 3 first
	     * always.
	      e = e;  ki == 3 
     * If we've come out of here by `break', n will still be
     * non-NULL and all we need to do is go back up the tree
     * updating counts. If we've come here because n is NULL, we
     * need to create a new root for the tree because the old one
     * has just split into two.  root unchanged  root moved 
 * Add an element e to a 2-3-4 tree t. Returns e on success, or if
 * an existing element compares equal, returns that.
 
		 * Leaf node. We want to insert at kid position
		 * equal to the index:
		 * 
		 *   0 A 1 B 2 C 3
		 
		 * Internal node. We always descend through it (add
		 * always starts at the bottom, never in the
		 * middle).
		  error: index out of range  already exists  already exists  already exists  tree is unsorted  index out of range  tree is sorted  return failure  this checks the upper bound 
 * Look up the element at a given numeric index in a 2-3-4 tree.
 * Returns NULL if the index is out of range.
  tree is empty  out of range  We shouldn't ever get here. I wonder how we did. 
 * Find an element e in a sorted 2-3-4 tree t. Returns NULL if not
 * found. e is always passed as the first argument to cmp, so cmp
 * can be an asymmetric function if desired. cmp can also be passed
 * as NULL, in which case the compare function from the tree proper
 * will be used.
 
     * Attempt to find the element itself.
     
     * Prepare a fake `cmp' result if e is NULL.
      e is a max: always greater  e is a min: always smaller 
	 * We have found the element we're looking for. It's
	 * n->elems[ecount], at tree index idx. If our search
	 * relation is EQ, LE or GE we can now go home.
	 
	 * Otherwise, we'll do an indexed lookup for the previous
	 * or next element. (It would be perfectly possible to
	 * implement these search types in a non-counted tree by
	 * going back up from where we are, but far more fiddly.)
	 
	 * We've found our way to the bottom of the tree and we
	 * know where we would insert this node if we wanted to:
	 * we'd put it in in place of the (empty) subtree
	 * n->kids[kcount], and it would have index idx
	 * 
	 * But the actual element isn't there. So if our search
	 * relation is EQ, we're doomed.
	 
	 * Otherwise, we must do an index lookup for index idx-1
	 * (if we're going left - LE or LT) or index idx (if we're
	 * going right - GE or GT).
	 
     * We know the index of the element we want; just call index234
     * to do the rest. This will return NULL if the index is out of
     * bounds, which is exactly what we want.
     
 * Tree transformation used in delete and split: move a subtree
 * right, from child ki of a node to the next child. Update k and
 * index so that they still point to the same place in the
 * transformed tree. Assumes the destination child is not full, and
 * that the source child does have a subtree to spare. Can cope if
 * the destination child is undersized.
 * 
 *                . C .                     . B .
 *               /     \     ->            /     \
 * [more] a A b B c   d D e      [more] a A b   c C d D e
 * 
 *                 . C .                     . B .
 *                /     \    ->             /     \
 *  [more] a A b B c     d        [more] a A b   c C d
 
     * Move over the rest of the destination node to make space.
      which element to move over 
 * Tree transformation used in delete and split: move a subtree
 * left, from child ki of a node to the previous child. Update k
 * and index so that they still point to the same place in the
 * transformed tree. Assumes the destination child is not full, and
 * that the source child does have a subtree to spare. Can cope if
 * the destination child is undersized. 
 *
 *      . B .                             . C .
 *     /     \                ->         /     \
 *  a A b   c C d D e [more]      a A b B c   d D e [more]
 *
 *     . A .                             . B .
 *    /     \                 ->        /     \
 *   a   b B c C d [more]            a A b   c C d [more]
  where in dest to put it 
     * Move over the rest of the source node.
     
 * Tree transformation used in delete and split: merge child nodes
 * ki and ki+1 of a node. Update k and index so that they still
 * point to the same place in the transformed tree. Assumes both
 * children _are_ sufficiently small.
 *
 *      . B .                .
 *     /     \     ->        |
 *  a A b   c C d      a A b B c C d
 * 
 * This routine can also cope with either child being undersized:
 * 
 *     . A .                 .
 *    /     \      ->        |
 *   a     b B c         a A b B c
 *
 *    . A .                  .
 *   /     \       ->        |
 *  a   b B c C d      a A b B c C d
  neither is large! 
     * Move the rest of n up by one.
     
 * Delete an element e in a 2-3-4 tree. Does not free the element,
 * merely removes all links to it from the tree nodes.
  by assumption this is non-NULL  can't happen  n is a leaf node; we're here! 
	 * Check to see if we've found our target element. If so,
	 * we must choose a new target (we'll use the old target's
	 * successor, which will be in a leaf), move it into the
	 * place of the old one, continue down to the leaf and
	 * delete the old copy of the new target.
	  must be a kid _before_ an element 
	 * Recurse down to subtree ki. If it has only one element,
	 * we have to do some transformation to start with.
	 
		 * Child ki has only one element, but child
		 * ki-1 has two or more. So we need to move a
		 * subtree from ki-1 to ki.
		 
		 * Child ki has only one element, but ki+1 has
		 * two or more. Move a subtree from ki+1 to ki.
		 
		 * ki is small with only small neighbours. Pick a
		 * neighbour and merge with it.
		 
		     * The root is empty and needs to be
		     * removed.
		     
     * Now n is a leaf node, and ki marks the element number we
     * want to delete. We've already arranged for the leaf to be
     * bigger than minimum size, so let's just go to it.
     
     * It's just possible that we have reduced the leaf to zero
     * size. This can only happen if it was the root - so destroy
     * it and make the tree empty.
      finished!  it wasn't in there anyway  it's there; delete it. 
 * Join two subtrees together with a separator element between
 * them, given their relative height.
 * 
 * (Height<0 means the left tree is shorter, >0 means the right
 * tree is shorter, =0 means (duh) they're equal.)
 * 
 * It is assumed that any checks needed on the ordering criterion
 * have _already_ been done.
 * 
 * The value returned in `height' is 0 or 1 depending on whether the
 * resulting tree is the same height as the original larger one, or
 * one higher.
 
	 * The trees are the same height. Create a new one-element
	 * root containing the separator and pointers to the two
	 * nodes.
	 
     * This now works like the addition algorithm on the larger
     * tree. We're replacing a single kid pointer with two kid
     * pointers separated by an element; if that causes the node to
     * overload, we split it in two, move a separator element up to
     * the next node, and repeat.
     
	 * Left tree is shorter. Search down the right tree to find
	 * the pointer we're inserting at.
	 
	 * Right tree is shorter; search down the left to find the
	 * pointer we're inserting at.
	 
     * Now proceed as for addition.
     
 * Split out the first <index> elements in a tree and return a
 * pointer to the root node. Leave the root node of the remainder
 * in t.
 
     * Easy special cases. After this we have also dealt completely
     * with the empty-tree case and we can assume the root exists.
      return nothing  return the whole tree 
     * Search down the tree to find the split point.
     
	 * Split the node, put halves[0] on the right of the left
	 * one and halves[1] on the left of the right one, put the
	 * new node pointers in halves[0] and halves[1], and go up
	 * a level.
	 
     * We've come off the bottom here, so we've successfully split
     * the tree into two equally high subtrees. The only problem is
     * that some of the nodes down the fault line will be smaller
     * than the minimum permitted size. (Since this is a 2-3-4
     * tree, that means they'll be zero-element one-child nodes.)
     
     * So now we go back down the tree from each of the two roots,
     * fixing up undersize nodes.
     
	 * Remove the root if it's undersize (it will contain only
	 * one child pointer, so just throw it away and replace it
	 * with its child). This might happen several times.
	 
	     * Now we have a potentially undersize node on the
	     * right (if half==0) or left (if half==1). Sort it
	     * out, by merging with a neighbour or by transferring
	     * subtrees over. At this time we must also ensure that
	     * nodes are bigger than minimum, in case we need an
	     * element to merge two nodes below.
	      the kid we're interested in  the neighbour  for merge: leftmost of the two 
		 * This node is undersized or minimum-size. If we
		 * can merge it with its neighbour, we do so;
		 * otherwise we must be able to transfer subtrees
		 * over to it until it is greater than minimum
		 * size.
		 
		     * Neighbour is small, or possibly neighbour is
		     * medium and we are undersize.
		     
			 * n is empty, and hence must have been the
			 * root and needs to be removed.
			  Neighbour is big enough to move trees over.  error  We want to return the ones before the index. 
	 * We want to keep the ones before the index and return the
	 * ones after.
	 
 * Test code for the 2-3-4 tree. This code maintains an alternative
 * representation of the data in the tree, in an array (using the
 * obvious and slow insert and delete functions). After each tree
 * operation, the verify() function is called, which ensures all
 * the tree properties are preserved:
 *  - node->child->parent always equals node
 *  - tree->root->parent always equals NULL
 *  - number of kids == 0 or number of elements + 1;
 *  - tree has the same depth everywhere
 *  - every node has at least one element
 *  - subtree element counts are accurate
 *  - any NULL kid pointer is accompanied by a zero count
 *  - in a sorted tree: ordering property between elements of a
 *    node and elements of its children is preserved
 * and also ensures the list represented by the tree is the same
 * list it should be. (This last check also doubly verifies the
 * ordering properties, because the `same list it should be' is by
 * definition correctly ordered. It also ensures all nodes are
 * distinct, because the enum functions would get caught in a loop
 * if not.)
 
 * Error reporting function.
  The array representation of the data.  The tree representation of the same data. 
 * Routines to provide a diagnostic printout of a tree. Currently
 * relies on every element in the tree being a one-character string
 * :-)
  Count the non-NULL kids.  Ensure no kids beyond the first NULL are non-NULL.  Count the non-NULL elements.  Ensure no elements beyond the first NULL are non-NULL. 
         * If nkids==0, this is a leaf node; verify that the tree
         * depth is the same everywhere.
          we didn't know the depth yet 
         * If nkids != 0, then it should be nelems+1, unless nelems
         * is 0 in which case nkids should also be 0 (and so we
         * shouldn't be in this condition at all).
         
     * nelems should be at least 1.
     
     * Add nelems to the running element count of the whole tree.
     
     * Check ordering property: all elements should be strictly >
     * lowbound, strictly < highbound, and strictly < each other in
     * sequence. (lowbound and highbound are NULL at edges of tree
     * - both NULL at root node - and NULL is considered to be <
     * everything and > everything. IYSWIM.)
     
     * Check parent pointers: all non-NULL kids should have a
     * parent pointer coming back to this node.
     
     * Now (finally!) recurse into subtrees.
      depth unknown yet  no elements seen yet 
     * Verify validity of tree properties.
     
     * Enumerate the tree and ensure it matches up to the array.
      now i points to the first element >= elem  expect elem returned (success)  add elem to array  expect that returned not elem  i points to the right element  delete elem from array  don't do it!  A sample data set and test utility. Designed for pseudo-randomness,
 * and yet repeatability. 
 * This random number generator uses the `portable implementation'
 * given in ANSI C99 draft N869. It assumes `unsigned' is 32 bits;
 * change it if not.
  left empty by join 
     * Now try an unsorted tree. We don't really need to test
     * delpos234 because we know del234 is based on it, so it's
     * already been tested in the above sorted-tree code; but for
     * completeness we'll use it to tear down our unsorted tree
     * once we've built it.
     
     * While we have this tree in its full form, we'll take a copy
     * of it to use in split and join testing.
      check the copy is accurate 
     * Split tests. Split the tree at every possible point and
     * check the resulting subtrees.
      see if it has a 2-root 
     * Now do the split test again, but on a tree that has a 2-root
     * (if the previous one didn't) or doesn't (if the previous one
     * did).
     
     * Back to the main testing of uncounted trees.
     
     * Finally, do some testing on split/join on _sorted_ trees. At
     * the same time, we'll be testing split on very small trees.
     
     * Test silly cases of join: join(emptytree, emptytree), and
     * also ensure join correctly spots when sorted trees fail the
     * ordering constraint.
      just in case :-) 
     * So:
     *  - join(tree,tree3) should leave both tree and tree3 unchanged.
     *  - joinr(tree,tree2) should leave both tree and tree2 unchanged.
     *  - join(tree4,tree3) should leave both tree3 and tree4 unchanged.
     *  - join(tree, tree2) should move the element from tree2 to tree.
     *  - joinr(tree4, tree3) should move the element from tree4 to tree3.
     *  - join(tree,tree3) should return NULL and leave both unchanged.
     *  - join(tree3,tree) should work and create a bigger tree in tree3.
      sorted list of strings might be useful 
 * tree234.c: reasonably generic counted 2-3-4 tree routines.
 * 
 * This file is copyright 1999-2001 Simon Tatham.
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL SIMON TATHAM BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
  for smalloc/sfree 
 * Create a 2-3-4 tree.
 
 * Free a 2-3-4 tree (not including freeing the elements).
 
 * Internal function to count a node.
 
 * Count the elements in a tree.
 
 * Propagate a node overflow up a tree until it stops. Returns 0 or
 * 1, depending on whether the root had to be split or not.
 
     * We need to insert the new left/element/right set in n at
     * child position ki.
     
	     * Insert in a 2-node; simple.
	      ki == 1 
	     * Insert in a 3-node; simple.
	      ki == 2 
	     * Insert in a 4-node; split into a 2-node and a
	     * 3-node, and move focus up a level.
	     * 
	     * I don't think it matters which way round we put the
	     * 2 and the 3. For simplicity, we'll put the 3 first
	     * always.
	      e = e;  ki == 3 
     * If we've come out of here by `break', n will still be
     * non-NULL and all we need to do is go back up the tree
     * updating counts. If we've come here because n is NULL, we
     * need to create a new root for the tree because the old one
     * has just split into two.  root unchanged  root moved 
 * Add an element e to a 2-3-4 tree t. Returns e on success, or if
 * an existing element compares equal, returns that.
 
		 * Leaf node. We want to insert at kid position
		 * equal to the index:
		 * 
		 *   0 A 1 B 2 C 3
		 
		 * Internal node. We always descend through it (add
		 * always starts at the bottom, never in the
		 * middle).
		  error: index out of range  already exists  already exists  already exists  tree is unsorted  index out of range  tree is sorted  return failure  this checks the upper bound 
 * Look up the element at a given numeric index in a 2-3-4 tree.
 * Returns NULL if the index is out of range.
  tree is empty  out of range  We shouldn't ever get here. I wonder how we did. 
 * Find an element e in a sorted 2-3-4 tree t. Returns NULL if not
 * found. e is always passed as the first argument to cmp, so cmp
 * can be an asymmetric function if desired. cmp can also be passed
 * as NULL, in which case the compare function from the tree proper
 * will be used.
 
     * Attempt to find the element itself.
     
     * Prepare a fake `cmp' result if e is NULL.
      e is a max: always greater  e is a min: always smaller 
	 * We have found the element we're looking for. It's
	 * n->elems[ecount], at tree index idx. If our search
	 * relation is EQ, LE or GE we can now go home.
	 
	 * Otherwise, we'll do an indexed lookup for the previous
	 * or next element. (It would be perfectly possible to
	 * implement these search types in a non-counted tree by
	 * going back up from where we are, but far more fiddly.)
	 
	 * We've found our way to the bottom of the tree and we
	 * know where we would insert this node if we wanted to:
	 * we'd put it in in place of the (empty) subtree
	 * n->kids[kcount], and it would have index idx
	 * 
	 * But the actual element isn't there. So if our search
	 * relation is EQ, we're doomed.
	 
	 * Otherwise, we must do an index lookup for index idx-1
	 * (if we're going left - LE or LT) or index idx (if we're
	 * going right - GE or GT).
	 
     * We know the index of the element we want; just call index234
     * to do the rest. This will return NULL if the index is out of
     * bounds, which is exactly what we want.
     
 * Tree transformation used in delete and split: move a subtree
 * right, from child ki of a node to the next child. Update k and
 * index so that they still point to the same place in the
 * transformed tree. Assumes the destination child is not full, and
 * that the source child does have a subtree to spare. Can cope if
 * the destination child is undersized.
 * 
 *                . C .                     . B .
 *               /     \     ->            /     \
 * [more] a A b B c   d D e      [more] a A b   c C d D e
 * 
 *                 . C .                     . B .
 *                /     \    ->             /     \
 *  [more] a A b B c     d        [more] a A b   c C d
 
     * Move over the rest of the destination node to make space.
      which element to move over 
 * Tree transformation used in delete and split: move a subtree
 * left, from child ki of a node to the previous child. Update k
 * and index so that they still point to the same place in the
 * transformed tree. Assumes the destination child is not full, and
 * that the source child does have a subtree to spare. Can cope if
 * the destination child is undersized. 
 *
 *      . B .                             . C .
 *     /     \                ->         /     \
 *  a A b   c C d D e [more]      a A b B c   d D e [more]
 *
 *     . A .                             . B .
 *    /     \                 ->        /     \
 *   a   b B c C d [more]            a A b   c C d [more]
  where in dest to put it 
     * Move over the rest of the source node.
     
 * Tree transformation used in delete and split: merge child nodes
 * ki and ki+1 of a node. Update k and index so that they still
 * point to the same place in the transformed tree. Assumes both
 * children _are_ sufficiently small.
 *
 *      . B .                .
 *     /     \     ->        |
 *  a A b   c C d      a A b B c C d
 * 
 * This routine can also cope with either child being undersized:
 * 
 *     . A .                 .
 *    /     \      ->        |
 *   a     b B c         a A b B c
 *
 *    . A .                  .
 *   /     \       ->        |
 *  a   b B c C d      a A b B c C d
  neither is large! 
     * Move the rest of n up by one.
     
 * Delete an element e in a 2-3-4 tree. Does not free the element,
 * merely removes all links to it from the tree nodes.
  by assumption this is non-NULL  can't happen  n is a leaf node; we're here! 
	 * Check to see if we've found our target element. If so,
	 * we must choose a new target (we'll use the old target's
	 * successor, which will be in a leaf), move it into the
	 * place of the old one, continue down to the leaf and
	 * delete the old copy of the new target.
	  must be a kid _before_ an element 
	 * Recurse down to subtree ki. If it has only one element,
	 * we have to do some transformation to start with.
	 
		 * Child ki has only one element, but child
		 * ki-1 has two or more. So we need to move a
		 * subtree from ki-1 to ki.
		 
		 * Child ki has only one element, but ki+1 has
		 * two or more. Move a subtree from ki+1 to ki.
		 
		 * ki is small with only small neighbours. Pick a
		 * neighbour and merge with it.
		 
		     * The root is empty and needs to be
		     * removed.
		     
     * Now n is a leaf node, and ki marks the element number we
     * want to delete. We've already arranged for the leaf to be
     * bigger than minimum size, so let's just go to it.
     
     * It's just possible that we have reduced the leaf to zero
     * size. This can only happen if it was the root - so destroy
     * it and make the tree empty.
      finished!  it wasn't in there anyway  it's there; delete it. 
 * Join two subtrees together with a separator element between
 * them, given their relative height.
 * 
 * (Height<0 means the left tree is shorter, >0 means the right
 * tree is shorter, =0 means (duh) they're equal.)
 * 
 * It is assumed that any checks needed on the ordering criterion
 * have _already_ been done.
 * 
 * The value returned in `height' is 0 or 1 depending on whether the
 * resulting tree is the same height as the original larger one, or
 * one higher.
 
	 * The trees are the same height. Create a new one-element
	 * root containing the separator and pointers to the two
	 * nodes.
	 
     * This now works like the addition algorithm on the larger
     * tree. We're replacing a single kid pointer with two kid
     * pointers separated by an element; if that causes the node to
     * overload, we split it in two, move a separator element up to
     * the next node, and repeat.
     
	 * Left tree is shorter. Search down the right tree to find
	 * the pointer we're inserting at.
	 
	 * Right tree is shorter; search down the left to find the
	 * pointer we're inserting at.
	 
     * Now proceed as for addition.
     
 * Split out the first <index> elements in a tree and return a
 * pointer to the root node. Leave the root node of the remainder
 * in t.
 
     * Easy special cases. After this we have also dealt completely
     * with the empty-tree case and we can assume the root exists.
      return nothing  return the whole tree 
     * Search down the tree to find the split point.
     
	 * Split the node, put halves[0] on the right of the left
	 * one and halves[1] on the left of the right one, put the
	 * new node pointers in halves[0] and halves[1], and go up
	 * a level.
	 
     * We've come off the bottom here, so we've successfully split
     * the tree into two equally high subtrees. The only problem is
     * that some of the nodes down the fault line will be smaller
     * than the minimum permitted size. (Since this is a 2-3-4
     * tree, that means they'll be zero-element one-child nodes.)
     
     * So now we go back down the tree from each of the two roots,
     * fixing up undersize nodes.
     
	 * Remove the root if it's undersize (it will contain only
	 * one child pointer, so just throw it away and replace it
	 * with its child). This might happen several times.
	 
	     * Now we have a potentially undersize node on the
	     * right (if half==0) or left (if half==1). Sort it
	     * out, by merging with a neighbour or by transferring
	     * subtrees over. At this time we must also ensure that
	     * nodes are bigger than minimum, in case we need an
	     * element to merge two nodes below.
	      the kid we're interested in  the neighbour  for merge: leftmost of the two 
		 * This node is undersized or minimum-size. If we
		 * can merge it with its neighbour, we do so;
		 * otherwise we must be able to transfer subtrees
		 * over to it until it is greater than minimum
		 * size.
		 
		     * Neighbour is small, or possibly neighbour is
		     * medium and we are undersize.
		     
			 * n is empty, and hence must have been the
			 * root and needs to be removed.
			  Neighbour is big enough to move trees over.  error  We want to return the ones before the index. 
	 * We want to keep the ones before the index and return the
	 * ones after.
	 
 * Test code for the 2-3-4 tree. This code maintains an alternative
 * representation of the data in the tree, in an array (using the
 * obvious and slow insert and delete functions). After each tree
 * operation, the verify() function is called, which ensures all
 * the tree properties are preserved:
 *  - node->child->parent always equals node
 *  - tree->root->parent always equals NULL
 *  - number of kids == 0 or number of elements + 1;
 *  - tree has the same depth everywhere
 *  - every node has at least one element
 *  - subtree element counts are accurate
 *  - any NULL kid pointer is accompanied by a zero count
 *  - in a sorted tree: ordering property between elements of a
 *    node and elements of its children is preserved
 * and also ensures the list represented by the tree is the same
 * list it should be. (This last check also doubly verifies the
 * ordering properties, because the `same list it should be' is by
 * definition correctly ordered. It also ensures all nodes are
 * distinct, because the enum functions would get caught in a loop
 * if not.)
 
 * Error reporting function.
  The array representation of the data.  The tree representation of the same data. 
 * Routines to provide a diagnostic printout of a tree. Currently
 * relies on every element in the tree being a one-character string
 * :-)
  Count the non-NULL kids.  Ensure no kids beyond the first NULL are non-NULL.  Count the non-NULL elements.  Ensure no elements beyond the first NULL are non-NULL. 
         * If nkids==0, this is a leaf node; verify that the tree
         * depth is the same everywhere.
          we didn't know the depth yet 
         * If nkids != 0, then it should be nelems+1, unless nelems
         * is 0 in which case nkids should also be 0 (and so we
         * shouldn't be in this condition at all).
         
     * nelems should be at least 1.
     
     * Add nelems to the running element count of the whole tree.
     
     * Check ordering property: all elements should be strictly >
     * lowbound, strictly < highbound, and strictly < each other in
     * sequence. (lowbound and highbound are NULL at edges of tree
     * - both NULL at root node - and NULL is considered to be <
     * everything and > everything. IYSWIM.)
     
     * Check parent pointers: all non-NULL kids should have a
     * parent pointer coming back to this node.
     
     * Now (finally!) recurse into subtrees.
      depth unknown yet  no elements seen yet 
     * Verify validity of tree properties.
     
     * Enumerate the tree and ensure it matches up to the array.
      now i points to the first element >= elem  expect elem returned (success)  add elem to array  expect that returned not elem  i points to the right element  delete elem from array  don't do it!  A sample data set and test utility. Designed for pseudo-randomness,
 * and yet repeatability. 
 * This random number generator uses the `portable implementation'
 * given in ANSI C99 draft N869. It assumes `unsigned' is 32 bits;
 * change it if not.
  left empty by join 
     * Now try an unsorted tree. We don't really need to test
     * delpos234 because we know del234 is based on it, so it's
     * already been tested in the above sorted-tree code; but for
     * completeness we'll use it to tear down our unsorted tree
     * once we've built it.
     
     * While we have this tree in its full form, we'll take a copy
     * of it to use in split and join testing.
      check the copy is accurate 
     * Split tests. Split the tree at every possible point and
     * check the resulting subtrees.
      see if it has a 2-root 
     * Now do the split test again, but on a tree that has a 2-root
     * (if the previous one didn't) or doesn't (if the previous one
     * did).
     
     * Back to the main testing of uncounted trees.
     
     * Finally, do some testing on split/join on _sorted_ trees. At
     * the same time, we'll be testing split on very small trees.
     
     * Test silly cases of join: join(emptytree, emptytree), and
     * also ensure join correctly spots when sorted trees fail the
     * ordering constraint.
      just in case :-) 
     * So:
     *  - join(tree,tree3) should leave both tree and tree3 unchanged.
     *  - joinr(tree,tree2) should leave both tree and tree2 unchanged.
     *  - join(tree4,tree3) should leave both tree3 and tree4 unchanged.
     *  - join(tree, tree2) should move the element from tree2 to tree.
     *  - joinr(tree4, tree3) should move the element from tree4 to tree3.
     *  - join(tree,tree3) should return NULL and leave both unchanged.
     *  - join(tree3,tree) should work and create a bigger tree in tree3.
      sorted list of strings might be useful 
 * tree234.c: reasonably generic counted 2-3-4 tree routines.
 * 
 * This file is copyright 1999-2001 Simon Tatham.
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL SIMON TATHAM BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
  for smalloc/sfree 
 * Create a 2-3-4 tree.
 
 * Free a 2-3-4 tree (not including freeing the elements).
 
 * Internal function to count a node.
 
 * Count the elements in a tree.
 
 * Propagate a node overflow up a tree until it stops. Returns 0 or
 * 1, depending on whether the root had to be split or not.
 
     * We need to insert the new left/element/right set in n at
     * child position ki.
     
	     * Insert in a 2-node; simple.
	      ki == 1 
	     * Insert in a 3-node; simple.
	      ki == 2 
	     * Insert in a 4-node; split into a 2-node and a
	     * 3-node, and move focus up a level.
	     * 
	     * I don't think it matters which way round we put the
	     * 2 and the 3. For simplicity, we'll put the 3 first
	     * always.
	      e = e;  ki == 3 
     * If we've come out of here by `break', n will still be
     * non-NULL and all we need to do is go back up the tree
     * updating counts. If we've come here because n is NULL, we
     * need to create a new root for the tree because the old one
     * has just split into two.  root unchanged  root moved 
 * Add an element e to a 2-3-4 tree t. Returns e on success, or if
 * an existing element compares equal, returns that.
 
		 * Leaf node. We want to insert at kid position
		 * equal to the index:
		 * 
		 *   0 A 1 B 2 C 3
		 
		 * Internal node. We always descend through it (add
		 * always starts at the bottom, never in the
		 * middle).
		  error: index out of range  already exists  already exists  already exists  tree is unsorted  index out of range  tree is sorted  return failure  this checks the upper bound 
 * Look up the element at a given numeric index in a 2-3-4 tree.
 * Returns NULL if the index is out of range.
  tree is empty  out of range  We shouldn't ever get here. I wonder how we did. 
 * Find an element e in a sorted 2-3-4 tree t. Returns NULL if not
 * found. e is always passed as the first argument to cmp, so cmp
 * can be an asymmetric function if desired. cmp can also be passed
 * as NULL, in which case the compare function from the tree proper
 * will be used.
 
     * Attempt to find the element itself.
     
     * Prepare a fake `cmp' result if e is NULL.
      e is a max: always greater  e is a min: always smaller 
	 * We have found the element we're looking for. It's
	 * n->elems[ecount], at tree index idx. If our search
	 * relation is EQ, LE or GE we can now go home.
	 
	 * Otherwise, we'll do an indexed lookup for the previous
	 * or next element. (It would be perfectly possible to
	 * implement these search types in a non-counted tree by
	 * going back up from where we are, but far more fiddly.)
	 
	 * We've found our way to the bottom of the tree and we
	 * know where we would insert this node if we wanted to:
	 * we'd put it in in place of the (empty) subtree
	 * n->kids[kcount], and it would have index idx
	 * 
	 * But the actual element isn't there. So if our search
	 * relation is EQ, we're doomed.
	 
	 * Otherwise, we must do an index lookup for index idx-1
	 * (if we're going left - LE or LT) or index idx (if we're
	 * going right - GE or GT).
	 
     * We know the index of the element we want; just call index234
     * to do the rest. This will return NULL if the index is out of
     * bounds, which is exactly what we want.
     
 * Tree transformation used in delete and split: move a subtree
 * right, from child ki of a node to the next child. Update k and
 * index so that they still point to the same place in the
 * transformed tree. Assumes the destination child is not full, and
 * that the source child does have a subtree to spare. Can cope if
 * the destination child is undersized.
 * 
 *                . C .                     . B .
 *               /     \     ->            /     \
 * [more] a A b B c   d D e      [more] a A b   c C d D e
 * 
 *                 . C .                     . B .
 *                /     \    ->             /     \
 *  [more] a A b B c     d        [more] a A b   c C d
 
     * Move over the rest of the destination node to make space.
      which element to move over 
 * Tree transformation used in delete and split: move a subtree
 * left, from child ki of a node to the previous child. Update k
 * and index so that they still point to the same place in the
 * transformed tree. Assumes the destination child is not full, and
 * that the source child does have a subtree to spare. Can cope if
 * the destination child is undersized. 
 *
 *      . B .                             . C .
 *     /     \                ->         /     \
 *  a A b   c C d D e [more]      a A b B c   d D e [more]
 *
 *     . A .                             . B .
 *    /     \                 ->        /     \
 *   a   b B c C d [more]            a A b   c C d [more]
  where in dest to put it 
     * Move over the rest of the source node.
     
 * Tree transformation used in delete and split: merge child nodes
 * ki and ki+1 of a node. Update k and index so that they still
 * point to the same place in the transformed tree. Assumes both
 * children _are_ sufficiently small.
 *
 *      . B .                .
 *     /     \     ->        |
 *  a A b   c C d      a A b B c C d
 * 
 * This routine can also cope with either child being undersized:
 * 
 *     . A .                 .
 *    /     \      ->        |
 *   a     b B c         a A b B c
 *
 *    . A .                  .
 *   /     \       ->        |
 *  a   b B c C d      a A b B c C d
  neither is large! 
     * Move the rest of n up by one.
     
 * Delete an element e in a 2-3-4 tree. Does not free the element,
 * merely removes all links to it from the tree nodes.
  by assumption this is non-NULL  can't happen  n is a leaf node; we're here! 
	 * Check to see if we've found our target element. If so,
	 * we must choose a new target (we'll use the old target's
	 * successor, which will be in a leaf), move it into the
	 * place of the old one, continue down to the leaf and
	 * delete the old copy of the new target.
	  must be a kid _before_ an element 
	 * Recurse down to subtree ki. If it has only one element,
	 * we have to do some transformation to start with.
	 
		 * Child ki has only one element, but child
		 * ki-1 has two or more. So we need to move a
		 * subtree from ki-1 to ki.
		 
		 * Child ki has only one element, but ki+1 has
		 * two or more. Move a subtree from ki+1 to ki.
		 
		 * ki is small with only small neighbours. Pick a
		 * neighbour and merge with it.
		 
		     * The root is empty and needs to be
		     * removed.
		     
     * Now n is a leaf node, and ki marks the element number we
     * want to delete. We've already arranged for the leaf to be
     * bigger than minimum size, so let's just go to it.
     
     * It's just possible that we have reduced the leaf to zero
     * size. This can only happen if it was the root - so destroy
     * it and make the tree empty.
      finished!  it wasn't in there anyway  it's there; delete it. 
 * Join two subtrees together with a separator element between
 * them, given their relative height.
 * 
 * (Height<0 means the left tree is shorter, >0 means the right
 * tree is shorter, =0 means (duh) they're equal.)
 * 
 * It is assumed that any checks needed on the ordering criterion
 * have _already_ been done.
 * 
 * The value returned in `height' is 0 or 1 depending on whether the
 * resulting tree is the same height as the original larger one, or
 * one higher.
 
	 * The trees are the same height. Create a new one-element
	 * root containing the separator and pointers to the two
	 * nodes.
	 
     * This now works like the addition algorithm on the larger
     * tree. We're replacing a single kid pointer with two kid
     * pointers separated by an element; if that causes the node to
     * overload, we split it in two, move a separator element up to
     * the next node, and repeat.
     
	 * Left tree is shorter. Search down the right tree to find
	 * the pointer we're inserting at.
	 
	 * Right tree is shorter; search down the left to find the
	 * pointer we're inserting at.
	 
     * Now proceed as for addition.
     
 * Split out the first <index> elements in a tree and return a
 * pointer to the root node. Leave the root node of the remainder
 * in t.
 
     * Easy special cases. After this we have also dealt completely
     * with the empty-tree case and we can assume the root exists.
      return nothing  return the whole tree 
     * Search down the tree to find the split point.
     
	 * Split the node, put halves[0] on the right of the left
	 * one and halves[1] on the left of the right one, put the
	 * new node pointers in halves[0] and halves[1], and go up
	 * a level.
	 
     * We've come off the bottom here, so we've successfully split
     * the tree into two equally high subtrees. The only problem is
     * that some of the nodes down the fault line will be smaller
     * than the minimum permitted size. (Since this is a 2-3-4
     * tree, that means they'll be zero-element one-child nodes.)
     
     * So now we go back down the tree from each of the two roots,
     * fixing up undersize nodes.
     
	 * Remove the root if it's undersize (it will contain only
	 * one child pointer, so just throw it away and replace it
	 * with its child). This might happen several times.
	 
	     * Now we have a potentially undersize node on the
	     * right (if half==0) or left (if half==1). Sort it
	     * out, by merging with a neighbour or by transferring
	     * subtrees over. At this time we must also ensure that
	     * nodes are bigger than minimum, in case we need an
	     * element to merge two nodes below.
	      the kid we're interested in  the neighbour  for merge: leftmost of the two 
		 * This node is undersized or minimum-size. If we
		 * can merge it with its neighbour, we do so;
		 * otherwise we must be able to transfer subtrees
		 * over to it until it is greater than minimum
		 * size.
		 
		     * Neighbour is small, or possibly neighbour is
		     * medium and we are undersize.
		     
			 * n is empty, and hence must have been the
			 * root and needs to be removed.
			  Neighbour is big enough to move trees over.  error  We want to return the ones before the index. 
	 * We want to keep the ones before the index and return the
	 * ones after.
	 
 * Test code for the 2-3-4 tree. This code maintains an alternative
 * representation of the data in the tree, in an array (using the
 * obvious and slow insert and delete functions). After each tree
 * operation, the verify() function is called, which ensures all
 * the tree properties are preserved:
 *  - node->child->parent always equals node
 *  - tree->root->parent always equals NULL
 *  - number of kids == 0 or number of elements + 1;
 *  - tree has the same depth everywhere
 *  - every node has at least one element
 *  - subtree element counts are accurate
 *  - any NULL kid pointer is accompanied by a zero count
 *  - in a sorted tree: ordering property between elements of a
 *    node and elements of its children is preserved
 * and also ensures the list represented by the tree is the same
 * list it should be. (This last check also doubly verifies the
 * ordering properties, because the `same list it should be' is by
 * definition correctly ordered. It also ensures all nodes are
 * distinct, because the enum functions would get caught in a loop
 * if not.)
 
 * Error reporting function.
  The array representation of the data.  The tree representation of the same data. 
 * Routines to provide a diagnostic printout of a tree. Currently
 * relies on every element in the tree being a one-character string
 * :-)
  Count the non-NULL kids.  Ensure no kids beyond the first NULL are non-NULL.  Count the non-NULL elements.  Ensure no elements beyond the first NULL are non-NULL. 
         * If nkids==0, this is a leaf node; verify that the tree
         * depth is the same everywhere.
          we didn't know the depth yet 
         * If nkids != 0, then it should be nelems+1, unless nelems
         * is 0 in which case nkids should also be 0 (and so we
         * shouldn't be in this condition at all).
         
     * nelems should be at least 1.
     
     * Add nelems to the running element count of the whole tree.
     
     * Check ordering property: all elements should be strictly >
     * lowbound, strictly < highbound, and strictly < each other in
     * sequence. (lowbound and highbound are NULL at edges of tree
     * - both NULL at root node - and NULL is considered to be <
     * everything and > everything. IYSWIM.)
     
     * Check parent pointers: all non-NULL kids should have a
     * parent pointer coming back to this node.
     
     * Now (finally!) recurse into subtrees.
      depth unknown yet  no elements seen yet 
     * Verify validity of tree properties.
     
     * Enumerate the tree and ensure it matches up to the array.
      now i points to the first element >= elem  expect elem returned (success)  add elem to array  expect that returned not elem  i points to the right element  delete elem from array  don't do it!  A sample data set and test utility. Designed for pseudo-randomness,
 * and yet repeatability. 
 * This random number generator uses the `portable implementation'
 * given in ANSI C99 draft N869. It assumes `unsigned' is 32 bits;
 * change it if not.
  left empty by join 
     * Now try an unsorted tree. We don't really need to test
     * delpos234 because we know del234 is based on it, so it's
     * already been tested in the above sorted-tree code; but for
     * completeness we'll use it to tear down our unsorted tree
     * once we've built it.
     
     * While we have this tree in its full form, we'll take a copy
     * of it to use in split and join testing.
      check the copy is accurate 
     * Split tests. Split the tree at every possible point and
     * check the resulting subtrees.
      see if it has a 2-root 
     * Now do the split test again, but on a tree that has a 2-root
     * (if the previous one didn't) or doesn't (if the previous one
     * did).
     
     * Back to the main testing of uncounted trees.
     
     * Finally, do some testing on split/join on _sorted_ trees. At
     * the same time, we'll be testing split on very small trees.
     
     * Test silly cases of join: join(emptytree, emptytree), and
     * also ensure join correctly spots when sorted trees fail the
     * ordering constraint.
      just in case :-) 
     * So:
     *  - join(tree,tree3) should leave both tree and tree3 unchanged.
     *  - joinr(tree,tree2) should leave both tree and tree2 unchanged.
     *  - join(tree4,tree3) should leave both tree3 and tree4 unchanged.
     *  - join(tree, tree2) should move the element from tree2 to tree.
     *  - joinr(tree4, tree3) should move the element from tree4 to tree3.
     *  - join(tree,tree3) should return NULL and leave both unchanged.
     *  - join(tree3,tree) should work and create a bigger tree in tree3.
      sorted list of strings might be useful 