
 * tents.c: Puzzle involving placing tents next to trees subject to
 * some confusing conditions.
 * 
 * TODO:
 *
 *  - it might be nice to make setter-provided tent/nontent clues
 *    inviolable?
 *     * on the other hand, this would introduce considerable extra
 *       complexity and size into the game state; also inviolable
 *       clues would have to be marked as such somehow, in an
 *       intrusive and annoying manner. Since they're never
 *       generated by _my_ generator, I'm currently more inclined
 *       not to bother.
 * 
 *  - more difficult levels at the top end?
 *     * for example, sometimes we can deduce that two BLANKs in
 *       the same row are each adjacent to the same unattached tree
 *       and to nothing else, implying that they can't both be
 *       tents; this enables us to rule out some extra combinations
 *       in the row-based deduction loop, and hence deduce more
 *       from the number in that row than we could otherwise do.
 *     * that by itself doesn't seem worth implementing a new
 *       difficulty level for, but if I can find a few more things
 *       like that then it might become worthwhile.
 *     * I wonder if there's a sensible heuristic for where to
 *       guess which would make a recursive solver viable?
 
 * Design discussion
 * -----------------
 * 
 * The rules of this puzzle as available on the WWW are poorly
 * specified. The bits about tents having to be orthogonally
 * adjacent to trees, tents not being even diagonally adjacent to
 * one another, and the number of tents in each row and column
 * being given are simple enough; the difficult bit is the
 * tent-to-tree matching.
 * 
 * Some sources use simplistic wordings such as `each tree is
 * exactly connected to only one tent', which is extremely unclear:
 * it's easy to read erroneously as `each tree is _orthogonally
 * adjacent_ to exactly one tent', which is definitely incorrect.
 * Even the most coherent sources I've found don't do a much better
 * job of stating the rule.
 * 
 * A more precise statement of the rule is that it must be possible
 * to find a bijection f between tents and trees such that each
 * tree T is orthogonally adjacent to the tent f(T), but that a
 * tent is permitted to be adjacent to other trees in addition to
 * its own. This slightly non-obvious criterion is what gives this
 * puzzle most of its subtlety.
 * 
 * However, there's a particularly subtle ambiguity left over. Is
 * the bijection between tents and trees required to be _unique_?
 * In other words, is that bijection conceptually something the
 * player should be able to exhibit as part of the solution (even
 * if they aren't actually required to do so)? Or is it sufficient
 * to have a unique _placement_ of the tents which gives rise to at
 * least one suitable bijection?
 * 
 * The puzzle shown to the right of this       .T. 2      *T* 2
 * paragraph illustrates the problem. There    T.T 0  ->  T-T 0
 * are two distinct bijections available.      .T. 2      *T* 2
 * The answer to the above question will
 * determine whether it's a valid puzzle.      202        202
 * 
 * This is an important question, because it affects both the
 * player and the generator. Eventually I found all the instances
 * of this puzzle I could Google up, solved them all by hand, and
 * verified that in all cases the tree/tent matching was uniquely
 * determined given the tree and tent positions. Therefore, the
 * puzzle as implemented in this source file takes the following
 * policy:
 * 
 *  - When checking a user-supplied solution for correctness, only
 *    verify that there exists _at least_ one matching.
 *  - When generating a puzzle, enforce that there must be
 *    _exactly_ one.
 * 
 * Algorithmic implications
 * ------------------------
 * 
 * Another way of phrasing the tree/tent matching criterion is to
 * say that the bipartite adjacency graph between trees and tents
 * has a perfect matching. That is, if you construct a graph which
 * has a vertex per tree and a vertex per tent, and an edge between
 * any tree and tent which are orthogonally adjacent, it is
 * possible to find a set of N edges of that graph (where N is the
 * number of trees and also the number of tents) which between them
 * connect every tree to every tent.
 * 
 * The most efficient known algorithms for finding such a matching
 * given a graph, as far as I'm aware, are the Munkres assignment
 * algorithm (also known as the Hungarian algorithm) and the
 * Ford-Fulkerson algorithm (for finding optimal flows in
 * networks). Each of these takes O(N^3) running time; so we're
 * talking O(N^3) time to verify any candidate solution to this
 * puzzle. That's just about OK if you're doing it once per mouse
 * click (and in fact not even that, since the sensible thing to do
 * is check all the _other_ puzzle criteria and only wade into this
 * quagmire if none are violated); but if the solver had to keep
 * doing N^3 work internally, then it would probably end up with
 * more like N^5 or N^6 running time, and grid generation would
 * become very clunky.
 * 
 * Fortunately, I've been able to prove a very useful property of
 * _unique_ perfect matchings, by adapting the proof of Hall's
 * Marriage Theorem. For those unaware of Hall's Theorem, I'll
 * recap it and its proof: it states that a bipartite graph
 * contains a perfect matching iff every set of vertices on the
 * left side of the graph have a neighbourhood _at least_ as big on
 * the right.
 * 
 * This condition is obviously satisfied if a perfect matching does
 * exist; each left-side node has a distinct right-side node which
 * is the one assigned to it by the matching, and thus any set of n
 * left vertices must have a combined neighbourhood containing at
 * least the n corresponding right vertices, and possibly others
 * too. Alternatively, imagine if you had (say) three left-side
 * nodes all of which were connected to only two right-side nodes
 * between them: any perfect matching would have to assign one of
 * those two right nodes to each of the three left nodes, and still
 * give the three left nodes a different right node each. This is
 * of course impossible.
 *
 * To prove the converse (that if every subset of left vertices
 * satisfies the Hall condition then a perfect matching exists),
 * consider trying to find a proper subset of the left vertices
 * which _exactly_ satisfies the Hall condition: that is, its right
 * neighbourhood is precisely the same size as it. If we can find
 * such a subset, then we can split the bipartite graph into two
 * smaller ones: one consisting of the left subset and its right
 * neighbourhood, the other consisting of everything else. Edges
 * from the left side of the former graph to the right side of the
 * latter do not exist, by construction; edges from the right side
 * of the former to the left of the latter cannot be part of any
 * perfect matching because otherwise the left subset would not be
 * left with enough distinct right vertices to connect to (this is
 * exactly the same deduction used in Solo's set analysis). You can
 * then prove (left as an exercise) that both these smaller graphs
 * still satisfy the Hall condition, and therefore the proof will
 * follow by induction.
 * 
 * There's one other possibility, which is the case where _no_
 * proper subset of the left vertices has a right neighbourhood of
 * exactly the same size. That is, every left subset has a strictly
 * _larger_ right neighbourhood. In this situation, we can simply
 * remove an _arbitrary_ edge from the graph. This cannot reduce
 * the size of any left subset's right neighbourhood by more than
 * one, so if all neighbourhoods were strictly bigger than they
 * needed to be initially, they must now still be _at least as big_
 * as they need to be. So we can keep throwing out arbitrary edges
 * until we find a set which exactly satisfies the Hall condition,
 * and then proceed as above. []
 * 
 * That's Hall's theorem. I now build on this by examining the
 * circumstances in which a bipartite graph can have a _unique_
 * perfect matching. It is clear that in the second case, where no
 * left subset exactly satisfies the Hall condition and so we can
 * remove an arbitrary edge, there cannot be a unique perfect
 * matching: given one perfect matching, we choose our arbitrary
 * removed edge to be one of those contained in it, and then we can
 * still find a perfect matching in the remaining graph, which will
 * be a distinct perfect matching in the original.
 * 
 * So it is a necessary condition for a unique perfect matching
 * that there must be at least one proper left subset which
 * _exactly_ satisfies the Hall condition. But now consider the
 * smaller graph constructed by taking that left subset and its
 * neighbourhood: if the graph as a whole had a unique perfect
 * matching, then so must this smaller one, which means we can find
 * a proper left subset _again_, and so on. Repeating this process
 * must eventually reduce us to a graph with only one left-side
 * vertex (so there are no proper subsets at all); this vertex must
 * be connected to only one right-side vertex, and hence must be so
 * in the original graph as well (by construction). So we can
 * discard this vertex pair from the graph, and any other edges
 * that involved it (which will by construction be from other left
 * vertices only), and the resulting smaller graph still has a
 * unique perfect matching which means we can do the same thing
 * again.
 * 
 * In other words, given any bipartite graph with a unique perfect
 * matching, we can find that matching by the following extremely
 * simple algorithm:
 * 
 *  - Find a left-side vertex which is only connected to one
 *    right-side vertex.
 *  - Assign those vertices to one another, and therefore discard
 *    any other edges connecting to that right vertex.
 *  - Repeat until all vertices have been matched.
 * 
 * This algorithm can be run in O(V+E) time (where V is the number
 * of vertices and E is the number of edges in the graph), and the
 * only way it can fail is if there is not a unique perfect
 * matching (either because there is no matching at all, or because
 * it isn't unique; but it can't distinguish those cases).
 * 
 * Thus, the internal solver in this source file can be confident
 * that if the tree/tent matching is uniquely determined by the
 * tree and tent positions, it can find it using only this kind of
 * obvious and simple operation: assign a tree to a tent if it
 * cannot possibly belong to any other tent, and vice versa. If the
 * solver were _only_ trying to determine the matching, even that
 * `vice versa' wouldn't be required; but it can come in handy when
 * not all the tents have been placed yet. I can therefore be
 * reasonably confident that as long as my solver doesn't need to
 * cope with grids that have a non-unique matching, it will also
 * not need to do anything complicated like set analysis between
 * trees and tents.
 
 * In standalone solver mode, `verbose' is a variable which can be
 * set by command-line option; in debugging mode it's simply always
 * true.
 
 * Difficulty levels. I do some macro ickery here to ensure that my
 * enum and the various forms of my name list always match up.
  structure copy 
     * Generating anything under 4x4 runs into trouble of one kind
     * or another.
     
 * Scratch space for solver.
  link directions  mapping between trees and tents 
 * Solver. Returns 0 for impossibility, 1 for success, 2 for
 * ambiguity or failure to converge.
 
     * Set up solver data.
     
     * Set up solution array.
     
     * Main solver loop.
     
	 * Any tent which has only one unattached tree adjacent to
	 * it can be tied to that tree.
	  found more than one  no solution exists  don't do anything else! 
	 * Mark a blank square as NONTENT if it is not orthogonally
	 * adjacent to any unmatched tree.
	 
	 * Mark a blank square as NONTENT if it is (perhaps
	 * diagonally) adjacent to any other tent.
	 
	 * Any tree which has exactly one {unattached tent, BLANK}
	 * adjacent to it must have its tent in that square.
	  no solution exists 
			 * If there are two possible places where
			 * this tree's tent can go, and they are
			 * diagonally separated rather than being
			 * on opposite sides of the tree, then the
			 * square (other than the tree square)
			 * which is adjacent to both of them must
			 * be a non-tent.
			 
	 * If localised deductions about the trees and tents
	 * themselves haven't helped us, it's time to resort to the
	 * numbers round the grid edge. For each row and column, we
	 * go through all possible combinations of locations for
	 * the unplaced tents, rule out any which have adjacent
	 * tents, and spot any square which is given the same state
	 * by all remaining combinations.
	 
		 * This is the number for a column.
		 
		 * This is the number for a row.
		 
		 * In Easy mode, we don't look at the effect of one
		 * row on the next (i.e. ruling out a square if all
		 * possibilities for an adjacent row place a tent
		 * next to it).
		 
	     * Count and store the locations of the free squares,
	     * and also count the number of tents already placed.
	      one fewer tent to place  nothing left to do here 
	     * Now we know we're placing k tents in n squares. Set
	     * up the first possibility.
	     
	     * We're aiming to find squares in this row which are
	     * invariant over all valid possibilities. Thus, we
	     * maintain the current state of that invariance. We
	     * start everything off at MAGIC to indicate that it
	     * hasn't been set up yet.
	     
	     * And iterate over all possibilities.
	     
		 * See if this possibility is valid. The only way
		 * it can fail to be valid is if it contains two
		 * adjacent tents. (Other forms of invalidity, such
		 * as containing a tent adjacent to one already
		 * placed, will have been dealt with already by
		 * other parts of the solver.)
		 
		     * Merge this valid combination into mrow.
		     
			     * Either this is the first valid
			     * placement we've found at all, or
			     * this square's contents are
			     * consistent with every previous valid
			     * combination.
			     
			     * This square's contents fail to match
			     * what they were in a different
			     * combination, so we cannot deduce
			     * anything about this square.
			     
		 * Find the next combination of k choices from n.
		 * We do this by finding the rightmost tent which
		 * can be moved one place right, doing so, and
		 * shunting all tents to the right of that as far
		 * left as they can go.
		  we've finished 
	     * It's just possible that _no_ placement was valid, in
	     * which case we have an internally inconsistent
	     * puzzle.
	      inconsistent 
	     * Now go through mrow and see if there's anything
	     * we've deduced which wasn't already mentioned in soln.
	     
     * The solver has nothing further it can do. Return 1 if both
     * soln and sc->links are completely filled in, or 2 otherwise.
      structure copy 
     * Since this puzzle has many global deductions and doesn't
     * permit limited clue sets, generating grids for this puzzle
     * is hard enough that I see no better option than to simply
     * generate a solution and see if it's unique and has the
     * required difficulty. This turns out to be computationally
     * plausible as well.
     * 
     * We chose our tree count (hence also tent count) by dividing
     * the total grid area by five above. Why five? Well, w*h/4 is
     * the maximum number of tents you can _possibly_ fit into the
     * grid without violating the separation criterion, and to
     * achieve that you are constrained to a very small set of
     * possible layouts (the obvious one with a tent at every
     * (even,even) coordinate, and trivial variations thereon). So
     * if we reduce the tent count a bit more, we enable more
     * random-looking placement; 5 turns out to be a plausible
     * figure which yields sensible puzzles. Increasing the tent
     * count would give puzzles whose solutions were too regimented
     * and could be solved by the use of that knowledge (and would
     * also take longer to find a viable placement); decreasing it
     * would make the grids emptier and more boring.
     * 
     * Actually generating a grid is a matter of first placing the
     * tents, and then placing the trees by the use of matching.c
     * (finding a distinct square adjacent to every tent). We do it
     * this way round because otherwise satisfying the tent
     * separation condition would become onerous: most randomly
     * chosen tent layouts do not satisfy this condition, so we'd
     * have gone to a lot of work before finding that a candidate
     * layout was unusable. Instead, we place the tents first and
     * ensure they meet the separation criterion _before_ doing
     * lots of computation; this works much better.
     * 
     * This generation strategy can fail at many points, including
     * as early as tent placement (if you get a bad random order in
     * which to greedily try the grid squares, you won't even
     * manage to find enough mutually non-adjacent squares to put
     * the tents in). Then it can fail if matching.c doesn't manage
     * to find a good enough matching (i.e. the tent placements don't
     * admit any adequate tree placements); and finally it can fail
     * if the solver finds that the problem has the wrong
     * difficulty (including being actually non-unique). All of
     * these, however, are insufficiently frequent to cause
     * trouble.
      downgrade to prevent tight loop 
	 * Make a list of grid squares which we'll permute as we pick
	 * the tent locations.
         *
         * We'll also need to index all the potential tree squares,
         * i.e. the ones adjacent to the tents.
	 
	 * Place tents at random without making any two adjacent.
	  Loop end condition: either j==0 (we've placed all the
         * tents), or the number of grid squares we have yet to try
         * is too few to fit the remaining tents into.  couldn't place all the tents 
	 * Build up the graph for matching.c.
	 
	 * Call the matching algorithm to actually place the trees.
	  couldn't place all the trees 
	 * Fill in the trees in the grid, by cross-referencing treemap
	 * (which maps a grid square to its index as known to
	 * matching()) against the output from matching().
         *
         * Note that for these purposes we don't actually care _which_
         * tent each potential tree square is assigned to - we only
         * care whether it was assigned to any tent at all, in order
         * to decide whether to put a tree in it.
	 
	 * I think it looks ugly if there isn't at least one of
	 * _something_ (tent or tree) in each row and each column
	 * of the grid. This doesn't give any information away
	 * since a completely empty row/column is instantly obvious
	 * from the clues (it has no trees and a zero).
	  found something in this column  found empty column  a column was empty  found something in this row  found empty row  a row was empty 
	 * Now set up the numbers round the edge.
	 
	 * And now actually solve the puzzle, to see whether it's
	 * unique and has the required difficulty.
	 
         * We expect solving with difficulty params->diff to have
         * succeeded (otherwise the problem is too hard), and
         * solving with diff-1 to have failed (otherwise it's too
         * easy).
         
     * That's it. Encode as a game ID.
     
     * And encode the solution as an aux_info.
      do nothing  structure copy  structure copy 
	 * If we already have the solution, save ourselves some
	 * time.
	 
         * Construct a move string which turns the current state
         * into the solved state.
          999 tents  NOP  coords of drag start  coords of drag end  -1 for none, or a button code  dragged off the window, to cancel  cursor position.  is cursor displayed?  last-drawn cursor pos, or (-1,-1) if absent. 
     * Left-dragging has no effect, so we treat a left-drag as a
     * single click on dsx,dsy.
      no change outside drag area  trees are inviolate always 
         * Results of a simple click. Left button sets blanks to
         * tents; right button sets blanks to non-tents; either
         * button clears a non-blank square.
         * If stylus-based however, it loops instead.
         
         * Results of a drag. Left-dragging has no effect.
         * Right-dragging sets all blank squares to non-tents and
         * has no effect on anything else.
          do nothing 
             * Drags are limited to one row or column. Hence, we
             * work out which coordinate is closer to the drag
             * start, and move it _to_ the drag start.
             
         * The drag has been released. Enact it.
          drag was just cancelled  drag is terminated  drag was terminated  NONTENTify all unique traversed eligible squares  SELECT cycles T, N, B 
             * Set all non-tree squares to NONTENT. The rest of the
             * solve move will fill the tents in over the top.
             
     * Check for completion.
     
         * We have the right number of tents, which is a
         * precondition for the game being complete. Now check that
         * the numbers add up.
         
         * Also, check that no two tents are adjacent.
         
         * OK; we have the right number of tents, they match the
         * numeric clues, and they satisfy the non-adjacency
         * criterion. Finally, we need to verify that they can be
         * placed in a one-to-one matching with the trees such that
         * every tent is orthogonally adjacent to its tree.
         * 
         * This bit is where the hard work comes in: we have to do
         * it by finding such a matching using matching.c.
          Assign each tent and tree a consecutive vertex id for
         * matching().  Build the vertices' adjacency lists. 
                     * Here we use the direction enum declared for
                     * the solver. We make use of the fact that the
                     * directions are declared in the order
                     * U,L,R,D, meaning that we go through the four
                     * neighbours of any square in numerically
                     * increasing order.
                     
         * We haven't managed to fault the grid on any count. Score!
          ----------------------------------------------------------------------
 * Drawing routines.
  fool the macros  structure copy 
     * This function goes through a grid and works out where to
     * highlight play errors in red. The aim is that it should
     * produce at least one error highlight for any complete grid
     * (or complete piece of grid) violating a puzzle constraint, so
     * that a grid containing no BLANK squares is either a win or is
     * marked up in some way that indicates why not.
     *
     * So it's easy enough to highlight errors in the numeric clues
     * - just light up any row or column number which is not
     * fulfilled - and it's just as easy to highlight adjacent
     * tents. The difficult bit is highlighting failures in the
     * tent/tree matching criterion.
     *
     * A natural approach would seem to be to apply the matching.c
     * algorithm to find the tent/tree matching; if this fails, it
     * could be made to produce as a by-product some set of trees
     * which have too few tents between them (or vice versa). However,
     * it's bad for localising errors, because it's not easy to make
     * the algorithm narrow down to the _smallest_ such set of trees:
     * if trees A and B have only one tent between them, for instance,
     * it might perfectly well highlight not only A and B but also
     * trees C and D which are correctly matched on the far side of
     * the grid, on the grounds that those four trees between them
     * have only three tents.
     *
     * Also, that approach fares badly when you introduce the
     * additional requirement that incomplete grids should have
     * errors highlighted only when they can be proved to be errors
     * - so that trees should not be marked as having too few tents
     * if there are enough BLANK squares remaining around them that
     * could be turned into the missing tents (to do so would be
     * patronising, since the overwhelming likelihood is not that
     * the player has forgotten to put a tree there but that they
     * have merely not put one there _yet_). However, tents with too
     * few trees can be marked immediately, since those are
     * definitely player error.
     *
     * So I adopt an alternative approach, which is to consider the
     * bipartite adjacency graph between trees and tents
     * ('bipartite' in the sense that for these purposes I
     * deliberately ignore two adjacent trees or two adjacent
     * tents), divide that graph up into its connected components
     * using a dsf, and look for components which contain different
     * numbers of trees and tents. This allows me to highlight
     * groups of tents with too few trees between them immediately,
     * and then in order to find groups of trees with too few tents
     * I redo the same process but counting BLANKs as potential
     * tents (so that the only trees highlighted are those
     * surrounded by enough NONTENTs to make it impossible to give
     * them enough tents).
     *
     * However, this technique is incomplete: it is not a sufficient
     * condition for the existence of a perfect matching that every
     * connected component of the graph has the same number of tents
     * and trees. An example of a graph which satisfies the latter
     * condition but still has no perfect matching is
     * 
     *     A    B    C
     *     |   /   ,/|
     *     |  /  ,'/ |
     *     | / ,' /  |
     *     |/,'  /   |
     *     1    2    3
     *
     * which can be realised in Tents as
     * 
     *       B
     *     A 1 C 2
     *         3
     *
     * The matching-error highlighter described above will not mark
     * this construction as erroneous. However, something else will:
     * the three tents in the above diagram (let us suppose A,B,C
     * are the tents, though it doesn't matter which) contain two
     * diagonally adjacent pairs. So there will be _an_ error
     * highlighted for the above layout, even though not all types
     * of error will be highlighted.
     *
     * And in fact we can prove that this will always be the case:
     * that the shortcomings of the matching-error highlighter will
     * always be made up for by the easy tent adjacency highlighter.
     *
     * Lemma: Let G be a bipartite graph between n trees and n
     * tents, which is connected, and in which no tree has degree
     * more than two (but a tent may). Then G has a perfect matching.
     * 
     * (Note: in the statement and proof of the Lemma I will
     * consistently use 'tree' to indicate a type of graph vertex as
     * opposed to a tent, and not to indicate a tree in the graph-
     * theoretic sense.)
     *
     * Proof:
     * 
     * If we can find a tent of degree 1 joined to a tree of degree
     * 2, then any perfect matching must pair that tent with that
     * tree. Hence, we can remove both, leaving a smaller graph G'
     * which still satisfies all the conditions of the Lemma, and
     * which has a perfect matching iff G does.
     *
     * So, wlog, we may assume G contains no tent of degree 1 joined
     * to a tree of degree 2; if it does, we can reduce it as above.
     *
     * If G has no tent of degree 1 at all, then every tent has
     * degree at least two, so there are at least 2n edges in the
     * graph. But every tree has degree at most two, so there are at
     * most 2n edges. Hence there must be exactly 2n edges, so every
     * tree and every tent must have degree exactly two, which means
     * that the whole graph consists of a single loop (by
     * connectedness), and therefore certainly has a perfect
     * matching.
     *
     * Alternatively, if G does have a tent of degree 1 but it is
     * not connected to a tree of degree 2, then the tree it is
     * connected to must have degree 1 - and, by connectedness, that
     * must mean that that tent and that tree between them form the
     * entire graph. This trivial graph has a trivial perfect
     * matching. []
     *
     * That proves the lemma. Hence, in any case where the matching-
     * error highlighter fails to highlight an erroneous component
     * (because it has the same number of tents as trees, but they
     * cannot be matched up), the above lemma tells us that there
     * must be a tree with degree more than 2, i.e. a tree
     * orthogonally adjacent to at least three tents. But in that
     * case, there must be some pair of those three tents which are
     * diagonally adjacent to each other, so the tent-adjacency
     * highlighter will necessarily show an error. So any filled
     * layout in Tents which is not a correct solution to the puzzle
     * must have _some_ error highlighted by the subroutine below.
     *
     * (Of course it would be nicer if we could highlight all
     * errors: in the above example layout, we would like to
     * highlight tents A,B as having too few trees between them, and
     * trees 2,3 as having too few tents, in addition to marking the
     * adjacency problems. But I can't immediately think of any way
     * to find the smallest sets of such tents and trees without an
     * O(2^N) loop over all subsets of a given component.)
     
     * ret[0] through to ret[w*h-1] give error markers for the grid
     * squares. After that, ret[w*h] to ret[w*h+w-1] give error
     * markers for the column numbers, and ret[w*h+w] to
     * ret[w*h+w+h-1] for the row numbers.
     
     * Spot tent-adjacency violations.
     
     * Spot numeric clue violations.
     
     * Identify groups of tents with too few trees between them,
     * which we do by constructing the connected components of the
     * bipartite adjacency graph between tents and trees
     * ('bipartite' in the sense that we deliberately ignore
     * adjacency between tents or between trees), and highlighting
     * all the tents in any component which has a smaller tree
     * count.
      Construct the equivalence classes.  Count up the tent/tree difference in each one.  And highlight any tent belonging to an equivalence class with
     * a score less than zero. 
     * Identify groups of trees with too few tents between them.
     * This is done similarly, except that we now count BLANK as
     * equivalent to TENT, i.e. we only highlight such trees when
     * the user hasn't even left _room_ to provide tents for them
     * all. (Otherwise, we'd highlight all trees red right at the
     * start of the game, before the user had done anything wrong!)
      Construct the equivalence classes.  Count up the tent/tree difference in each one.  And highlight any tree belonging to an equivalence class with
     * a score more than zero. 
     * Draw a diamond.
     
     * Draw an exclamation mark in the diamond. This turns out to
     * look unpleasantly off-centre if done via draw_text, so I do
     * it by hand on the basis that exclamation marks aren't that
     * difficult to draw...
     
 * Internal redraw function, used for printing as well as drawing.
 
         * Draw the grid.
         
     * Find errors. For this we use _part_ of the information from a
     * currently active drag: we transform dsx,dsy but not anything
     * else. (This seems to strike a good compromise between having
     * the error highlights respond instantly to single clicks, but
     * not giving constant feedback during a right-drag.)
     
     * Draw the grid.
     
             * We deliberately do not take drag_ok into account
             * here, because user feedback suggests that it's
             * marginally nicer not to have the drag effects
             * flickering on and off disconcertingly.
             
     * Draw (or redraw, if their error-highlighted state has
     * changed) the numbers.
     
     * I'll use 6mm squares by default.
      Ick: fake up `ds->tilesize' for macro expansion purposes  game_request_keys  wants_statusbar  flags 
     * When solving an Easy puzzle, we don't want to bother the
     * user with Hard-level deductions. For this reason, we grade
     * the puzzle internally before doing anything else.
      placate optimiser  vim: set shiftwidth=4 tabstop=8: 
 * tents.c: Puzzle involving placing tents next to trees subject to
 * some confusing conditions.
 * 
 * TODO:
 *
 *  - it might be nice to make setter-provided tent/nontent clues
 *    inviolable?
 *     * on the other hand, this would introduce considerable extra
 *       complexity and size into the game state; also inviolable
 *       clues would have to be marked as such somehow, in an
 *       intrusive and annoying manner. Since they're never
 *       generated by _my_ generator, I'm currently more inclined
 *       not to bother.
 * 
 *  - more difficult levels at the top end?
 *     * for example, sometimes we can deduce that two BLANKs in
 *       the same row are each adjacent to the same unattached tree
 *       and to nothing else, implying that they can't both be
 *       tents; this enables us to rule out some extra combinations
 *       in the row-based deduction loop, and hence deduce more
 *       from the number in that row than we could otherwise do.
 *     * that by itself doesn't seem worth implementing a new
 *       difficulty level for, but if I can find a few more things
 *       like that then it might become worthwhile.
 *     * I wonder if there's a sensible heuristic for where to
 *       guess which would make a recursive solver viable?
 
 * Design discussion
 * -----------------
 * 
 * The rules of this puzzle as available on the WWW are poorly
 * specified. The bits about tents having to be orthogonally
 * adjacent to trees, tents not being even diagonally adjacent to
 * one another, and the number of tents in each row and column
 * being given are simple enough; the difficult bit is the
 * tent-to-tree matching.
 * 
 * Some sources use simplistic wordings such as `each tree is
 * exactly connected to only one tent', which is extremely unclear:
 * it's easy to read erroneously as `each tree is _orthogonally
 * adjacent_ to exactly one tent', which is definitely incorrect.
 * Even the most coherent sources I've found don't do a much better
 * job of stating the rule.
 * 
 * A more precise statement of the rule is that it must be possible
 * to find a bijection f between tents and trees such that each
 * tree T is orthogonally adjacent to the tent f(T), but that a
 * tent is permitted to be adjacent to other trees in addition to
 * its own. This slightly non-obvious criterion is what gives this
 * puzzle most of its subtlety.
 * 
 * However, there's a particularly subtle ambiguity left over. Is
 * the bijection between tents and trees required to be _unique_?
 * In other words, is that bijection conceptually something the
 * player should be able to exhibit as part of the solution (even
 * if they aren't actually required to do so)? Or is it sufficient
 * to have a unique _placement_ of the tents which gives rise to at
 * least one suitable bijection?
 * 
 * The puzzle shown to the right of this       .T. 2      *T* 2
 * paragraph illustrates the problem. There    T.T 0  ->  T-T 0
 * are two distinct bijections available.      .T. 2      *T* 2
 * The answer to the above question will
 * determine whether it's a valid puzzle.      202        202
 * 
 * This is an important question, because it affects both the
 * player and the generator. Eventually I found all the instances
 * of this puzzle I could Google up, solved them all by hand, and
 * verified that in all cases the tree/tent matching was uniquely
 * determined given the tree and tent positions. Therefore, the
 * puzzle as implemented in this source file takes the following
 * policy:
 * 
 *  - When checking a user-supplied solution for correctness, only
 *    verify that there exists _at least_ one matching.
 *  - When generating a puzzle, enforce that there must be
 *    _exactly_ one.
 * 
 * Algorithmic implications
 * ------------------------
 * 
 * Another way of phrasing the tree/tent matching criterion is to
 * say that the bipartite adjacency graph between trees and tents
 * has a perfect matching. That is, if you construct a graph which
 * has a vertex per tree and a vertex per tent, and an edge between
 * any tree and tent which are orthogonally adjacent, it is
 * possible to find a set of N edges of that graph (where N is the
 * number of trees and also the number of tents) which between them
 * connect every tree to every tent.
 * 
 * The most efficient known algorithms for finding such a matching
 * given a graph, as far as I'm aware, are the Munkres assignment
 * algorithm (also known as the Hungarian algorithm) and the
 * Ford-Fulkerson algorithm (for finding optimal flows in
 * networks). Each of these takes O(N^3) running time; so we're
 * talking O(N^3) time to verify any candidate solution to this
 * puzzle. That's just about OK if you're doing it once per mouse
 * click (and in fact not even that, since the sensible thing to do
 * is check all the _other_ puzzle criteria and only wade into this
 * quagmire if none are violated); but if the solver had to keep
 * doing N^3 work internally, then it would probably end up with
 * more like N^5 or N^6 running time, and grid generation would
 * become very clunky.
 * 
 * Fortunately, I've been able to prove a very useful property of
 * _unique_ perfect matchings, by adapting the proof of Hall's
 * Marriage Theorem. For those unaware of Hall's Theorem, I'll
 * recap it and its proof: it states that a bipartite graph
 * contains a perfect matching iff every set of vertices on the
 * left side of the graph have a neighbourhood _at least_ as big on
 * the right.
 * 
 * This condition is obviously satisfied if a perfect matching does
 * exist; each left-side node has a distinct right-side node which
 * is the one assigned to it by the matching, and thus any set of n
 * left vertices must have a combined neighbourhood containing at
 * least the n corresponding right vertices, and possibly others
 * too. Alternatively, imagine if you had (say) three left-side
 * nodes all of which were connected to only two right-side nodes
 * between them: any perfect matching would have to assign one of
 * those two right nodes to each of the three left nodes, and still
 * give the three left nodes a different right node each. This is
 * of course impossible.
 *
 * To prove the converse (that if every subset of left vertices
 * satisfies the Hall condition then a perfect matching exists),
 * consider trying to find a proper subset of the left vertices
 * which _exactly_ satisfies the Hall condition: that is, its right
 * neighbourhood is precisely the same size as it. If we can find
 * such a subset, then we can split the bipartite graph into two
 * smaller ones: one consisting of the left subset and its right
 * neighbourhood, the other consisting of everything else. Edges
 * from the left side of the former graph to the right side of the
 * latter do not exist, by construction; edges from the right side
 * of the former to the left of the latter cannot be part of any
 * perfect matching because otherwise the left subset would not be
 * left with enough distinct right vertices to connect to (this is
 * exactly the same deduction used in Solo's set analysis). You can
 * then prove (left as an exercise) that both these smaller graphs
 * still satisfy the Hall condition, and therefore the proof will
 * follow by induction.
 * 
 * There's one other possibility, which is the case where _no_
 * proper subset of the left vertices has a right neighbourhood of
 * exactly the same size. That is, every left subset has a strictly
 * _larger_ right neighbourhood. In this situation, we can simply
 * remove an _arbitrary_ edge from the graph. This cannot reduce
 * the size of any left subset's right neighbourhood by more than
 * one, so if all neighbourhoods were strictly bigger than they
 * needed to be initially, they must now still be _at least as big_
 * as they need to be. So we can keep throwing out arbitrary edges
 * until we find a set which exactly satisfies the Hall condition,
 * and then proceed as above. []
 * 
 * That's Hall's theorem. I now build on this by examining the
 * circumstances in which a bipartite graph can have a _unique_
 * perfect matching. It is clear that in the second case, where no
 * left subset exactly satisfies the Hall condition and so we can
 * remove an arbitrary edge, there cannot be a unique perfect
 * matching: given one perfect matching, we choose our arbitrary
 * removed edge to be one of those contained in it, and then we can
 * still find a perfect matching in the remaining graph, which will
 * be a distinct perfect matching in the original.
 * 
 * So it is a necessary condition for a unique perfect matching
 * that there must be at least one proper left subset which
 * _exactly_ satisfies the Hall condition. But now consider the
 * smaller graph constructed by taking that left subset and its
 * neighbourhood: if the graph as a whole had a unique perfect
 * matching, then so must this smaller one, which means we can find
 * a proper left subset _again_, and so on. Repeating this process
 * must eventually reduce us to a graph with only one left-side
 * vertex (so there are no proper subsets at all); this vertex must
 * be connected to only one right-side vertex, and hence must be so
 * in the original graph as well (by construction). So we can
 * discard this vertex pair from the graph, and any other edges
 * that involved it (which will by construction be from other left
 * vertices only), and the resulting smaller graph still has a
 * unique perfect matching which means we can do the same thing
 * again.
 * 
 * In other words, given any bipartite graph with a unique perfect
 * matching, we can find that matching by the following extremely
 * simple algorithm:
 * 
 *  - Find a left-side vertex which is only connected to one
 *    right-side vertex.
 *  - Assign those vertices to one another, and therefore discard
 *    any other edges connecting to that right vertex.
 *  - Repeat until all vertices have been matched.
 * 
 * This algorithm can be run in O(V+E) time (where V is the number
 * of vertices and E is the number of edges in the graph), and the
 * only way it can fail is if there is not a unique perfect
 * matching (either because there is no matching at all, or because
 * it isn't unique; but it can't distinguish those cases).
 * 
 * Thus, the internal solver in this source file can be confident
 * that if the tree/tent matching is uniquely determined by the
 * tree and tent positions, it can find it using only this kind of
 * obvious and simple operation: assign a tree to a tent if it
 * cannot possibly belong to any other tent, and vice versa. If the
 * solver were _only_ trying to determine the matching, even that
 * `vice versa' wouldn't be required; but it can come in handy when
 * not all the tents have been placed yet. I can therefore be
 * reasonably confident that as long as my solver doesn't need to
 * cope with grids that have a non-unique matching, it will also
 * not need to do anything complicated like set analysis between
 * trees and tents.
 
 * In standalone solver mode, `verbose' is a variable which can be
 * set by command-line option; in debugging mode it's simply always
 * true.
 
 * Difficulty levels. I do some macro ickery here to ensure that my
 * enum and the various forms of my name list always match up.
  structure copy 
     * Generating anything under 4x4 runs into trouble of one kind
     * or another.
     
 * Scratch space for solver.
  link directions  mapping between trees and tents 
 * Solver. Returns 0 for impossibility, 1 for success, 2 for
 * ambiguity or failure to converge.
 
     * Set up solver data.
     
     * Set up solution array.
     
     * Main solver loop.
     
	 * Any tent which has only one unattached tree adjacent to
	 * it can be tied to that tree.
	  found more than one  no solution exists  don't do anything else! 
	 * Mark a blank square as NONTENT if it is not orthogonally
	 * adjacent to any unmatched tree.
	 
	 * Mark a blank square as NONTENT if it is (perhaps
	 * diagonally) adjacent to any other tent.
	 
	 * Any tree which has exactly one {unattached tent, BLANK}
	 * adjacent to it must have its tent in that square.
	  no solution exists 
			 * If there are two possible places where
			 * this tree's tent can go, and they are
			 * diagonally separated rather than being
			 * on opposite sides of the tree, then the
			 * square (other than the tree square)
			 * which is adjacent to both of them must
			 * be a non-tent.
			 
	 * If localised deductions about the trees and tents
	 * themselves haven't helped us, it's time to resort to the
	 * numbers round the grid edge. For each row and column, we
	 * go through all possible combinations of locations for
	 * the unplaced tents, rule out any which have adjacent
	 * tents, and spot any square which is given the same state
	 * by all remaining combinations.
	 
		 * This is the number for a column.
		 
		 * This is the number for a row.
		 
		 * In Easy mode, we don't look at the effect of one
		 * row on the next (i.e. ruling out a square if all
		 * possibilities for an adjacent row place a tent
		 * next to it).
		 
	     * Count and store the locations of the free squares,
	     * and also count the number of tents already placed.
	      one fewer tent to place  nothing left to do here 
	     * Now we know we're placing k tents in n squares. Set
	     * up the first possibility.
	     
	     * We're aiming to find squares in this row which are
	     * invariant over all valid possibilities. Thus, we
	     * maintain the current state of that invariance. We
	     * start everything off at MAGIC to indicate that it
	     * hasn't been set up yet.
	     
	     * And iterate over all possibilities.
	     
		 * See if this possibility is valid. The only way
		 * it can fail to be valid is if it contains two
		 * adjacent tents. (Other forms of invalidity, such
		 * as containing a tent adjacent to one already
		 * placed, will have been dealt with already by
		 * other parts of the solver.)
		 
		     * Merge this valid combination into mrow.
		     
			     * Either this is the first valid
			     * placement we've found at all, or
			     * this square's contents are
			     * consistent with every previous valid
			     * combination.
			     
			     * This square's contents fail to match
			     * what they were in a different
			     * combination, so we cannot deduce
			     * anything about this square.
			     
		 * Find the next combination of k choices from n.
		 * We do this by finding the rightmost tent which
		 * can be moved one place right, doing so, and
		 * shunting all tents to the right of that as far
		 * left as they can go.
		  we've finished 
	     * It's just possible that _no_ placement was valid, in
	     * which case we have an internally inconsistent
	     * puzzle.
	      inconsistent 
	     * Now go through mrow and see if there's anything
	     * we've deduced which wasn't already mentioned in soln.
	     
     * The solver has nothing further it can do. Return 1 if both
     * soln and sc->links are completely filled in, or 2 otherwise.
      structure copy 
     * Since this puzzle has many global deductions and doesn't
     * permit limited clue sets, generating grids for this puzzle
     * is hard enough that I see no better option than to simply
     * generate a solution and see if it's unique and has the
     * required difficulty. This turns out to be computationally
     * plausible as well.
     * 
     * We chose our tree count (hence also tent count) by dividing
     * the total grid area by five above. Why five? Well, w*h/4 is
     * the maximum number of tents you can _possibly_ fit into the
     * grid without violating the separation criterion, and to
     * achieve that you are constrained to a very small set of
     * possible layouts (the obvious one with a tent at every
     * (even,even) coordinate, and trivial variations thereon). So
     * if we reduce the tent count a bit more, we enable more
     * random-looking placement; 5 turns out to be a plausible
     * figure which yields sensible puzzles. Increasing the tent
     * count would give puzzles whose solutions were too regimented
     * and could be solved by the use of that knowledge (and would
     * also take longer to find a viable placement); decreasing it
     * would make the grids emptier and more boring.
     * 
     * Actually generating a grid is a matter of first placing the
     * tents, and then placing the trees by the use of matching.c
     * (finding a distinct square adjacent to every tent). We do it
     * this way round because otherwise satisfying the tent
     * separation condition would become onerous: most randomly
     * chosen tent layouts do not satisfy this condition, so we'd
     * have gone to a lot of work before finding that a candidate
     * layout was unusable. Instead, we place the tents first and
     * ensure they meet the separation criterion _before_ doing
     * lots of computation; this works much better.
     * 
     * This generation strategy can fail at many points, including
     * as early as tent placement (if you get a bad random order in
     * which to greedily try the grid squares, you won't even
     * manage to find enough mutually non-adjacent squares to put
     * the tents in). Then it can fail if matching.c doesn't manage
     * to find a good enough matching (i.e. the tent placements don't
     * admit any adequate tree placements); and finally it can fail
     * if the solver finds that the problem has the wrong
     * difficulty (including being actually non-unique). All of
     * these, however, are insufficiently frequent to cause
     * trouble.
      downgrade to prevent tight loop 
	 * Make a list of grid squares which we'll permute as we pick
	 * the tent locations.
         *
         * We'll also need to index all the potential tree squares,
         * i.e. the ones adjacent to the tents.
	 
	 * Place tents at random without making any two adjacent.
	  Loop end condition: either j==0 (we've placed all the
         * tents), or the number of grid squares we have yet to try
         * is too few to fit the remaining tents into.  couldn't place all the tents 
	 * Build up the graph for matching.c.
	 
	 * Call the matching algorithm to actually place the trees.
	  couldn't place all the trees 
	 * Fill in the trees in the grid, by cross-referencing treemap
	 * (which maps a grid square to its index as known to
	 * matching()) against the output from matching().
         *
         * Note that for these purposes we don't actually care _which_
         * tent each potential tree square is assigned to - we only
         * care whether it was assigned to any tent at all, in order
         * to decide whether to put a tree in it.
	 
	 * I think it looks ugly if there isn't at least one of
	 * _something_ (tent or tree) in each row and each column
	 * of the grid. This doesn't give any information away
	 * since a completely empty row/column is instantly obvious
	 * from the clues (it has no trees and a zero).
	  found something in this column  found empty column  a column was empty  found something in this row  found empty row  a row was empty 
	 * Now set up the numbers round the edge.
	 
	 * And now actually solve the puzzle, to see whether it's
	 * unique and has the required difficulty.
	 
         * We expect solving with difficulty params->diff to have
         * succeeded (otherwise the problem is too hard), and
         * solving with diff-1 to have failed (otherwise it's too
         * easy).
         
     * That's it. Encode as a game ID.
     
     * And encode the solution as an aux_info.
      do nothing  structure copy  structure copy 
	 * If we already have the solution, save ourselves some
	 * time.
	 
         * Construct a move string which turns the current state
         * into the solved state.
          999 tents  NOP  coords of drag start  coords of drag end  -1 for none, or a button code  dragged off the window, to cancel  cursor position.  is cursor displayed?  last-drawn cursor pos, or (-1,-1) if absent. 
     * Left-dragging has no effect, so we treat a left-drag as a
     * single click on dsx,dsy.
      no change outside drag area  trees are inviolate always 
         * Results of a simple click. Left button sets blanks to
         * tents; right button sets blanks to non-tents; either
         * button clears a non-blank square.
         * If stylus-based however, it loops instead.
         
         * Results of a drag. Left-dragging has no effect.
         * Right-dragging sets all blank squares to non-tents and
         * has no effect on anything else.
          do nothing 
             * Drags are limited to one row or column. Hence, we
             * work out which coordinate is closer to the drag
             * start, and move it _to_ the drag start.
             
         * The drag has been released. Enact it.
          drag was just cancelled  drag is terminated  drag was terminated  NONTENTify all unique traversed eligible squares  SELECT cycles T, N, B 
             * Set all non-tree squares to NONTENT. The rest of the
             * solve move will fill the tents in over the top.
             
     * Check for completion.
     
         * We have the right number of tents, which is a
         * precondition for the game being complete. Now check that
         * the numbers add up.
         
         * Also, check that no two tents are adjacent.
         
         * OK; we have the right number of tents, they match the
         * numeric clues, and they satisfy the non-adjacency
         * criterion. Finally, we need to verify that they can be
         * placed in a one-to-one matching with the trees such that
         * every tent is orthogonally adjacent to its tree.
         * 
         * This bit is where the hard work comes in: we have to do
         * it by finding such a matching using matching.c.
          Assign each tent and tree a consecutive vertex id for
         * matching().  Build the vertices' adjacency lists. 
                     * Here we use the direction enum declared for
                     * the solver. We make use of the fact that the
                     * directions are declared in the order
                     * U,L,R,D, meaning that we go through the four
                     * neighbours of any square in numerically
                     * increasing order.
                     
         * We haven't managed to fault the grid on any count. Score!
          ----------------------------------------------------------------------
 * Drawing routines.
  fool the macros  structure copy 
     * This function goes through a grid and works out where to
     * highlight play errors in red. The aim is that it should
     * produce at least one error highlight for any complete grid
     * (or complete piece of grid) violating a puzzle constraint, so
     * that a grid containing no BLANK squares is either a win or is
     * marked up in some way that indicates why not.
     *
     * So it's easy enough to highlight errors in the numeric clues
     * - just light up any row or column number which is not
     * fulfilled - and it's just as easy to highlight adjacent
     * tents. The difficult bit is highlighting failures in the
     * tent/tree matching criterion.
     *
     * A natural approach would seem to be to apply the matching.c
     * algorithm to find the tent/tree matching; if this fails, it
     * could be made to produce as a by-product some set of trees
     * which have too few tents between them (or vice versa). However,
     * it's bad for localising errors, because it's not easy to make
     * the algorithm narrow down to the _smallest_ such set of trees:
     * if trees A and B have only one tent between them, for instance,
     * it might perfectly well highlight not only A and B but also
     * trees C and D which are correctly matched on the far side of
     * the grid, on the grounds that those four trees between them
     * have only three tents.
     *
     * Also, that approach fares badly when you introduce the
     * additional requirement that incomplete grids should have
     * errors highlighted only when they can be proved to be errors
     * - so that trees should not be marked as having too few tents
     * if there are enough BLANK squares remaining around them that
     * could be turned into the missing tents (to do so would be
     * patronising, since the overwhelming likelihood is not that
     * the player has forgotten to put a tree there but that they
     * have merely not put one there _yet_). However, tents with too
     * few trees can be marked immediately, since those are
     * definitely player error.
     *
     * So I adopt an alternative approach, which is to consider the
     * bipartite adjacency graph between trees and tents
     * ('bipartite' in the sense that for these purposes I
     * deliberately ignore two adjacent trees or two adjacent
     * tents), divide that graph up into its connected components
     * using a dsf, and look for components which contain different
     * numbers of trees and tents. This allows me to highlight
     * groups of tents with too few trees between them immediately,
     * and then in order to find groups of trees with too few tents
     * I redo the same process but counting BLANKs as potential
     * tents (so that the only trees highlighted are those
     * surrounded by enough NONTENTs to make it impossible to give
     * them enough tents).
     *
     * However, this technique is incomplete: it is not a sufficient
     * condition for the existence of a perfect matching that every
     * connected component of the graph has the same number of tents
     * and trees. An example of a graph which satisfies the latter
     * condition but still has no perfect matching is
     * 
     *     A    B    C
     *     |   /   ,/|
     *     |  /  ,'/ |
     *     | / ,' /  |
     *     |/,'  /   |
     *     1    2    3
     *
     * which can be realised in Tents as
     * 
     *       B
     *     A 1 C 2
     *         3
     *
     * The matching-error highlighter described above will not mark
     * this construction as erroneous. However, something else will:
     * the three tents in the above diagram (let us suppose A,B,C
     * are the tents, though it doesn't matter which) contain two
     * diagonally adjacent pairs. So there will be _an_ error
     * highlighted for the above layout, even though not all types
     * of error will be highlighted.
     *
     * And in fact we can prove that this will always be the case:
     * that the shortcomings of the matching-error highlighter will
     * always be made up for by the easy tent adjacency highlighter.
     *
     * Lemma: Let G be a bipartite graph between n trees and n
     * tents, which is connected, and in which no tree has degree
     * more than two (but a tent may). Then G has a perfect matching.
     * 
     * (Note: in the statement and proof of the Lemma I will
     * consistently use 'tree' to indicate a type of graph vertex as
     * opposed to a tent, and not to indicate a tree in the graph-
     * theoretic sense.)
     *
     * Proof:
     * 
     * If we can find a tent of degree 1 joined to a tree of degree
     * 2, then any perfect matching must pair that tent with that
     * tree. Hence, we can remove both, leaving a smaller graph G'
     * which still satisfies all the conditions of the Lemma, and
     * which has a perfect matching iff G does.
     *
     * So, wlog, we may assume G contains no tent of degree 1 joined
     * to a tree of degree 2; if it does, we can reduce it as above.
     *
     * If G has no tent of degree 1 at all, then every tent has
     * degree at least two, so there are at least 2n edges in the
     * graph. But every tree has degree at most two, so there are at
     * most 2n edges. Hence there must be exactly 2n edges, so every
     * tree and every tent must have degree exactly two, which means
     * that the whole graph consists of a single loop (by
     * connectedness), and therefore certainly has a perfect
     * matching.
     *
     * Alternatively, if G does have a tent of degree 1 but it is
     * not connected to a tree of degree 2, then the tree it is
     * connected to must have degree 1 - and, by connectedness, that
     * must mean that that tent and that tree between them form the
     * entire graph. This trivial graph has a trivial perfect
     * matching. []
     *
     * That proves the lemma. Hence, in any case where the matching-
     * error highlighter fails to highlight an erroneous component
     * (because it has the same number of tents as trees, but they
     * cannot be matched up), the above lemma tells us that there
     * must be a tree with degree more than 2, i.e. a tree
     * orthogonally adjacent to at least three tents. But in that
     * case, there must be some pair of those three tents which are
     * diagonally adjacent to each other, so the tent-adjacency
     * highlighter will necessarily show an error. So any filled
     * layout in Tents which is not a correct solution to the puzzle
     * must have _some_ error highlighted by the subroutine below.
     *
     * (Of course it would be nicer if we could highlight all
     * errors: in the above example layout, we would like to
     * highlight tents A,B as having too few trees between them, and
     * trees 2,3 as having too few tents, in addition to marking the
     * adjacency problems. But I can't immediately think of any way
     * to find the smallest sets of such tents and trees without an
     * O(2^N) loop over all subsets of a given component.)
     
     * ret[0] through to ret[w*h-1] give error markers for the grid
     * squares. After that, ret[w*h] to ret[w*h+w-1] give error
     * markers for the column numbers, and ret[w*h+w] to
     * ret[w*h+w+h-1] for the row numbers.
     
     * Spot tent-adjacency violations.
     
     * Spot numeric clue violations.
     
     * Identify groups of tents with too few trees between them,
     * which we do by constructing the connected components of the
     * bipartite adjacency graph between tents and trees
     * ('bipartite' in the sense that we deliberately ignore
     * adjacency between tents or between trees), and highlighting
     * all the tents in any component which has a smaller tree
     * count.
      Construct the equivalence classes.  Count up the tent/tree difference in each one.  And highlight any tent belonging to an equivalence class with
     * a score less than zero. 
     * Identify groups of trees with too few tents between them.
     * This is done similarly, except that we now count BLANK as
     * equivalent to TENT, i.e. we only highlight such trees when
     * the user hasn't even left _room_ to provide tents for them
     * all. (Otherwise, we'd highlight all trees red right at the
     * start of the game, before the user had done anything wrong!)
      Construct the equivalence classes.  Count up the tent/tree difference in each one.  And highlight any tree belonging to an equivalence class with
     * a score more than zero. 
     * Draw a diamond.
     
     * Draw an exclamation mark in the diamond. This turns out to
     * look unpleasantly off-centre if done via draw_text, so I do
     * it by hand on the basis that exclamation marks aren't that
     * difficult to draw...
     
 * Internal redraw function, used for printing as well as drawing.
 
         * Draw the grid.
         
     * Find errors. For this we use _part_ of the information from a
     * currently active drag: we transform dsx,dsy but not anything
     * else. (This seems to strike a good compromise between having
     * the error highlights respond instantly to single clicks, but
     * not giving constant feedback during a right-drag.)
     
     * Draw the grid.
     
             * We deliberately do not take drag_ok into account
             * here, because user feedback suggests that it's
             * marginally nicer not to have the drag effects
             * flickering on and off disconcertingly.
             
     * Draw (or redraw, if their error-highlighted state has
     * changed) the numbers.
     
     * I'll use 6mm squares by default.
      Ick: fake up `ds->tilesize' for macro expansion purposes  game_request_keys  wants_statusbar  flags 
     * When solving an Easy puzzle, we don't want to bother the
     * user with Hard-level deductions. For this reason, we grade
     * the puzzle internally before doing anything else.
      placate optimiser  vim: set shiftwidth=4 tabstop=8: 
 * tents.c: Puzzle involving placing tents next to trees subject to
 * some confusing conditions.
 * 
 * TODO:
 *
 *  - it might be nice to make setter-provided tent/nontent clues
 *    inviolable?
 *     * on the other hand, this would introduce considerable extra
 *       complexity and size into the game state; also inviolable
 *       clues would have to be marked as such somehow, in an
 *       intrusive and annoying manner. Since they're never
 *       generated by _my_ generator, I'm currently more inclined
 *       not to bother.
 * 
 *  - more difficult levels at the top end?
 *     * for example, sometimes we can deduce that two BLANKs in
 *       the same row are each adjacent to the same unattached tree
 *       and to nothing else, implying that they can't both be
 *       tents; this enables us to rule out some extra combinations
 *       in the row-based deduction loop, and hence deduce more
 *       from the number in that row than we could otherwise do.
 *     * that by itself doesn't seem worth implementing a new
 *       difficulty level for, but if I can find a few more things
 *       like that then it might become worthwhile.
 *     * I wonder if there's a sensible heuristic for where to
 *       guess which would make a recursive solver viable?
 
 * Design discussion
 * -----------------
 * 
 * The rules of this puzzle as available on the WWW are poorly
 * specified. The bits about tents having to be orthogonally
 * adjacent to trees, tents not being even diagonally adjacent to
 * one another, and the number of tents in each row and column
 * being given are simple enough; the difficult bit is the
 * tent-to-tree matching.
 * 
 * Some sources use simplistic wordings such as `each tree is
 * exactly connected to only one tent', which is extremely unclear:
 * it's easy to read erroneously as `each tree is _orthogonally
 * adjacent_ to exactly one tent', which is definitely incorrect.
 * Even the most coherent sources I've found don't do a much better
 * job of stating the rule.
 * 
 * A more precise statement of the rule is that it must be possible
 * to find a bijection f between tents and trees such that each
 * tree T is orthogonally adjacent to the tent f(T), but that a
 * tent is permitted to be adjacent to other trees in addition to
 * its own. This slightly non-obvious criterion is what gives this
 * puzzle most of its subtlety.
 * 
 * However, there's a particularly subtle ambiguity left over. Is
 * the bijection between tents and trees required to be _unique_?
 * In other words, is that bijection conceptually something the
 * player should be able to exhibit as part of the solution (even
 * if they aren't actually required to do so)? Or is it sufficient
 * to have a unique _placement_ of the tents which gives rise to at
 * least one suitable bijection?
 * 
 * The puzzle shown to the right of this       .T. 2      *T* 2
 * paragraph illustrates the problem. There    T.T 0  ->  T-T 0
 * are two distinct bijections available.      .T. 2      *T* 2
 * The answer to the above question will
 * determine whether it's a valid puzzle.      202        202
 * 
 * This is an important question, because it affects both the
 * player and the generator. Eventually I found all the instances
 * of this puzzle I could Google up, solved them all by hand, and
 * verified that in all cases the tree/tent matching was uniquely
 * determined given the tree and tent positions. Therefore, the
 * puzzle as implemented in this source file takes the following
 * policy:
 * 
 *  - When checking a user-supplied solution for correctness, only
 *    verify that there exists _at least_ one matching.
 *  - When generating a puzzle, enforce that there must be
 *    _exactly_ one.
 * 
 * Algorithmic implications
 * ------------------------
 * 
 * Another way of phrasing the tree/tent matching criterion is to
 * say that the bipartite adjacency graph between trees and tents
 * has a perfect matching. That is, if you construct a graph which
 * has a vertex per tree and a vertex per tent, and an edge between
 * any tree and tent which are orthogonally adjacent, it is
 * possible to find a set of N edges of that graph (where N is the
 * number of trees and also the number of tents) which between them
 * connect every tree to every tent.
 * 
 * The most efficient known algorithms for finding such a matching
 * given a graph, as far as I'm aware, are the Munkres assignment
 * algorithm (also known as the Hungarian algorithm) and the
 * Ford-Fulkerson algorithm (for finding optimal flows in
 * networks). Each of these takes O(N^3) running time; so we're
 * talking O(N^3) time to verify any candidate solution to this
 * puzzle. That's just about OK if you're doing it once per mouse
 * click (and in fact not even that, since the sensible thing to do
 * is check all the _other_ puzzle criteria and only wade into this
 * quagmire if none are violated); but if the solver had to keep
 * doing N^3 work internally, then it would probably end up with
 * more like N^5 or N^6 running time, and grid generation would
 * become very clunky.
 * 
 * Fortunately, I've been able to prove a very useful property of
 * _unique_ perfect matchings, by adapting the proof of Hall's
 * Marriage Theorem. For those unaware of Hall's Theorem, I'll
 * recap it and its proof: it states that a bipartite graph
 * contains a perfect matching iff every set of vertices on the
 * left side of the graph have a neighbourhood _at least_ as big on
 * the right.
 * 
 * This condition is obviously satisfied if a perfect matching does
 * exist; each left-side node has a distinct right-side node which
 * is the one assigned to it by the matching, and thus any set of n
 * left vertices must have a combined neighbourhood containing at
 * least the n corresponding right vertices, and possibly others
 * too. Alternatively, imagine if you had (say) three left-side
 * nodes all of which were connected to only two right-side nodes
 * between them: any perfect matching would have to assign one of
 * those two right nodes to each of the three left nodes, and still
 * give the three left nodes a different right node each. This is
 * of course impossible.
 *
 * To prove the converse (that if every subset of left vertices
 * satisfies the Hall condition then a perfect matching exists),
 * consider trying to find a proper subset of the left vertices
 * which _exactly_ satisfies the Hall condition: that is, its right
 * neighbourhood is precisely the same size as it. If we can find
 * such a subset, then we can split the bipartite graph into two
 * smaller ones: one consisting of the left subset and its right
 * neighbourhood, the other consisting of everything else. Edges
 * from the left side of the former graph to the right side of the
 * latter do not exist, by construction; edges from the right side
 * of the former to the left of the latter cannot be part of any
 * perfect matching because otherwise the left subset would not be
 * left with enough distinct right vertices to connect to (this is
 * exactly the same deduction used in Solo's set analysis). You can
 * then prove (left as an exercise) that both these smaller graphs
 * still satisfy the Hall condition, and therefore the proof will
 * follow by induction.
 * 
 * There's one other possibility, which is the case where _no_
 * proper subset of the left vertices has a right neighbourhood of
 * exactly the same size. That is, every left subset has a strictly
 * _larger_ right neighbourhood. In this situation, we can simply
 * remove an _arbitrary_ edge from the graph. This cannot reduce
 * the size of any left subset's right neighbourhood by more than
 * one, so if all neighbourhoods were strictly bigger than they
 * needed to be initially, they must now still be _at least as big_
 * as they need to be. So we can keep throwing out arbitrary edges
 * until we find a set which exactly satisfies the Hall condition,
 * and then proceed as above. []
 * 
 * That's Hall's theorem. I now build on this by examining the
 * circumstances in which a bipartite graph can have a _unique_
 * perfect matching. It is clear that in the second case, where no
 * left subset exactly satisfies the Hall condition and so we can
 * remove an arbitrary edge, there cannot be a unique perfect
 * matching: given one perfect matching, we choose our arbitrary
 * removed edge to be one of those contained in it, and then we can
 * still find a perfect matching in the remaining graph, which will
 * be a distinct perfect matching in the original.
 * 
 * So it is a necessary condition for a unique perfect matching
 * that there must be at least one proper left subset which
 * _exactly_ satisfies the Hall condition. But now consider the
 * smaller graph constructed by taking that left subset and its
 * neighbourhood: if the graph as a whole had a unique perfect
 * matching, then so must this smaller one, which means we can find
 * a proper left subset _again_, and so on. Repeating this process
 * must eventually reduce us to a graph with only one left-side
 * vertex (so there are no proper subsets at all); this vertex must
 * be connected to only one right-side vertex, and hence must be so
 * in the original graph as well (by construction). So we can
 * discard this vertex pair from the graph, and any other edges
 * that involved it (which will by construction be from other left
 * vertices only), and the resulting smaller graph still has a
 * unique perfect matching which means we can do the same thing
 * again.
 * 
 * In other words, given any bipartite graph with a unique perfect
 * matching, we can find that matching by the following extremely
 * simple algorithm:
 * 
 *  - Find a left-side vertex which is only connected to one
 *    right-side vertex.
 *  - Assign those vertices to one another, and therefore discard
 *    any other edges connecting to that right vertex.
 *  - Repeat until all vertices have been matched.
 * 
 * This algorithm can be run in O(V+E) time (where V is the number
 * of vertices and E is the number of edges in the graph), and the
 * only way it can fail is if there is not a unique perfect
 * matching (either because there is no matching at all, or because
 * it isn't unique; but it can't distinguish those cases).
 * 
 * Thus, the internal solver in this source file can be confident
 * that if the tree/tent matching is uniquely determined by the
 * tree and tent positions, it can find it using only this kind of
 * obvious and simple operation: assign a tree to a tent if it
 * cannot possibly belong to any other tent, and vice versa. If the
 * solver were _only_ trying to determine the matching, even that
 * `vice versa' wouldn't be required; but it can come in handy when
 * not all the tents have been placed yet. I can therefore be
 * reasonably confident that as long as my solver doesn't need to
 * cope with grids that have a non-unique matching, it will also
 * not need to do anything complicated like set analysis between
 * trees and tents.
 
 * In standalone solver mode, `verbose' is a variable which can be
 * set by command-line option; in debugging mode it's simply always
 * true.
 
 * Difficulty levels. I do some macro ickery here to ensure that my
 * enum and the various forms of my name list always match up.
  structure copy 
     * Generating anything under 4x4 runs into trouble of one kind
     * or another.
     
 * Scratch space for solver.
  link directions  mapping between trees and tents 
 * Solver. Returns 0 for impossibility, 1 for success, 2 for
 * ambiguity or failure to converge.
 
     * Set up solver data.
     
     * Set up solution array.
     
     * Main solver loop.
     
	 * Any tent which has only one unattached tree adjacent to
	 * it can be tied to that tree.
	  found more than one  no solution exists  don't do anything else! 
	 * Mark a blank square as NONTENT if it is not orthogonally
	 * adjacent to any unmatched tree.
	 
	 * Mark a blank square as NONTENT if it is (perhaps
	 * diagonally) adjacent to any other tent.
	 
	 * Any tree which has exactly one {unattached tent, BLANK}
	 * adjacent to it must have its tent in that square.
	  no solution exists 
			 * If there are two possible places where
			 * this tree's tent can go, and they are
			 * diagonally separated rather than being
			 * on opposite sides of the tree, then the
			 * square (other than the tree square)
			 * which is adjacent to both of them must
			 * be a non-tent.
			 
	 * If localised deductions about the trees and tents
	 * themselves haven't helped us, it's time to resort to the
	 * numbers round the grid edge. For each row and column, we
	 * go through all possible combinations of locations for
	 * the unplaced tents, rule out any which have adjacent
	 * tents, and spot any square which is given the same state
	 * by all remaining combinations.
	 
		 * This is the number for a column.
		 
		 * This is the number for a row.
		 
		 * In Easy mode, we don't look at the effect of one
		 * row on the next (i.e. ruling out a square if all
		 * possibilities for an adjacent row place a tent
		 * next to it).
		 
	     * Count and store the locations of the free squares,
	     * and also count the number of tents already placed.
	      one fewer tent to place  nothing left to do here 
	     * Now we know we're placing k tents in n squares. Set
	     * up the first possibility.
	     
	     * We're aiming to find squares in this row which are
	     * invariant over all valid possibilities. Thus, we
	     * maintain the current state of that invariance. We
	     * start everything off at MAGIC to indicate that it
	     * hasn't been set up yet.
	     
	     * And iterate over all possibilities.
	     
		 * See if this possibility is valid. The only way
		 * it can fail to be valid is if it contains two
		 * adjacent tents. (Other forms of invalidity, such
		 * as containing a tent adjacent to one already
		 * placed, will have been dealt with already by
		 * other parts of the solver.)
		 
		     * Merge this valid combination into mrow.
		     
			     * Either this is the first valid
			     * placement we've found at all, or
			     * this square's contents are
			     * consistent with every previous valid
			     * combination.
			     
			     * This square's contents fail to match
			     * what they were in a different
			     * combination, so we cannot deduce
			     * anything about this square.
			     
		 * Find the next combination of k choices from n.
		 * We do this by finding the rightmost tent which
		 * can be moved one place right, doing so, and
		 * shunting all tents to the right of that as far
		 * left as they can go.
		  we've finished 
	     * It's just possible that _no_ placement was valid, in
	     * which case we have an internally inconsistent
	     * puzzle.
	      inconsistent 
	     * Now go through mrow and see if there's anything
	     * we've deduced which wasn't already mentioned in soln.
	     
     * The solver has nothing further it can do. Return 1 if both
     * soln and sc->links are completely filled in, or 2 otherwise.
      structure copy 
     * Since this puzzle has many global deductions and doesn't
     * permit limited clue sets, generating grids for this puzzle
     * is hard enough that I see no better option than to simply
     * generate a solution and see if it's unique and has the
     * required difficulty. This turns out to be computationally
     * plausible as well.
     * 
     * We chose our tree count (hence also tent count) by dividing
     * the total grid area by five above. Why five? Well, w*h/4 is
     * the maximum number of tents you can _possibly_ fit into the
     * grid without violating the separation criterion, and to
     * achieve that you are constrained to a very small set of
     * possible layouts (the obvious one with a tent at every
     * (even,even) coordinate, and trivial variations thereon). So
     * if we reduce the tent count a bit more, we enable more
     * random-looking placement; 5 turns out to be a plausible
     * figure which yields sensible puzzles. Increasing the tent
     * count would give puzzles whose solutions were too regimented
     * and could be solved by the use of that knowledge (and would
     * also take longer to find a viable placement); decreasing it
     * would make the grids emptier and more boring.
     * 
     * Actually generating a grid is a matter of first placing the
     * tents, and then placing the trees by the use of matching.c
     * (finding a distinct square adjacent to every tent). We do it
     * this way round because otherwise satisfying the tent
     * separation condition would become onerous: most randomly
     * chosen tent layouts do not satisfy this condition, so we'd
     * have gone to a lot of work before finding that a candidate
     * layout was unusable. Instead, we place the tents first and
     * ensure they meet the separation criterion _before_ doing
     * lots of computation; this works much better.
     * 
     * This generation strategy can fail at many points, including
     * as early as tent placement (if you get a bad random order in
     * which to greedily try the grid squares, you won't even
     * manage to find enough mutually non-adjacent squares to put
     * the tents in). Then it can fail if matching.c doesn't manage
     * to find a good enough matching (i.e. the tent placements don't
     * admit any adequate tree placements); and finally it can fail
     * if the solver finds that the problem has the wrong
     * difficulty (including being actually non-unique). All of
     * these, however, are insufficiently frequent to cause
     * trouble.
      downgrade to prevent tight loop 
	 * Make a list of grid squares which we'll permute as we pick
	 * the tent locations.
         *
         * We'll also need to index all the potential tree squares,
         * i.e. the ones adjacent to the tents.
	 
	 * Place tents at random without making any two adjacent.
	  Loop end condition: either j==0 (we've placed all the
         * tents), or the number of grid squares we have yet to try
         * is too few to fit the remaining tents into.  couldn't place all the tents 
	 * Build up the graph for matching.c.
	 
	 * Call the matching algorithm to actually place the trees.
	  couldn't place all the trees 
	 * Fill in the trees in the grid, by cross-referencing treemap
	 * (which maps a grid square to its index as known to
	 * matching()) against the output from matching().
         *
         * Note that for these purposes we don't actually care _which_
         * tent each potential tree square is assigned to - we only
         * care whether it was assigned to any tent at all, in order
         * to decide whether to put a tree in it.
	 
	 * I think it looks ugly if there isn't at least one of
	 * _something_ (tent or tree) in each row and each column
	 * of the grid. This doesn't give any information away
	 * since a completely empty row/column is instantly obvious
	 * from the clues (it has no trees and a zero).
	  found something in this column  found empty column  a column was empty  found something in this row  found empty row  a row was empty 
	 * Now set up the numbers round the edge.
	 
	 * And now actually solve the puzzle, to see whether it's
	 * unique and has the required difficulty.
	 
         * We expect solving with difficulty params->diff to have
         * succeeded (otherwise the problem is too hard), and
         * solving with diff-1 to have failed (otherwise it's too
         * easy).
         
     * That's it. Encode as a game ID.
     
     * And encode the solution as an aux_info.
      do nothing  structure copy  structure copy 
	 * If we already have the solution, save ourselves some
	 * time.
	 
         * Construct a move string which turns the current state
         * into the solved state.
          999 tents  NOP  coords of drag start  coords of drag end  -1 for none, or a button code  dragged off the window, to cancel  cursor position.  is cursor displayed?  last-drawn cursor pos, or (-1,-1) if absent. 
     * Left-dragging has no effect, so we treat a left-drag as a
     * single click on dsx,dsy.
      no change outside drag area  trees are inviolate always 
         * Results of a simple click. Left button sets blanks to
         * tents; right button sets blanks to non-tents; either
         * button clears a non-blank square.
         * If stylus-based however, it loops instead.
         
         * Results of a drag. Left-dragging has no effect.
         * Right-dragging sets all blank squares to non-tents and
         * has no effect on anything else.
          do nothing 
             * Drags are limited to one row or column. Hence, we
             * work out which coordinate is closer to the drag
             * start, and move it _to_ the drag start.
             
         * The drag has been released. Enact it.
          drag was just cancelled  drag is terminated  drag was terminated  NONTENTify all unique traversed eligible squares  SELECT cycles T, N, B 
             * Set all non-tree squares to NONTENT. The rest of the
             * solve move will fill the tents in over the top.
             
     * Check for completion.
     
         * We have the right number of tents, which is a
         * precondition for the game being complete. Now check that
         * the numbers add up.
         
         * Also, check that no two tents are adjacent.
         
         * OK; we have the right number of tents, they match the
         * numeric clues, and they satisfy the non-adjacency
         * criterion. Finally, we need to verify that they can be
         * placed in a one-to-one matching with the trees such that
         * every tent is orthogonally adjacent to its tree.
         * 
         * This bit is where the hard work comes in: we have to do
         * it by finding such a matching using matching.c.
          Assign each tent and tree a consecutive vertex id for
         * matching().  Build the vertices' adjacency lists. 
                     * Here we use the direction enum declared for
                     * the solver. We make use of the fact that the
                     * directions are declared in the order
                     * U,L,R,D, meaning that we go through the four
                     * neighbours of any square in numerically
                     * increasing order.
                     
         * We haven't managed to fault the grid on any count. Score!
          ----------------------------------------------------------------------
 * Drawing routines.
  fool the macros  structure copy 
     * This function goes through a grid and works out where to
     * highlight play errors in red. The aim is that it should
     * produce at least one error highlight for any complete grid
     * (or complete piece of grid) violating a puzzle constraint, so
     * that a grid containing no BLANK squares is either a win or is
     * marked up in some way that indicates why not.
     *
     * So it's easy enough to highlight errors in the numeric clues
     * - just light up any row or column number which is not
     * fulfilled - and it's just as easy to highlight adjacent
     * tents. The difficult bit is highlighting failures in the
     * tent/tree matching criterion.
     *
     * A natural approach would seem to be to apply the matching.c
     * algorithm to find the tent/tree matching; if this fails, it
     * could be made to produce as a by-product some set of trees
     * which have too few tents between them (or vice versa). However,
     * it's bad for localising errors, because it's not easy to make
     * the algorithm narrow down to the _smallest_ such set of trees:
     * if trees A and B have only one tent between them, for instance,
     * it might perfectly well highlight not only A and B but also
     * trees C and D which are correctly matched on the far side of
     * the grid, on the grounds that those four trees between them
     * have only three tents.
     *
     * Also, that approach fares badly when you introduce the
     * additional requirement that incomplete grids should have
     * errors highlighted only when they can be proved to be errors
     * - so that trees should not be marked as having too few tents
     * if there are enough BLANK squares remaining around them that
     * could be turned into the missing tents (to do so would be
     * patronising, since the overwhelming likelihood is not that
     * the player has forgotten to put a tree there but that they
     * have merely not put one there _yet_). However, tents with too
     * few trees can be marked immediately, since those are
     * definitely player error.
     *
     * So I adopt an alternative approach, which is to consider the
     * bipartite adjacency graph between trees and tents
     * ('bipartite' in the sense that for these purposes I
     * deliberately ignore two adjacent trees or two adjacent
     * tents), divide that graph up into its connected components
     * using a dsf, and look for components which contain different
     * numbers of trees and tents. This allows me to highlight
     * groups of tents with too few trees between them immediately,
     * and then in order to find groups of trees with too few tents
     * I redo the same process but counting BLANKs as potential
     * tents (so that the only trees highlighted are those
     * surrounded by enough NONTENTs to make it impossible to give
     * them enough tents).
     *
     * However, this technique is incomplete: it is not a sufficient
     * condition for the existence of a perfect matching that every
     * connected component of the graph has the same number of tents
     * and trees. An example of a graph which satisfies the latter
     * condition but still has no perfect matching is
     * 
     *     A    B    C
     *     |   /   ,/|
     *     |  /  ,'/ |
     *     | / ,' /  |
     *     |/,'  /   |
     *     1    2    3
     *
     * which can be realised in Tents as
     * 
     *       B
     *     A 1 C 2
     *         3
     *
     * The matching-error highlighter described above will not mark
     * this construction as erroneous. However, something else will:
     * the three tents in the above diagram (let us suppose A,B,C
     * are the tents, though it doesn't matter which) contain two
     * diagonally adjacent pairs. So there will be _an_ error
     * highlighted for the above layout, even though not all types
     * of error will be highlighted.
     *
     * And in fact we can prove that this will always be the case:
     * that the shortcomings of the matching-error highlighter will
     * always be made up for by the easy tent adjacency highlighter.
     *
     * Lemma: Let G be a bipartite graph between n trees and n
     * tents, which is connected, and in which no tree has degree
     * more than two (but a tent may). Then G has a perfect matching.
     * 
     * (Note: in the statement and proof of the Lemma I will
     * consistently use 'tree' to indicate a type of graph vertex as
     * opposed to a tent, and not to indicate a tree in the graph-
     * theoretic sense.)
     *
     * Proof:
     * 
     * If we can find a tent of degree 1 joined to a tree of degree
     * 2, then any perfect matching must pair that tent with that
     * tree. Hence, we can remove both, leaving a smaller graph G'
     * which still satisfies all the conditions of the Lemma, and
     * which has a perfect matching iff G does.
     *
     * So, wlog, we may assume G contains no tent of degree 1 joined
     * to a tree of degree 2; if it does, we can reduce it as above.
     *
     * If G has no tent of degree 1 at all, then every tent has
     * degree at least two, so there are at least 2n edges in the
     * graph. But every tree has degree at most two, so there are at
     * most 2n edges. Hence there must be exactly 2n edges, so every
     * tree and every tent must have degree exactly two, which means
     * that the whole graph consists of a single loop (by
     * connectedness), and therefore certainly has a perfect
     * matching.
     *
     * Alternatively, if G does have a tent of degree 1 but it is
     * not connected to a tree of degree 2, then the tree it is
     * connected to must have degree 1 - and, by connectedness, that
     * must mean that that tent and that tree between them form the
     * entire graph. This trivial graph has a trivial perfect
     * matching. []
     *
     * That proves the lemma. Hence, in any case where the matching-
     * error highlighter fails to highlight an erroneous component
     * (because it has the same number of tents as trees, but they
     * cannot be matched up), the above lemma tells us that there
     * must be a tree with degree more than 2, i.e. a tree
     * orthogonally adjacent to at least three tents. But in that
     * case, there must be some pair of those three tents which are
     * diagonally adjacent to each other, so the tent-adjacency
     * highlighter will necessarily show an error. So any filled
     * layout in Tents which is not a correct solution to the puzzle
     * must have _some_ error highlighted by the subroutine below.
     *
     * (Of course it would be nicer if we could highlight all
     * errors: in the above example layout, we would like to
     * highlight tents A,B as having too few trees between them, and
     * trees 2,3 as having too few tents, in addition to marking the
     * adjacency problems. But I can't immediately think of any way
     * to find the smallest sets of such tents and trees without an
     * O(2^N) loop over all subsets of a given component.)
     
     * ret[0] through to ret[w*h-1] give error markers for the grid
     * squares. After that, ret[w*h] to ret[w*h+w-1] give error
     * markers for the column numbers, and ret[w*h+w] to
     * ret[w*h+w+h-1] for the row numbers.
     
     * Spot tent-adjacency violations.
     
     * Spot numeric clue violations.
     
     * Identify groups of tents with too few trees between them,
     * which we do by constructing the connected components of the
     * bipartite adjacency graph between tents and trees
     * ('bipartite' in the sense that we deliberately ignore
     * adjacency between tents or between trees), and highlighting
     * all the tents in any component which has a smaller tree
     * count.
      Construct the equivalence classes.  Count up the tent/tree difference in each one.  And highlight any tent belonging to an equivalence class with
     * a score less than zero. 
     * Identify groups of trees with too few tents between them.
     * This is done similarly, except that we now count BLANK as
     * equivalent to TENT, i.e. we only highlight such trees when
     * the user hasn't even left _room_ to provide tents for them
     * all. (Otherwise, we'd highlight all trees red right at the
     * start of the game, before the user had done anything wrong!)
      Construct the equivalence classes.  Count up the tent/tree difference in each one.  And highlight any tree belonging to an equivalence class with
     * a score more than zero. 
     * Draw a diamond.
     
     * Draw an exclamation mark in the diamond. This turns out to
     * look unpleasantly off-centre if done via draw_text, so I do
     * it by hand on the basis that exclamation marks aren't that
     * difficult to draw...
     
 * Internal redraw function, used for printing as well as drawing.
 
         * Draw the grid.
         
     * Find errors. For this we use _part_ of the information from a
     * currently active drag: we transform dsx,dsy but not anything
     * else. (This seems to strike a good compromise between having
     * the error highlights respond instantly to single clicks, but
     * not giving constant feedback during a right-drag.)
     
     * Draw the grid.
     
             * We deliberately do not take drag_ok into account
             * here, because user feedback suggests that it's
             * marginally nicer not to have the drag effects
             * flickering on and off disconcertingly.
             
     * Draw (or redraw, if their error-highlighted state has
     * changed) the numbers.
     
     * I'll use 6mm squares by default.
      Ick: fake up `ds->tilesize' for macro expansion purposes  game_request_keys  wants_statusbar  flags 
     * When solving an Easy puzzle, we don't want to bother the
     * user with Hard-level deductions. For this reason, we grade
     * the puzzle internally before doing anything else.
      placate optimiser  vim: set shiftwidth=4 tabstop=8: 