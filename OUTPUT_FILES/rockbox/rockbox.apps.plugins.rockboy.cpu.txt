 Make sure we don't miss lcdc status events!  If timer interrupt cannot happen, this is very simple!  Figure out when the next timer interrupt will happen     if (debug_trace) debug_disassemble(PC, 1);  NOP  LD B,B  LD C,C  LD D,D  LD E,E  LD H,H  LD L,L  LD A,A  LD B,C  LD B,D  LD B,E  LD B,H  LD B,L  LD B,(HL)  LD B,A  LD C,B  LD C,D  LD C,E  LD C,H  LD C,L  LD C,(HL)  LD C,A  LD D,B  LD D,C  LD D,E  LD D,H  LD D,L  LD D,(HL)  LD D,A  LD E,B  LD E,C  LD E,D  LD E,H  LD E,L  LD E,(HL)  LD E,A  LD H,B  LD H,C  LD H,D  LD H,E  LD H,L  LD H,(HL)  LD H,A  LD L,B  LD L,C  LD L,D  LD L,E  LD L,H  LD L,(HL)  LD L,A  LD (HL),B  LD (HL),C  LD (HL),D  LD (HL),E  LD (HL),H  LD (HL),L  LD (HL),A  LD A,B  LD A,C  LD A,D  LD A,E  LD A,H  LD A,L  LD A,(HL)  LD BC,imm  LD DE,imm  LD HL,imm  LD SP,imm  LD (BC),A  LD A,(BC)  LD (DE),A  LD A,(DE)  LDI (HL),A  LDI A,(HL)  LDD (HL),A  LDD A,(HL)  LD B,imm  LD C,imm  LD D,imm  LD E,imm  LD H,imm  LD L,imm  LD (HL),imm  LD A,imm  LD (imm),SP  LD (imm),A  LDH (imm),A  LDH (C),A  LDH A,(imm)  LDH A,(C) (undocumented)  LD HL,SP+imm  LD SP,HL  LD A,(imm)  ADD HL,BC  ADD HL,DE  ADD HL,SP  ADD HL,HL  INC B  INC C  INC D  INC E  INC H  INC L  INC (HL)  INC A  INC BC  INC DE  INC HL  INC SP  DEC B  DEC C  DEC D  DEC E  DEC H  DEC L  DEC (HL)  DEC A  DEC BC  DEC DE  DEC HL  DEC SP  RLCA  RRCA  RLA  RRA  DAA  CPL  JR  JR NZ  JR Z  JR NC  JR C  JP  JP NZ  JP Z  JP NC  JP C  JP HL  RET  RET NZ  RET Z  RET NC  RET C  RETI  CALL  CALL NZ  CALL Z  CALL NC  CALL C  RST 0  RST 8  RST 10  RST 18  RST 20  RST 28  RST 30  RST 38  POP BC  PUSH BC  POP DE  PUSH DE  POP HL  PUSH HL  POP AF  PUSH AF  ADD SP,imm  DI  EI  SCF  CCF  STOP  NOTE - we do not implement dmg STOP whatsoever  HALT  CB prefix  exclude BIT  ROM, dynarec.  call block  Hash miss -> not found -> recompile block and add it  ASM_CPU_EMULATE  Make sure we don't miss lcdc status events!  If timer interrupt cannot happen, this is very simple!  Figure out when the next timer interrupt will happen     if (debug_trace) debug_disassemble(PC, 1);  NOP  LD B,B  LD C,C  LD D,D  LD E,E  LD H,H  LD L,L  LD A,A  LD B,C  LD B,D  LD B,E  LD B,H  LD B,L  LD B,(HL)  LD B,A  LD C,B  LD C,D  LD C,E  LD C,H  LD C,L  LD C,(HL)  LD C,A  LD D,B  LD D,C  LD D,E  LD D,H  LD D,L  LD D,(HL)  LD D,A  LD E,B  LD E,C  LD E,D  LD E,H  LD E,L  LD E,(HL)  LD E,A  LD H,B  LD H,C  LD H,D  LD H,E  LD H,L  LD H,(HL)  LD H,A  LD L,B  LD L,C  LD L,D  LD L,E  LD L,H  LD L,(HL)  LD L,A  LD (HL),B  LD (HL),C  LD (HL),D  LD (HL),E  LD (HL),H  LD (HL),L  LD (HL),A  LD A,B  LD A,C  LD A,D  LD A,E  LD A,H  LD A,L  LD A,(HL)  LD BC,imm  LD DE,imm  LD HL,imm  LD SP,imm  LD (BC),A  LD A,(BC)  LD (DE),A  LD A,(DE)  LDI (HL),A  LDI A,(HL)  LDD (HL),A  LDD A,(HL)  LD B,imm  LD C,imm  LD D,imm  LD E,imm  LD H,imm  LD L,imm  LD (HL),imm  LD A,imm  LD (imm),SP  LD (imm),A  LDH (imm),A  LDH (C),A  LDH A,(imm)  LDH A,(C) (undocumented)  LD HL,SP+imm  LD SP,HL  LD A,(imm)  ADD HL,BC  ADD HL,DE  ADD HL,SP  ADD HL,HL  INC B  INC C  INC D  INC E  INC H  INC L  INC (HL)  INC A  INC BC  INC DE  INC HL  INC SP  DEC B  DEC C  DEC D  DEC E  DEC H  DEC L  DEC (HL)  DEC A  DEC BC  DEC DE  DEC HL  DEC SP  RLCA  RRCA  RLA  RRA  DAA  CPL  JR  JR NZ  JR Z  JR NC  JR C  JP  JP NZ  JP Z  JP NC  JP C  JP HL  RET  RET NZ  RET Z  RET NC  RET C  RETI  CALL  CALL NZ  CALL Z  CALL NC  CALL C  RST 0  RST 8  RST 10  RST 18  RST 20  RST 28  RST 30  RST 38  POP BC  PUSH BC  POP DE  PUSH DE  POP HL  PUSH HL  POP AF  PUSH AF  ADD SP,imm  DI  EI  SCF  CCF  STOP  NOTE - we do not implement dmg STOP whatsoever  HALT  CB prefix  exclude BIT  ROM, dynarec.  call block  Hash miss -> not found -> recompile block and add it  ASM_CPU_EMULATE  Make sure we don't miss lcdc status events!  If timer interrupt cannot happen, this is very simple!  Figure out when the next timer interrupt will happen     if (debug_trace) debug_disassemble(PC, 1);  NOP  LD B,B  LD C,C  LD D,D  LD E,E  LD H,H  LD L,L  LD A,A  LD B,C  LD B,D  LD B,E  LD B,H  LD B,L  LD B,(HL)  LD B,A  LD C,B  LD C,D  LD C,E  LD C,H  LD C,L  LD C,(HL)  LD C,A  LD D,B  LD D,C  LD D,E  LD D,H  LD D,L  LD D,(HL)  LD D,A  LD E,B  LD E,C  LD E,D  LD E,H  LD E,L  LD E,(HL)  LD E,A  LD H,B  LD H,C  LD H,D  LD H,E  LD H,L  LD H,(HL)  LD H,A  LD L,B  LD L,C  LD L,D  LD L,E  LD L,H  LD L,(HL)  LD L,A  LD (HL),B  LD (HL),C  LD (HL),D  LD (HL),E  LD (HL),H  LD (HL),L  LD (HL),A  LD A,B  LD A,C  LD A,D  LD A,E  LD A,H  LD A,L  LD A,(HL)  LD BC,imm  LD DE,imm  LD HL,imm  LD SP,imm  LD (BC),A  LD A,(BC)  LD (DE),A  LD A,(DE)  LDI (HL),A  LDI A,(HL)  LDD (HL),A  LDD A,(HL)  LD B,imm  LD C,imm  LD D,imm  LD E,imm  LD H,imm  LD L,imm  LD (HL),imm  LD A,imm  LD (imm),SP  LD (imm),A  LDH (imm),A  LDH (C),A  LDH A,(imm)  LDH A,(C) (undocumented)  LD HL,SP+imm  LD SP,HL  LD A,(imm)  ADD HL,BC  ADD HL,DE  ADD HL,SP  ADD HL,HL  INC B  INC C  INC D  INC E  INC H  INC L  INC (HL)  INC A  INC BC  INC DE  INC HL  INC SP  DEC B  DEC C  DEC D  DEC E  DEC H  DEC L  DEC (HL)  DEC A  DEC BC  DEC DE  DEC HL  DEC SP  RLCA  RRCA  RLA  RRA  DAA  CPL  JR  JR NZ  JR Z  JR NC  JR C  JP  JP NZ  JP Z  JP NC  JP C  JP HL  RET  RET NZ  RET Z  RET NC  RET C  RETI  CALL  CALL NZ  CALL Z  CALL NC  CALL C  RST 0  RST 8  RST 10  RST 18  RST 20  RST 28  RST 30  RST 38  POP BC  PUSH BC  POP DE  PUSH DE  POP HL  PUSH HL  POP AF  PUSH AF  ADD SP,imm  DI  EI  SCF  CCF  STOP  NOTE - we do not implement dmg STOP whatsoever  HALT  CB prefix  exclude BIT  ROM, dynarec.  call block  Hash miss -> not found -> recompile block and add it  ASM_CPU_EMULATE 