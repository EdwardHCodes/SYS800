 builtin charmaps  only 0-7 are valid as dest charset  additional charsets with algorithmic conversion  some programs like php need this  these must match the constants above  separate identifiers for sbcs/dbcs/etc map type  FIXME: these are not implemented yet
// EUC:   A1-FE A1-FE
// GBK:   81-FE 40-7E,80-FE
// Big5:  A1-FE 40-7E,A1-FE
 1100000x (10xxxxxx)  11100000 100xxxxx (10xxxxxx)  11110000 1000xxxx (10xxxxxx 10xxxxxx)  trivial char  find utf8 sequence length  starved?  decode ...  reject invalid sequences  decode ...  illegal continuation byte  unmapped sequence (> 4)  a number of trivial iso-8859-15 <> utf-8 transliterations  Euro  S caron  s caron  Z caron  z caron  OE  oe  Y diaeresis  cannot translate  FIXME c = get_32(*in, from); only support ascii supersets  FIXME... fall thru and count replacement in latin1 case  fall through  builtin charmaps  only 0-7 are valid as dest charset  additional charsets with algorithmic conversion  some programs like php need this  these must match the constants above  separate identifiers for sbcs/dbcs/etc map type  FIXME: these are not implemented yet
// EUC:   A1-FE A1-FE
// GBK:   81-FE 40-7E,80-FE
// Big5:  A1-FE 40-7E,A1-FE
 1100000x (10xxxxxx)  11100000 100xxxxx (10xxxxxx)  11110000 1000xxxx (10xxxxxx 10xxxxxx)  trivial char  find utf8 sequence length  starved?  decode ...  reject invalid sequences  decode ...  illegal continuation byte  unmapped sequence (> 4)  a number of trivial iso-8859-15 <> utf-8 transliterations  Euro  S caron  s caron  Z caron  z caron  OE  oe  Y diaeresis  cannot translate  FIXME c = get_32(*in, from); only support ascii supersets  FIXME... fall thru and count replacement in latin1 case  fall through  builtin charmaps  only 0-7 are valid as dest charset  additional charsets with algorithmic conversion  some programs like php need this  these must match the constants above  separate identifiers for sbcs/dbcs/etc map type  FIXME: these are not implemented yet
// EUC:   A1-FE A1-FE
// GBK:   81-FE 40-7E,80-FE
// Big5:  A1-FE 40-7E,A1-FE
 1100000x (10xxxxxx)  11100000 100xxxxx (10xxxxxx)  11110000 1000xxxx (10xxxxxx 10xxxxxx)  trivial char  find utf8 sequence length  starved?  decode ...  reject invalid sequences  decode ...  illegal continuation byte  unmapped sequence (> 4)  a number of trivial iso-8859-15 <> utf-8 transliterations  Euro  S caron  s caron  Z caron  z caron  OE  oe  Y diaeresis  cannot translate  FIXME c = get_32(*in, from); only support ascii supersets  FIXME... fall thru and count replacement in latin1 case  fall through 