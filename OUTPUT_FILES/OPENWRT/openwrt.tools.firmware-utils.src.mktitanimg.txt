 The checksum for the complete header.
 Excepting the
                                           checksum block **************************************************************************
 * void print_help(void)
 ****************************************************************************************************************************************************
 * void mknspimg_print_hdr(NSP_IMG_HDR* p_img_hdr)
 **************************************************************************	MIN	MAX	FLAGS					OPTION	 '-a' align1 align2  '-b' bootstrap  '-c'  '-d'  '-e'  '-f' flags  '-g'  '-h'  '-i arg1 arg2 '  '-j'  '-k'  '-l'  '-m'  '-n'  '-o arg'  '-p' PROD_ID  '-q'  '-r' REL_ID  '-s' "Release XXX.XXX"  '-t'  '-u'  '-v' control VERBOSE/NON-VERBOSE mode  '-w'  '-x'  '-y'  '-z'  global arguments **************************************************************************
 * int nsp_img_write(void* image, char* file, int padding)
 * Write out the image.
 ************************************************************************** loop variables  We require exactly two image with -i option
							   (see CMDLINE_CFG structure above)  Start of image header  Section pointers  Configure the command line.  Read and parse the command line.  Check for parsing errors.  Get the parse error message  Print it out  Print our help too  Set up arguments  Command line arguments have been parsed. Start doing our work.  Caculate the header size, and allocate the memory, and assign the sub pointers  This has a single section
								   desc block already 	chksum = (struct nsp_img_hdr_chksum *)
			((unsigned int)image_hdr + header_size - sizeof(struct nsp_img_hdr_chksum)); Open the out file  Skip image header. We'll come back to it after we've written out the images.  The user indicated no padding  Calculate number padding bytes  Write out all specified images (with -i option)  input file name  input file pointer  number of padding bytes to prepend  align factor from command line  intermediate result  Open the specified image for reading  Determine file size  Retrieve the alignment constant  Set image offset from the beginning of the out file  + padding;total += padding; Copy the image file into nsp_image  HACK: This is a hack to get the names and types to the files.
			TODO: Fix this to be a real method  Account for the total total += section->raw_size; Close the input file  Move the section pointer to the next slot  Take care of the NSP image header fields  head fields  Set to all 1's 	image_hdr->head.chksum_offset	= (unsigned int)chksum - (unsigned int)image_hdr;	image_hdr->head.pad1 = 0xffffffff; info fields  TODO: Fix. Do nothing yet 	strncpy(nsp_img_hdr.id.prod_info,NSP_PRODINFO_STRING,sizeof(NSP_PRODINFO_STRING)); section fields  Calculate checksum(s)  Write out the NSP header.  Check if -v option was specified (no arg needed)  Rewind the file back to the beginning  Read header from the file  Get memory to store the complete header  Read header from the file  Print it out  Close NSP image file  return result  DMALLOC  ********* Library internal data *********  No Error (OK)  Unspecified error  Invalid option key  Too many arguments  Too few arguments  Option not allowed (illegal option)  No memory  A mandatory option is missing  Argument list  Index of the argument in the command line  Next node in the linked list  Master control block for an option  Total count of arguments found  Total count of options found  Argument list  Master control block for all found arguments  Array of MCBs for each option ('a' through 'z')  Global arguments  Internal flag to prevent client calls if library is not initialized  ********* Local Data *********  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Check the validity of the index  ERROR: Wrong option  Return a pointer to the ARGS control structure  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Return number of arguments for this option  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Calculate index value  Return number of arguments for this option  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Search the 'num' argument in the list for this option  if num matches i, we found it  We did not find the specified argument or the list was empty  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  reset global data  Copy the user's config structure  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  TODO: implement a table of error messages  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Check if the command line was parsed  Print out option arguments  Check if the option was specified  Print out option name and arguments  Print out global arguments  ***************************************************************
* Print configuration
******************************************************************  See if we had anything in the list  Link the argument in  Find the tail of the list  Link the argument in  Keep track of arg number  ***************************************************************
* cmdline_read()
* Read and parse command line arguments
******************************************************************  Process every command line argument in argv[] array  Does the argument start with a dash?  The argument must be two characters: a dash, and a letter  ERROR: option syntax (needs to be a dash and one letter)  Check validity of the option key ('a' through 'z')  ERROR: option sysntax (invalid option key)  Calculate the option index  Check to see if the option is allowed  Option allowed.  ERROR: Option is not allowed  Read the arguments for the option  Allocate space for the argument node  ERROR: Can't allocate memory for the argument index  Initialize the argument  Check if we can add to the list of arguments for this option  Do we have to add to the global list?  Did we reach MAX arguments?  This option does not require arguments. Keep the argument in the global list.  See if the current count has reached max for this option  ERROR: too many arguments for an option  Link the argument to the arg list of the option  ****** We read the complete command line. See if what we collected matches the configuration *******  Check every collected option against its configuration  Check if this option was allowed  See if it was mandatory  Check if we really collected this option on the command line.  ERROR: a missing mandatory option  Option was there. Check how many args we got for it.  ERROR: too few arguments for an option  This mandatory option was proper.  This is non-mandatory option:  Check if the option was specified on the command line  option wasn't specified, go to the next  Option was there. Check how many args we collected for it.  ERROR: too few arguments for a non-mandatory option  This non-mandatory option was proper.  Option was not allowed.  We should not get here as the non-allowed options should have been
			trapped eariler.  Command line was proper as far as the number of options and their arguments  The checksum for the complete header.
 Excepting the
                                           checksum block **************************************************************************
 * void print_help(void)
 ****************************************************************************************************************************************************
 * void mknspimg_print_hdr(NSP_IMG_HDR* p_img_hdr)
 **************************************************************************	MIN	MAX	FLAGS					OPTION	 '-a' align1 align2  '-b' bootstrap  '-c'  '-d'  '-e'  '-f' flags  '-g'  '-h'  '-i arg1 arg2 '  '-j'  '-k'  '-l'  '-m'  '-n'  '-o arg'  '-p' PROD_ID  '-q'  '-r' REL_ID  '-s' "Release XXX.XXX"  '-t'  '-u'  '-v' control VERBOSE/NON-VERBOSE mode  '-w'  '-x'  '-y'  '-z'  global arguments **************************************************************************
 * int nsp_img_write(void* image, char* file, int padding)
 * Write out the image.
 ************************************************************************** loop variables  We require exactly two image with -i option
							   (see CMDLINE_CFG structure above)  Start of image header  Section pointers  Configure the command line.  Read and parse the command line.  Check for parsing errors.  Get the parse error message  Print it out  Print our help too  Set up arguments  Command line arguments have been parsed. Start doing our work.  Caculate the header size, and allocate the memory, and assign the sub pointers  This has a single section
								   desc block already 	chksum = (struct nsp_img_hdr_chksum *)
			((unsigned int)image_hdr + header_size - sizeof(struct nsp_img_hdr_chksum)); Open the out file  Skip image header. We'll come back to it after we've written out the images.  The user indicated no padding  Calculate number padding bytes  Write out all specified images (with -i option)  input file name  input file pointer  number of padding bytes to prepend  align factor from command line  intermediate result  Open the specified image for reading  Determine file size  Retrieve the alignment constant  Set image offset from the beginning of the out file  + padding;total += padding; Copy the image file into nsp_image  HACK: This is a hack to get the names and types to the files.
			TODO: Fix this to be a real method  Account for the total total += section->raw_size; Close the input file  Move the section pointer to the next slot  Take care of the NSP image header fields  head fields  Set to all 1's 	image_hdr->head.chksum_offset	= (unsigned int)chksum - (unsigned int)image_hdr;	image_hdr->head.pad1 = 0xffffffff; info fields  TODO: Fix. Do nothing yet 	strncpy(nsp_img_hdr.id.prod_info,NSP_PRODINFO_STRING,sizeof(NSP_PRODINFO_STRING)); section fields  Calculate checksum(s)  Write out the NSP header.  Check if -v option was specified (no arg needed)  Rewind the file back to the beginning  Read header from the file  Get memory to store the complete header  Read header from the file  Print it out  Close NSP image file  return result  DMALLOC  ********* Library internal data *********  No Error (OK)  Unspecified error  Invalid option key  Too many arguments  Too few arguments  Option not allowed (illegal option)  No memory  A mandatory option is missing  Argument list  Index of the argument in the command line  Next node in the linked list  Master control block for an option  Total count of arguments found  Total count of options found  Argument list  Master control block for all found arguments  Array of MCBs for each option ('a' through 'z')  Global arguments  Internal flag to prevent client calls if library is not initialized  ********* Local Data *********  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Check the validity of the index  ERROR: Wrong option  Return a pointer to the ARGS control structure  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Return number of arguments for this option  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Calculate index value  Return number of arguments for this option  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Search the 'num' argument in the list for this option  if num matches i, we found it  We did not find the specified argument or the list was empty  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  reset global data  Copy the user's config structure  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  TODO: implement a table of error messages  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  ***************************************************************
* Print all found command line options and their arguments
******************************************************************  Check if the command line was parsed  Print out option arguments  Check if the option was specified  Print out option name and arguments  Print out global arguments  ***************************************************************
* Print configuration
******************************************************************  See if we had anything in the list  Link the argument in  Find the tail of the list  Link the argument in  Keep track of arg number  ***************************************************************
* cmdline_read()
* Read and parse command line arguments
******************************************************************  Process every command line argument in argv[] array  Does the argument start with a dash?  The argument must be two characters: a dash, and a letter  ERROR: option syntax (needs to be a dash and one letter)  Check validity of the option key ('a' through 'z')  ERROR: option sysntax (invalid option key)  Calculate the option index  Check to see if the option is allowed  Option allowed.  ERROR: Option is not allowed  Read the arguments for the option  Allocate space for the argument node  ERROR: Can't allocate memory for the argument index  Initialize the argument  Check if we can add to the list of arguments for this option  Do we have to add to the global list?  Did we reach MAX arguments?  This option does not require arguments. Keep the argument in the global list.  See if the current count has reached max for this option  ERROR: too many arguments for an option  Link the argument to the arg list of the option  ****** We read the complete command line. See if what we collected matches the configuration *******  Check every collected option against its configuration  Check if this option was allowed  See if it was mandatory  Check if we really collected this option on the command line.  ERROR: a missing mandatory option  Option was there. Check how many args we got for it.  ERROR: too few arguments for an option  This mandatory option was proper.  This is non-mandatory option:  Check if the option was specified on the command line  option wasn't specified, go to the next  Option was there. Check how many args we collected for it.  ERROR: too few arguments for a non-mandatory option  This non-mandatory option was proper.  Option was not allowed.  We should not get here as the non-allowed options should have been
			trapped eariler.  Command line was proper as far as the number of options and their arguments 