  Shine is an MP3 encoder
 *  Copyright (C) 1999-2000  Gabriel Bouvigne
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.  0=(MPEG2 - 22.05,24,16kHz) 1=(MPEG1 - 44.1,48,32kHz)  0=stereo, 1=jstereo, 2=dual, 3=mono   Side information  number of 0-1-quadruples   current bitpos for writing  max. index                   pointer to array[len][len]   pointer to array[len][len]   max. index                    number of linbits             max number stored in linbits  sqrt(2) * 512   6656 Bytes   9216 Bytes   2304 Bytes    576 Bytes   1152 Bytes   1056 Bytes     16 Bytes     16 Bytes     18 Bytes    144 Bytes    862 Bytes   8192 Bytes     64 Bytes     64 Bytes     36 Bytes     64 Bytes   1024 Bytes   1024 Bytes    144 Bytes    256 Bytes  table0  hleng0  table1  hleng1  Apparently not used  Apparently not used  Apparently not used   0 bands   1 bands   2 bands   3 bands   4 bands   5 bands   6 bands   7 bands   8 bands   9 bands  10 bands  11 bands  12 bands  13 bands  14 bands  15 bands  16 bands  17 bands  18 bands  19 bands  20 bands  21 bands  22 bands  Table B.2.b: 22.05 kHz  Table B.2.c: 24 kHz  Table B.2.a: 16 kHz  Table B.8.b: 44.1 kHz  Table B.8.c: 48 kHz  Table B.8.a: 32 kHz   int2idx[i] = sqrt(i*sqrt(i));  MPEG 2  MPEG 1  MPEG 2  MPEG 1  0  1  2  3  4  5  6  7  8  9  encode chunk counter     forward declarations  return 1 on match, 0 on no match  rockbox: comment 'set but unused" variable
  unsigned long   dAvgBytesPerSec;
  unsigned short  wBlockAlign;
   complete wave chunk size  chunk size dAvgBytesPerSecwBlockAlign     linear PCM required  16 bps required  <=2 channels required  Sample rates != 16/22.05/24/32/44.1/48 kHz are not supported.   SAMP_PER_FRAME*MAX_CHANNELS  requires bits_per_sample==16  Pad last sample with zeros  interleave the mono samples to stereo as required by encoder  interleaving is correct for stereo 
   * MPEG header layout:
   * AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
   * A (31-21) = frame sync
   * B (20-19) = MPEG type
   * C (18-17) = MPEG layer
   * D (16)    = protection bit
   * E (15-12) = bitrate index
   * F (11-10) = samplerate index
   * G (9)     = padding bit
   * H (8)     = private bit
   * I (7-6)   = channel mode
   * J (5-4)   = mode extension (jstereo only)
   * K (3)     = copyright bit
   * L (2)     = original
   * M (1-0)   = emphasis
    frame sync (AAAAAAAAA AAA)
                              mp3 type (upper):  1 (B)   mp3 layer:        01 (CC)  mp3 crc:           1 (D)   mp3 org:           1 (L)   no emphasis (bits 0-1)  MPEG1  add scale_facs array size  set scale_facs compr type  set scale_facs to 1bit  MPEG2  add scale_facs array size  set scale_facs compr type  set scale_facs to 1bit  flush remaining bits  Note the discussion of huffmancodebits() on pages 28 and 29 of the IS,
   as well as the definitions of the side information on pages 26 and 27.  store scale_facs (part1) store scale_facs (part2) Huffman code tables leed to padding ones  flush remaining bits  Implements the pseudocode of page 98 of the IS  ESC-table is used  No ESC-words  flush remaining bits  data fit in one uint32_t *************************************************************************  Choose the Huffman table that will encode ix[begin..end] with            the fewest bits.                                                         Note: This code contains knowledge about the sizes and characteristic    of the Huffman tables as defined in the IS (Table B.7), and will not     work with any arbitrary tables.                                        ************************************************************************* tables without linbits  indx: 0  1  2  3  4  5  6  7  8  9 10 11 12  13 14  15   len: 0, 2, 3, 3, 0, 4, 4, 6, 6, 6, 8, 8, 8, 16, 0, 16  tables with linbits  avoid overflow in packed additions: 78*13 < 1024 *********************************************************************** Function: Count the number of bits necessary to code the subregion.   *********************************************************************** this is table1  ESC-table is used *********************************************************************** Function: Calculation of rzero, count1, address3                       (Partitions ix into big values, quadruples and zeros).                *********************************************************************** !!!! short *ix; !!!!! ***********************************************************************   Function: Quantization of the vector xr ( -> ix)                    *********************************************************************** check for possible 'out of range' values  all values fit the table size  check each index wether it fits the table *********************************************************************** subdivides the bigvalue region which will use separate Huffman tables *********************************************************************** no bigvalue region  Calculate scale factor band index ***************************************************************** Count the number of bits necessary to code the bigvalues region ***************************************************************** Select huffman code tables for bigvalues regions  region0  region1  region2  rzero,count1,address3   bigvalues sfb division  bit count ********************************************************************** The code selects the best quantStep for a particular set of scalefacs********************************************************************** distribute reserved bits to remaining granules  unused bits of the reservoir can be used for remaining granules  end: distribute the reserved bits to one or two granules  mp3 format allows max 12bits for granule length  returns sum_j=0^31 a[j]*cos(PI*j*(k+1/2)/32), 0<=k<32  d4 = x2[-224]  load 8 values  load 8 values  load 8 values  load 8 values  d4 = x1[-32]  load 8 values  load 8 values  load 8 values  A0  A1  A2  A3  A0  A1  A2  A3  x1[-572] .... x1[448] = 1022  18*4*16*32  A0  A1  A2  A3  rewind wk (to next channel start)  1,2, 5,6, 9,10, 13,14, 17  set default values: MPEG1 at 44100/s  0=stereo, 3=mono  use MPEG2 format  use MPEG1 format  Apparently not used  Apparently not used  Apparently not used  Figure average number of 'bytes' per frame  calc average of first 256 frequency values  if max of current band is smaller than average, increase precision  last band keeps untouched (not scaled)  encode one mp3 frame in this loop  Padding for this frame  reserved for scale_facs shift out old samples  read new samples to iram for further processing  swap bytes if neccessary  leave space for mp3 header  16bit packed wav data can be windowed efficiently on coldfire  36864=4*18*16*32  Compensate for inversion in the analysis filter  Perform imdct of 18 previous + 18 current subband samples  for integer precision do this loop again (if neccessary)   9216=4*32*9*8  7200=4*18*100  Perform aliasing reduction butterfly  negative  positive  calc new shift for higher integer precision  bit and noise allocation  write the frame to the bitstream  finish this chunk by adding sideinfo header data  copy iram mp3 buffer to sdram/file  write last chunks to disk  for rate selection  integer mode  set 128kBit as default  unit=.01s   Shine is an MP3 encoder
 *  Copyright (C) 1999-2000  Gabriel Bouvigne
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.  0=(MPEG2 - 22.05,24,16kHz) 1=(MPEG1 - 44.1,48,32kHz)  0=stereo, 1=jstereo, 2=dual, 3=mono   Side information  number of 0-1-quadruples   current bitpos for writing  max. index                   pointer to array[len][len]   pointer to array[len][len]   max. index                    number of linbits             max number stored in linbits  sqrt(2) * 512   6656 Bytes   9216 Bytes   2304 Bytes    576 Bytes   1152 Bytes   1056 Bytes     16 Bytes     16 Bytes     18 Bytes    144 Bytes    862 Bytes   8192 Bytes     64 Bytes     64 Bytes     36 Bytes     64 Bytes   1024 Bytes   1024 Bytes    144 Bytes    256 Bytes  table0  hleng0  table1  hleng1  Apparently not used  Apparently not used  Apparently not used   0 bands   1 bands   2 bands   3 bands   4 bands   5 bands   6 bands   7 bands   8 bands   9 bands  10 bands  11 bands  12 bands  13 bands  14 bands  15 bands  16 bands  17 bands  18 bands  19 bands  20 bands  21 bands  22 bands  Table B.2.b: 22.05 kHz  Table B.2.c: 24 kHz  Table B.2.a: 16 kHz  Table B.8.b: 44.1 kHz  Table B.8.c: 48 kHz  Table B.8.a: 32 kHz   int2idx[i] = sqrt(i*sqrt(i));  MPEG 2  MPEG 1  MPEG 2  MPEG 1  0  1  2  3  4  5  6  7  8  9  encode chunk counter     forward declarations  return 1 on match, 0 on no match  rockbox: comment 'set but unused" variable
  unsigned long   dAvgBytesPerSec;
  unsigned short  wBlockAlign;
   complete wave chunk size  chunk size dAvgBytesPerSecwBlockAlign     linear PCM required  16 bps required  <=2 channels required  Sample rates != 16/22.05/24/32/44.1/48 kHz are not supported.   SAMP_PER_FRAME*MAX_CHANNELS  requires bits_per_sample==16  Pad last sample with zeros  interleave the mono samples to stereo as required by encoder  interleaving is correct for stereo 
   * MPEG header layout:
   * AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
   * A (31-21) = frame sync
   * B (20-19) = MPEG type
   * C (18-17) = MPEG layer
   * D (16)    = protection bit
   * E (15-12) = bitrate index
   * F (11-10) = samplerate index
   * G (9)     = padding bit
   * H (8)     = private bit
   * I (7-6)   = channel mode
   * J (5-4)   = mode extension (jstereo only)
   * K (3)     = copyright bit
   * L (2)     = original
   * M (1-0)   = emphasis
    frame sync (AAAAAAAAA AAA)
                              mp3 type (upper):  1 (B)   mp3 layer:        01 (CC)  mp3 crc:           1 (D)   mp3 org:           1 (L)   no emphasis (bits 0-1)  MPEG1  add scale_facs array size  set scale_facs compr type  set scale_facs to 1bit  MPEG2  add scale_facs array size  set scale_facs compr type  set scale_facs to 1bit  flush remaining bits  Note the discussion of huffmancodebits() on pages 28 and 29 of the IS,
   as well as the definitions of the side information on pages 26 and 27.  store scale_facs (part1) store scale_facs (part2) Huffman code tables leed to padding ones  flush remaining bits  Implements the pseudocode of page 98 of the IS  ESC-table is used  No ESC-words  flush remaining bits  data fit in one uint32_t *************************************************************************  Choose the Huffman table that will encode ix[begin..end] with            the fewest bits.                                                         Note: This code contains knowledge about the sizes and characteristic    of the Huffman tables as defined in the IS (Table B.7), and will not     work with any arbitrary tables.                                        ************************************************************************* tables without linbits  indx: 0  1  2  3  4  5  6  7  8  9 10 11 12  13 14  15   len: 0, 2, 3, 3, 0, 4, 4, 6, 6, 6, 8, 8, 8, 16, 0, 16  tables with linbits  avoid overflow in packed additions: 78*13 < 1024 *********************************************************************** Function: Count the number of bits necessary to code the subregion.   *********************************************************************** this is table1  ESC-table is used *********************************************************************** Function: Calculation of rzero, count1, address3                       (Partitions ix into big values, quadruples and zeros).                *********************************************************************** !!!! short *ix; !!!!! ***********************************************************************   Function: Quantization of the vector xr ( -> ix)                    *********************************************************************** check for possible 'out of range' values  all values fit the table size  check each index wether it fits the table *********************************************************************** subdivides the bigvalue region which will use separate Huffman tables *********************************************************************** no bigvalue region  Calculate scale factor band index ***************************************************************** Count the number of bits necessary to code the bigvalues region ***************************************************************** Select huffman code tables for bigvalues regions  region0  region1  region2  rzero,count1,address3   bigvalues sfb division  bit count ********************************************************************** The code selects the best quantStep for a particular set of scalefacs********************************************************************** distribute reserved bits to remaining granules  unused bits of the reservoir can be used for remaining granules  end: distribute the reserved bits to one or two granules  mp3 format allows max 12bits for granule length  returns sum_j=0^31 a[j]*cos(PI*j*(k+1/2)/32), 0<=k<32  d4 = x2[-224]  load 8 values  load 8 values  load 8 values  load 8 values  d4 = x1[-32]  load 8 values  load 8 values  load 8 values  A0  A1  A2  A3  A0  A1  A2  A3  x1[-572] .... x1[448] = 1022  18*4*16*32  A0  A1  A2  A3  rewind wk (to next channel start)  1,2, 5,6, 9,10, 13,14, 17  set default values: MPEG1 at 44100/s  0=stereo, 3=mono  use MPEG2 format  use MPEG1 format  Apparently not used  Apparently not used  Apparently not used  Figure average number of 'bytes' per frame  calc average of first 256 frequency values  if max of current band is smaller than average, increase precision  last band keeps untouched (not scaled)  encode one mp3 frame in this loop  Padding for this frame  reserved for scale_facs shift out old samples  read new samples to iram for further processing  swap bytes if neccessary  leave space for mp3 header  16bit packed wav data can be windowed efficiently on coldfire  36864=4*18*16*32  Compensate for inversion in the analysis filter  Perform imdct of 18 previous + 18 current subband samples  for integer precision do this loop again (if neccessary)   9216=4*32*9*8  7200=4*18*100  Perform aliasing reduction butterfly  negative  positive  calc new shift for higher integer precision  bit and noise allocation  write the frame to the bitstream  finish this chunk by adding sideinfo header data  copy iram mp3 buffer to sdram/file  write last chunks to disk  for rate selection  integer mode  set 128kBit as default  unit=.01s   Shine is an MP3 encoder
 *  Copyright (C) 1999-2000  Gabriel Bouvigne
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.  0=(MPEG2 - 22.05,24,16kHz) 1=(MPEG1 - 44.1,48,32kHz)  0=stereo, 1=jstereo, 2=dual, 3=mono   Side information  number of 0-1-quadruples   current bitpos for writing  max. index                   pointer to array[len][len]   pointer to array[len][len]   max. index                    number of linbits             max number stored in linbits  sqrt(2) * 512   6656 Bytes   9216 Bytes   2304 Bytes    576 Bytes   1152 Bytes   1056 Bytes     16 Bytes     16 Bytes     18 Bytes    144 Bytes    862 Bytes   8192 Bytes     64 Bytes     64 Bytes     36 Bytes     64 Bytes   1024 Bytes   1024 Bytes    144 Bytes    256 Bytes  table0  hleng0  table1  hleng1  Apparently not used  Apparently not used  Apparently not used   0 bands   1 bands   2 bands   3 bands   4 bands   5 bands   6 bands   7 bands   8 bands   9 bands  10 bands  11 bands  12 bands  13 bands  14 bands  15 bands  16 bands  17 bands  18 bands  19 bands  20 bands  21 bands  22 bands  Table B.2.b: 22.05 kHz  Table B.2.c: 24 kHz  Table B.2.a: 16 kHz  Table B.8.b: 44.1 kHz  Table B.8.c: 48 kHz  Table B.8.a: 32 kHz   int2idx[i] = sqrt(i*sqrt(i));  MPEG 2  MPEG 1  MPEG 2  MPEG 1  0  1  2  3  4  5  6  7  8  9  encode chunk counter     forward declarations  return 1 on match, 0 on no match  rockbox: comment 'set but unused" variable
  unsigned long   dAvgBytesPerSec;
  unsigned short  wBlockAlign;
   complete wave chunk size  chunk size dAvgBytesPerSecwBlockAlign     linear PCM required  16 bps required  <=2 channels required  Sample rates != 16/22.05/24/32/44.1/48 kHz are not supported.   SAMP_PER_FRAME*MAX_CHANNELS  requires bits_per_sample==16  Pad last sample with zeros  interleave the mono samples to stereo as required by encoder  interleaving is correct for stereo 
   * MPEG header layout:
   * AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
   * A (31-21) = frame sync
   * B (20-19) = MPEG type
   * C (18-17) = MPEG layer
   * D (16)    = protection bit
   * E (15-12) = bitrate index
   * F (11-10) = samplerate index
   * G (9)     = padding bit
   * H (8)     = private bit
   * I (7-6)   = channel mode
   * J (5-4)   = mode extension (jstereo only)
   * K (3)     = copyright bit
   * L (2)     = original
   * M (1-0)   = emphasis
    frame sync (AAAAAAAAA AAA)
                              mp3 type (upper):  1 (B)   mp3 layer:        01 (CC)  mp3 crc:           1 (D)   mp3 org:           1 (L)   no emphasis (bits 0-1)  MPEG1  add scale_facs array size  set scale_facs compr type  set scale_facs to 1bit  MPEG2  add scale_facs array size  set scale_facs compr type  set scale_facs to 1bit  flush remaining bits  Note the discussion of huffmancodebits() on pages 28 and 29 of the IS,
   as well as the definitions of the side information on pages 26 and 27.  store scale_facs (part1) store scale_facs (part2) Huffman code tables leed to padding ones  flush remaining bits  Implements the pseudocode of page 98 of the IS  ESC-table is used  No ESC-words  flush remaining bits  data fit in one uint32_t *************************************************************************  Choose the Huffman table that will encode ix[begin..end] with            the fewest bits.                                                         Note: This code contains knowledge about the sizes and characteristic    of the Huffman tables as defined in the IS (Table B.7), and will not     work with any arbitrary tables.                                        ************************************************************************* tables without linbits  indx: 0  1  2  3  4  5  6  7  8  9 10 11 12  13 14  15   len: 0, 2, 3, 3, 0, 4, 4, 6, 6, 6, 8, 8, 8, 16, 0, 16  tables with linbits  avoid overflow in packed additions: 78*13 < 1024 *********************************************************************** Function: Count the number of bits necessary to code the subregion.   *********************************************************************** this is table1  ESC-table is used *********************************************************************** Function: Calculation of rzero, count1, address3                       (Partitions ix into big values, quadruples and zeros).                *********************************************************************** !!!! short *ix; !!!!! ***********************************************************************   Function: Quantization of the vector xr ( -> ix)                    *********************************************************************** check for possible 'out of range' values  all values fit the table size  check each index wether it fits the table *********************************************************************** subdivides the bigvalue region which will use separate Huffman tables *********************************************************************** no bigvalue region  Calculate scale factor band index ***************************************************************** Count the number of bits necessary to code the bigvalues region ***************************************************************** Select huffman code tables for bigvalues regions  region0  region1  region2  rzero,count1,address3   bigvalues sfb division  bit count ********************************************************************** The code selects the best quantStep for a particular set of scalefacs********************************************************************** distribute reserved bits to remaining granules  unused bits of the reservoir can be used for remaining granules  end: distribute the reserved bits to one or two granules  mp3 format allows max 12bits for granule length  returns sum_j=0^31 a[j]*cos(PI*j*(k+1/2)/32), 0<=k<32  d4 = x2[-224]  load 8 values  load 8 values  load 8 values  load 8 values  d4 = x1[-32]  load 8 values  load 8 values  load 8 values  A0  A1  A2  A3  A0  A1  A2  A3  x1[-572] .... x1[448] = 1022  18*4*16*32  A0  A1  A2  A3  rewind wk (to next channel start)  1,2, 5,6, 9,10, 13,14, 17  set default values: MPEG1 at 44100/s  0=stereo, 3=mono  use MPEG2 format  use MPEG1 format  Apparently not used  Apparently not used  Apparently not used  Figure average number of 'bytes' per frame  calc average of first 256 frequency values  if max of current band is smaller than average, increase precision  last band keeps untouched (not scaled)  encode one mp3 frame in this loop  Padding for this frame  reserved for scale_facs shift out old samples  read new samples to iram for further processing  swap bytes if neccessary  leave space for mp3 header  16bit packed wav data can be windowed efficiently on coldfire  36864=4*18*16*32  Compensate for inversion in the analysis filter  Perform imdct of 18 previous + 18 current subband samples  for integer precision do this loop again (if neccessary)   9216=4*32*9*8  7200=4*18*100  Perform aliasing reduction butterfly  negative  positive  calc new shift for higher integer precision  bit and noise allocation  write the frame to the bitstream  finish this chunk by adding sideinfo header data  copy iram mp3 buffer to sdram/file  write last chunks to disk  for rate selection  integer mode  set 128kBit as default  unit=.01s 