
 * "Build Engine & Tools" Copyright (c) 1993-1997 Ken Silverman
 * Ken Silverman's official web site: "http://www.advsys.net/ken"
 * See the included license file "BUILDLIC.TXT" for license info.
 * This file has been modified from Ken Silverman's original release
  SUPERBUILD define is in engine.h ...  Warning: This depends on MAXYSAVES & MAXYDIM!  used to be static. --ryan.  used to be static. --ryan.  used to be static. --ryan.  Textured Map variables 
 * !!! used to be static. If we ever put the original setgamemode() back, this
 * !!! can be made static again.  --ryan.
  This is the structure emitted for each wall that is potentially visible. A stack of those is populated when the sectors are scanned.Camera space coordinates of the wall endpoints. Access with vector_index_e.The index of the sector this wall belongs to in the map database.The index of the wall in the map database.Screen space coordinate of the wall endpoints. Access with screenSpaceCoo_index_e. Potentially Visible walls are stored in this stack.xb1 and xb2 seems to be storing the column of the wall endpointyb1 and yb2 store the Y distance from the camera.static int32_t xb1[MAXWALLSB], yb1[MAXWALLSB], xb2[MAXWALLSB], yb2[MAXWALLSB];
//rx1,rx2,ry1,ry2 stores the cameraspace wall endpoints coordinates.
static int32_t rx1[MAXWALLSB], ry1[MAXWALLSB], rx2[MAXWALLSB], ry2[MAXWALLSB];
static short thesector[MAXWALLSB], thewall[MAXWALLSB];
 bunchWallsList contains the list of walls in a bunch.FCS: (up-most pixel on column x that can still be drawn to)FCS: (down-most pixel +1 on column x that can still be drawn to) used to be static. --ryan. FCS: Those two variables are using during portal flooding: sectorBorder is the stack and sectorbordercnt is the stack counter. There is no really point to have this on the heap. That would have been better on the stack.static short sectorborder[256], sectorbordercnt;FCS: Moved this on the stackFCS: Num walls to potentially render.FCS: Number of colums to draw. ALWAYS set to the screen dimension width. search input   search output  Ken did this Ken did this krecip
 FCS:
 Scan through sectors using portals (a portal is wall with a nextsector attribute >= 0).
 Flood is prevented if a portal does not face the POV.
 The stack storing sectors to visit.Add every script in the current sector as potentially visible.Mark the current sector bit as "visited" in the bitvector In camera space the center is the player. Tranform the 2 Wall endpoints (x,y) from worldspace to camera space. After that we have two vectors starting from the camera and going to the endpoints (x1,y1) and (x2,y2). If this is a portal...If this portal has not been visited yet.Cross product -> Z component Using cross product, determine if the portal is facing us or not. If it is: Add it to the stack and bump the stack counter. This line is equivalent to tempint < 0x40000 ??? What is this test ?? How acute the angle is ?(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) is the squared length of the wall ??? What is this test ?? How acute the angle is ? Rotate the wall endpoints vectors according to the player orientation. This is a regular rotation matrix using [29.3] fixed point.If this is the first endpoint of the bunch, rotate: This is a standard cos sin 2D rotation matrix projectionIf this is NOT the first endpoint, Save the coordinate for next loop. Rotate: This is a standard cos sin 2D rotation matrix projection Equivalent of a near plane clipping ? If wall's NOT facing you  The wall is still not eligible for rendition: Let's do some more Frustrum culling !!Project the point onto screen and see in which column it belongs. Fix for SIGNED divide  Fix for SIGNED divide  Made it all the way! Time to add this wall information to the stack of wall potentially visible.Save the camera space wall endpoints coordinate (camera origin at player location + rotated according to player orientation).FCS: TODO rename this p2[] to bunchList[] or something like that. This name is an abomination     DONE, p2 is now called "bunchWallsList".Break down the list of walls for this sector into bunchs. Since a bunch is a continuously visible list of wall: A sector can generate many bunches. Create an entry in the bunch listMark the end of the bunch wall list.For each bunch, find the last wall and cache it in bunchlast. do this until the stack of sectors to visit if empty.
 FCS:
    
 Goal : ????
 param 1: Z is the wallID in the list of potentially visible walls.
 param 2: Only used to lookup the xrepeat attribute of the wall.
 
 lwall calculation Let's use some of the camera space wall coordinate now.X screenspce column of point Z.If the wall is less than 4 column wide.If the wall is less than 2 columns wide.The wall is 1 column wide. renders non-parallaxed ceilings. --ryan. Check the tile dimension are valid. renders non-parallaxed floors. --ryan. Retrieve the sector objectRetrieve the floor palette.We are UNDER the floor: Do NOT render anything.Retrive the floor texture.Lock the floor textureThis tile has unvalid dimensions ( negative)If this is an animated texture: Animate it.If the texture is not in RAM: Load it !!Check where is the texture in RAMRetrieve the shade of the sector (illumination level).Setup the drawing routine paramters
 * renders walls and parallaxed skies/floors. Look at parascan() for the
 *  higher level of parallaxing.
 *
 *    x1 == offset of leftmost pixel of wall. 0 is left of surface.
 *    x2 == offset of rightmost pixel of wall. 0 is left of surface.
 *
 *  apparently, walls are always vertical; there are sloping functions
 *   (!!!) er...elsewhere. Only the sides need be vertical, as the top and
 *   bottom of the polygon will need to be angled as the camera perspective
 *   shifts (user spins in a circle, etc.)
 *
 *  uwal is an array of the upper most pixels, and dwal are the lower most.
 *   This must be a list, as the top and bottom of the polygon are not
 *   necessarily horizontal lines.
 *
 *   So, the screen coordinate of the top left of a wall is specified by
 *   uwal[x1], the bottom left by dwal[x1], the top right by uwal[x2], and
 *   the bottom right by dwal[x2]. Every physical point on the edge of the
 *   wall in between is specified by traversing those arrays, one pixel per
 *   element.
 *
 *  --ryan.
 Starting on the left column of the wall, check the occlusion arrays. this renders masking sprites. See wallscan(). --ryan.  renders parallaxed skies/floors  --ryan.  globalorientation = 0L; if (globalorientation&256) globalyscale = -globalyscale, globalzd = -globalzd; Don't forget to change this in A.ASM also!  Back-face culling  Back-face culling  Relative alignment  JBF: was 2044     16380 Avoid visibility overflow by crossing horizon  inty = intz / (globaluclip>>16)  inty = intz / (globaldclip>>16)  uplc/dplc calculation  draw ceilings  draw floors  DRAW WALLS SECTION!  ceiling  floor  wall Animated 1 for umost  wall  2 for dmost 
                     * If can't see sector beyond, then cancel smost array and just
                     *  store wall!
                      White/1-way wall 
  FCS: Geez one more horrible algorithm to decipher :| :/ :( cry smiley..... 
  Algorithm:

  1.
  Take wall 1 vector [point1,point2] and using two cross products determine if the two endpoints of wall 2 are on the same side of Wall 1 plan.
  If they are then we can determine according to globalposx and globalposy if  wall2 is before or after wall1's plan.
  
  2. Do the same thing again but this time with wall2's plan. Try to find if wall1 is in front of behind wall2's plan.

  Key concept: If a cross-product is equal to 0 this mean they are parallel.

  Return: pvWallID1 in the potentially visible wall list is in front of pvWallID2 (in the same potentially visible list)
It seems we are going to work in Worldspace coordinates.This is part 1Wall 1's vectorThis is a cross-product between Wall 1 vector and the [Wall 1 Point 1-> Wall 2 Point 1] vector  p1(l2) vs. l1 This is a cross-product between Wall 1 vector and the [Wall 1 Point 1-> Wall 2 Point 2] vector  p2(l2) vs. l1 If the vectors a parallel, then the cross-product is zero.wall2's point1 is on wall1's plan. Those two walls are on the same plan.Wall 2's point 2 is on wall1's plan.This XOR just determine if the cross-product have the same sign and hence if both points are on the same side of wall 1 plan.Test if both points of wall2 are on the same side of wall 1 (in front or behind).cross-product have the same sign: Both points of wall2 are on the same side of wall1 : An answer is possible !!Now is time to take into account the camera position and determine which of wall1 or wall2 is seen first. pos vs. l1 Test the cross product sign difference.If (t2^t1) >= 0 then  both cross product had different sign so wall1 is in front of wall2otherwise wall2 is in front of wall1This is part 2Do it again but this time will wall2's plan.Wall 2's vector p1(l1) vs. l2  p2(l1) vs. l2  pos vs. l2 FCS: No wall is in front of the other's plan: This means they are crossing.Return 1 if bunch firstBunchID is in from of bunch secondBunchID.Bunch 1 left side is completely on the right of bunch2's right in screenspace: They do not overlap.Bunch 2 left side is completely on the right of bunch 1 right side: They do not overlap.Get the last wall in the bunch2.Get the last wall in the bunch.#include "keyboard.h"void WriteLastPaletteToFile(void);void WriteTranslucToFile(void);  
      FCS: Draw every walls in Front to Back Order.
Ceiling and Floor height at the player position. When visualizing the rendering process, part of the screen are not updated: In order to avoid the "ghost effect", we clear the framebuffer to black.CODE EXPLORATION
    if( KB_KeyDown[0x39]){ // 0x39 = SPACE
        //CODE EXPLORATION
        WriteLastPaletteToFile();
        WriteTranslucToFile();
    }        
    pixelsAllowed = pixelRenderable;printf("%d\n",pixelsAllowed); FCS: What was the point of having those values as parameters of this function....if it is to overwrite the values with the gloval variables ?!?!?FCS: Mask and keep only 11 bits of angle value.Clear the bit vector that keep track of what sector has been flooded in.Clear the occlusion array.NumHits is the number of column to draw.Num walls to potentially render. Even if the player leaves the map, the engine will keep on rendering from the last visited sector. Save it.Seem the player has left the map since updatesector cannot locate him -> Restore to the last known sector.Update the ceiling and floor Z coordinate for the player's 2D position.Build the list of potentially visible wall in to "bunches". scansector has generated the bunches, it is now time to see which ones to render. numhits is the number of column of pixels to draw: (if the screen is 320x200 then numhits starts at 200). Due to rounding error, not all columns may be drawn so an additional stop condition is here: When every bunches have been tested for rendition. tempbuf is used to mark which bunches have been elected as "closest". if tempbug[x] == 1 then it should be skipped. Almost works, but not quite :(  Double-check Draw every solid walls with ceiling/floor in the bunch "closest"Since we just rendered a bunch, lower the current stack element so we can treat the next item...and move the bunch at the top of the stack so we won't iterate on it again...Tile dimensions are invalid FIX_00058: Save/load game crash in both single and multiplayer We have to reset those arrays since the same arrays are used as temporary space in the compilecons() function like "label = (uint8_t  *)&sprite[0];" to save memory space I guess. Not reseting the array will leave dumps fooling the function saveplayer(), eg at if(actorscrptr[PN] == 0) where PN is sprite[i].picnum was beyong actorscrptr[] size) Must be after loading sectors, etc!  FIX_00009: Show map CRC and GRP file version of each player in case of Out Of Synchj = (i-64)*(i-64);CODE EXPLORATIONWritePaletteToFile(palette,"palette.tga",16, 16);CODE EXPLORATIONprintf("Num palettes lookup: %d.\n",numpalookups);Transluctent pallete is 65KB.kread(fil,transluc,65536); video driver specific.  Assume npoints=4 with polygon on &rx1,&ry1 FCS This is horrible to read: I hate you. Auto window size scaling  = scale(xdimen,yxaspect,320); 
             * If not clipping to startmosts, & auto-scaling on, as a
             *  hard-coded bonus, scale to full screen instead
              Don't aspect unscaled perms Taking care of the Y coordinates.Taking care of the X coordinates. back up these before clipping  Don't aspect unscaled perms  vlineasm4 has 256 high limit!  x,y1  x,y1  x,y2  x,y1  x2,y1  if  video driver specific.  if  Front  Front 
 FCS: Return true if the point (x,Y) is inside the sector sectnum.
 Note that a sector is closed (but can be concave) so the answer is always 0 or 1.

 Algorithm: This is an optimized raycasting inside polygon test:
 http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm
 The goal is to follow an ***horizontal*** ray passing by (x,y) and count how many
 wall are being crossed.
 If it is an odd number of time: (x,y) is inside the sector.
 If it is an even nymber of time:(x,y) is outside the sector.
 Quick check if the sector ID is valid. Compare the sign of y1 and y2. If (y1^y2) < 0 : y1 and y2 have different sign bit:  y is between wal->y and wall[wal->point2].y. The goal is to not take into consideration any wall that is totally above or totally under the point [x,y].If (x1^x2) >= 0 x1 and x2 have identic sign bit: x is on the left or the right of both wal->x and wall[wal->point2].x. If (x,y) is totally on the left or on the right, just count x1 (which indicate if we are on on the left or on the right. This is the most complicated case: X is between x1 and x2, we need a fine grained test. We need to know exactly if it is on the left or on the right in order to know if the ray is crossing the wall or not, The sign of the Cross-Product can answer this case :) !Just return the sign. If the position vector cut the sector walls an odd number of timeit is inside. Otherwise (even) it is outside.Retrive pvWall ID.Retrive world wall ID.Retrive sector IDRetrive sector.Retrive next sector. maskwall 
     * x = x1 + (x2-x1)t + (y1-y2)u  ³  x = 160v
     * y = y1 + (y2-y1)t + (x2-x1)u  ³  y = (scrx-160)v
     * z = z1 = z2                   ³  z = posz + (scry-horiz)v
      FIX_00088: crash on maps using a bad palette index (like the end of roch3.map) seem to crash when globalpal > 25 Watch out for divscale overflow  Odd xspans  Odd yspans  sprite  Odd yspans  If wall's NOT facing you  Fix for SIGNED divide  Fix for SIGNED divide  Odd yspans  INTERSECTION!  Fix for SIGNED divide  sprite  Rotate center point  Get top-left corner  Get other 3 corners  Put all points on same z  Calculate globals for hline texture mapping function  If ceilsprite is above you, reverse order of points  Clip polygon in 3-space  Clip edge 1  Clip edge 2  Clip edge 3  Clip edge 4  Project onto screen  Get uwall arrays  Get dwall arrays  Additional uwall/dwall clipping goes here  if (spritewallfront(tspr,thewall[j]) == 0)  sprite  Draw it! 
     FCS: Draw every transparent sprites in Back To Front Order. Also draw decals on the walls...
  int32_t zs, zp; Copy sprite address in a sprite proxy structure (pointers are easier to re-arrange than structs).Generate screenspace coordinate (X column and Y distance).Translate and rotate the sprite in Camera space coordinate. Delete face sprite if on wrong side! Move the sprite at the end of the array and decrease array length.FCS: Bubble sort ?! REally ?!?!? Sort sprite list  While BOTH > 0  Check to see if any sprites behind the masked wall...  remove holes in sprite list  finally safe to draw the masked wall  Init doubly-linked sprite sector lists  Init doubly-linked sprite status lists  list full  list full  p1 to p2 is a line segment  p1 towards p2 is a ray 
                 * These lines get the 2 points of the rotated sprite
                 * Given: (x1, y1) starts out as the center point
                  back side of 1-way sprite  search points CCW  search points CW if not searched all the way around  !!! ugh...move this var into clipmove as a parameter, and update build2.txt!  Extra walldist for sprites on sector lines  CLIPMASK0 = 0x00010001  CLIPMASK1 = 0x01000040  If wall's not facing you  Add 2 boxes at endpoints 
                     * These lines get the 2 points of the rotated sprite
                     * Given: (x1, y1) starts out as the center point
                      Front  Side blocker     int32_t dasprclipmask;    dasprclipmask = (cliptype>>16); Find closest point on wall (dax, day) to (*x, *y) 
 FCS:  x and y are the new position of the entity that has just moved:
 lastKnownSector is an hint (the last known sectorID of the entity).

 Thanks to the "hint", the algorithm check:
 1. Is (x,y) inside sectors[sectnum].
 2. Flood in sectnum portal and check again if (x,y) is inside.
 3. Do a linear search on sectors[sectnum] from 0 to numSectors.

 Note: Inside uses cross_product and return as soon as the point switch
 from one side to the other.
 First check the last sector where (old_x,old_y) was before being updated to (x,y)We found it and (x,y) is still in the same sector: nothing to update ! Seems (x,y) moved into an other sector....hopefully one connected via a portal. Let's flood in each portal.Damn that is a BIG move, still cannot find which sector (x,y) belongs to. Let's search via linear search. (x,y) is contained in NO sector. (x,y) is likely out of the map. tempint;            tempint = ((yp1*640+pageoffset)>>3)+(int32_t)_getVideoBase(); !!! Does this code ever get hit? Do something with this!  Draw white arrow 
 * This is ryan's change. SDL requires me to call SDL_UpdateRect() to force
 *  vid updates without a SDL_Flip() call, but there's no such thing in the
 *  DOS version of this program, so text won't show up sometimes without
 *  my update call in Linux.  However, to get a nice shadow effect on some
 *  text, Ken draws a string at an offset and darker, and then on top of it
 *  draws the actual string. Two SDL_UpdateRect() calls in over top of each
 *  other cause flicker, so I have this function here so the shadow can
 *  be drawn with _noupdate, and the actual string is draw with an update.
 For each character in the string. Extra walldist for sprites on sector lines  Collect sectors inside your square first  back  It actually got here, through all the continue's!  Render a sprite on screen. This is used by the Engine but also the Game module when drawing the HUD or the Weapon held by the player !!!If 2D target coordinate do not make sense (left > right)..Does the tile has negative dimensions ? Would be better to optimize out true bounding boxes  If non-masking write, checking for overlapping cases  Allocate palookup buffer Clamp bightness to [0-15]This is only used by drawmapview. They're pointers! - watch how you optimize this thing  maphline  maphline  Need to clip top or left  Need to clip bottom or right This seems to be dead code.clearbuf(visitedSectors,(int32_t)((numsectors+31)>>5),0L); Collect floor sprites to draw This seems to be dead code.visitedSectors[s>>3] |= pow2char[s&7]; Sort sprite list  relative alignment stuff  MUST USE RESTOREFORDRAWROOMS AFTER DRAWING  Can't reverse with uninitialized data  FIX_00085: Optimized Video driver. FPS increases by +20%.
 FCS:
 
 Output the ceiling and floor Z coordinate in the two last parameters for given:
 sectorNumber and worldspace (coordinate X,Y).
 
 If the sector is flat, this is jsut a lookup. But if either the floor/ceiling have
 a slope it requires more calculation
 
 If the sector has a slopped ceiling or a slopped floor then it needs more calculation.
 FCS:
 Search for ???
 Put correct loop at beginning  end of engine.c ... 
 * "Build Engine & Tools" Copyright (c) 1993-1997 Ken Silverman
 * Ken Silverman's official web site: "http://www.advsys.net/ken"
 * See the included license file "BUILDLIC.TXT" for license info.
 * This file has been modified from Ken Silverman's original release
  SUPERBUILD define is in engine.h ...  Warning: This depends on MAXYSAVES & MAXYDIM!  used to be static. --ryan.  used to be static. --ryan.  used to be static. --ryan.  Textured Map variables 
 * !!! used to be static. If we ever put the original setgamemode() back, this
 * !!! can be made static again.  --ryan.
  This is the structure emitted for each wall that is potentially visible. A stack of those is populated when the sectors are scanned.Camera space coordinates of the wall endpoints. Access with vector_index_e.The index of the sector this wall belongs to in the map database.The index of the wall in the map database.Screen space coordinate of the wall endpoints. Access with screenSpaceCoo_index_e. Potentially Visible walls are stored in this stack.xb1 and xb2 seems to be storing the column of the wall endpointyb1 and yb2 store the Y distance from the camera.static int32_t xb1[MAXWALLSB], yb1[MAXWALLSB], xb2[MAXWALLSB], yb2[MAXWALLSB];
//rx1,rx2,ry1,ry2 stores the cameraspace wall endpoints coordinates.
static int32_t rx1[MAXWALLSB], ry1[MAXWALLSB], rx2[MAXWALLSB], ry2[MAXWALLSB];
static short thesector[MAXWALLSB], thewall[MAXWALLSB];
 bunchWallsList contains the list of walls in a bunch.FCS: (up-most pixel on column x that can still be drawn to)FCS: (down-most pixel +1 on column x that can still be drawn to) used to be static. --ryan. FCS: Those two variables are using during portal flooding: sectorBorder is the stack and sectorbordercnt is the stack counter. There is no really point to have this on the heap. That would have been better on the stack.static short sectorborder[256], sectorbordercnt;FCS: Moved this on the stackFCS: Num walls to potentially render.FCS: Number of colums to draw. ALWAYS set to the screen dimension width. search input   search output  Ken did this Ken did this krecip
 FCS:
 Scan through sectors using portals (a portal is wall with a nextsector attribute >= 0).
 Flood is prevented if a portal does not face the POV.
 The stack storing sectors to visit.Add every script in the current sector as potentially visible.Mark the current sector bit as "visited" in the bitvector In camera space the center is the player. Tranform the 2 Wall endpoints (x,y) from worldspace to camera space. After that we have two vectors starting from the camera and going to the endpoints (x1,y1) and (x2,y2). If this is a portal...If this portal has not been visited yet.Cross product -> Z component Using cross product, determine if the portal is facing us or not. If it is: Add it to the stack and bump the stack counter. This line is equivalent to tempint < 0x40000 ??? What is this test ?? How acute the angle is ?(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) is the squared length of the wall ??? What is this test ?? How acute the angle is ? Rotate the wall endpoints vectors according to the player orientation. This is a regular rotation matrix using [29.3] fixed point.If this is the first endpoint of the bunch, rotate: This is a standard cos sin 2D rotation matrix projectionIf this is NOT the first endpoint, Save the coordinate for next loop. Rotate: This is a standard cos sin 2D rotation matrix projection Equivalent of a near plane clipping ? If wall's NOT facing you  The wall is still not eligible for rendition: Let's do some more Frustrum culling !!Project the point onto screen and see in which column it belongs. Fix for SIGNED divide  Fix for SIGNED divide  Made it all the way! Time to add this wall information to the stack of wall potentially visible.Save the camera space wall endpoints coordinate (camera origin at player location + rotated according to player orientation).FCS: TODO rename this p2[] to bunchList[] or something like that. This name is an abomination     DONE, p2 is now called "bunchWallsList".Break down the list of walls for this sector into bunchs. Since a bunch is a continuously visible list of wall: A sector can generate many bunches. Create an entry in the bunch listMark the end of the bunch wall list.For each bunch, find the last wall and cache it in bunchlast. do this until the stack of sectors to visit if empty.
 FCS:
    
 Goal : ????
 param 1: Z is the wallID in the list of potentially visible walls.
 param 2: Only used to lookup the xrepeat attribute of the wall.
 
 lwall calculation Let's use some of the camera space wall coordinate now.X screenspce column of point Z.If the wall is less than 4 column wide.If the wall is less than 2 columns wide.The wall is 1 column wide. renders non-parallaxed ceilings. --ryan. Check the tile dimension are valid. renders non-parallaxed floors. --ryan. Retrieve the sector objectRetrieve the floor palette.We are UNDER the floor: Do NOT render anything.Retrive the floor texture.Lock the floor textureThis tile has unvalid dimensions ( negative)If this is an animated texture: Animate it.If the texture is not in RAM: Load it !!Check where is the texture in RAMRetrieve the shade of the sector (illumination level).Setup the drawing routine paramters
 * renders walls and parallaxed skies/floors. Look at parascan() for the
 *  higher level of parallaxing.
 *
 *    x1 == offset of leftmost pixel of wall. 0 is left of surface.
 *    x2 == offset of rightmost pixel of wall. 0 is left of surface.
 *
 *  apparently, walls are always vertical; there are sloping functions
 *   (!!!) er...elsewhere. Only the sides need be vertical, as the top and
 *   bottom of the polygon will need to be angled as the camera perspective
 *   shifts (user spins in a circle, etc.)
 *
 *  uwal is an array of the upper most pixels, and dwal are the lower most.
 *   This must be a list, as the top and bottom of the polygon are not
 *   necessarily horizontal lines.
 *
 *   So, the screen coordinate of the top left of a wall is specified by
 *   uwal[x1], the bottom left by dwal[x1], the top right by uwal[x2], and
 *   the bottom right by dwal[x2]. Every physical point on the edge of the
 *   wall in between is specified by traversing those arrays, one pixel per
 *   element.
 *
 *  --ryan.
 Starting on the left column of the wall, check the occlusion arrays. this renders masking sprites. See wallscan(). --ryan.  renders parallaxed skies/floors  --ryan.  globalorientation = 0L; if (globalorientation&256) globalyscale = -globalyscale, globalzd = -globalzd; Don't forget to change this in A.ASM also!  Back-face culling  Back-face culling  Relative alignment  JBF: was 2044     16380 Avoid visibility overflow by crossing horizon  inty = intz / (globaluclip>>16)  inty = intz / (globaldclip>>16)  uplc/dplc calculation  draw ceilings  draw floors  DRAW WALLS SECTION!  ceiling  floor  wall Animated 1 for umost  wall  2 for dmost 
                     * If can't see sector beyond, then cancel smost array and just
                     *  store wall!
                      White/1-way wall 
  FCS: Geez one more horrible algorithm to decipher :| :/ :( cry smiley..... 
  Algorithm:

  1.
  Take wall 1 vector [point1,point2] and using two cross products determine if the two endpoints of wall 2 are on the same side of Wall 1 plan.
  If they are then we can determine according to globalposx and globalposy if  wall2 is before or after wall1's plan.
  
  2. Do the same thing again but this time with wall2's plan. Try to find if wall1 is in front of behind wall2's plan.

  Key concept: If a cross-product is equal to 0 this mean they are parallel.

  Return: pvWallID1 in the potentially visible wall list is in front of pvWallID2 (in the same potentially visible list)
It seems we are going to work in Worldspace coordinates.This is part 1Wall 1's vectorThis is a cross-product between Wall 1 vector and the [Wall 1 Point 1-> Wall 2 Point 1] vector  p1(l2) vs. l1 This is a cross-product between Wall 1 vector and the [Wall 1 Point 1-> Wall 2 Point 2] vector  p2(l2) vs. l1 If the vectors a parallel, then the cross-product is zero.wall2's point1 is on wall1's plan. Those two walls are on the same plan.Wall 2's point 2 is on wall1's plan.This XOR just determine if the cross-product have the same sign and hence if both points are on the same side of wall 1 plan.Test if both points of wall2 are on the same side of wall 1 (in front or behind).cross-product have the same sign: Both points of wall2 are on the same side of wall1 : An answer is possible !!Now is time to take into account the camera position and determine which of wall1 or wall2 is seen first. pos vs. l1 Test the cross product sign difference.If (t2^t1) >= 0 then  both cross product had different sign so wall1 is in front of wall2otherwise wall2 is in front of wall1This is part 2Do it again but this time will wall2's plan.Wall 2's vector p1(l1) vs. l2  p2(l1) vs. l2  pos vs. l2 FCS: No wall is in front of the other's plan: This means they are crossing.Return 1 if bunch firstBunchID is in from of bunch secondBunchID.Bunch 1 left side is completely on the right of bunch2's right in screenspace: They do not overlap.Bunch 2 left side is completely on the right of bunch 1 right side: They do not overlap.Get the last wall in the bunch2.Get the last wall in the bunch.#include "keyboard.h"void WriteLastPaletteToFile(void);void WriteTranslucToFile(void);  
      FCS: Draw every walls in Front to Back Order.
Ceiling and Floor height at the player position. When visualizing the rendering process, part of the screen are not updated: In order to avoid the "ghost effect", we clear the framebuffer to black.CODE EXPLORATION
    if( KB_KeyDown[0x39]){ // 0x39 = SPACE
        //CODE EXPLORATION
        WriteLastPaletteToFile();
        WriteTranslucToFile();
    }        
    pixelsAllowed = pixelRenderable;printf("%d\n",pixelsAllowed); FCS: What was the point of having those values as parameters of this function....if it is to overwrite the values with the gloval variables ?!?!?FCS: Mask and keep only 11 bits of angle value.Clear the bit vector that keep track of what sector has been flooded in.Clear the occlusion array.NumHits is the number of column to draw.Num walls to potentially render. Even if the player leaves the map, the engine will keep on rendering from the last visited sector. Save it.Seem the player has left the map since updatesector cannot locate him -> Restore to the last known sector.Update the ceiling and floor Z coordinate for the player's 2D position.Build the list of potentially visible wall in to "bunches". scansector has generated the bunches, it is now time to see which ones to render. numhits is the number of column of pixels to draw: (if the screen is 320x200 then numhits starts at 200). Due to rounding error, not all columns may be drawn so an additional stop condition is here: When every bunches have been tested for rendition. tempbuf is used to mark which bunches have been elected as "closest". if tempbug[x] == 1 then it should be skipped. Almost works, but not quite :(  Double-check Draw every solid walls with ceiling/floor in the bunch "closest"Since we just rendered a bunch, lower the current stack element so we can treat the next item...and move the bunch at the top of the stack so we won't iterate on it again...Tile dimensions are invalid FIX_00058: Save/load game crash in both single and multiplayer We have to reset those arrays since the same arrays are used as temporary space in the compilecons() function like "label = (uint8_t  *)&sprite[0];" to save memory space I guess. Not reseting the array will leave dumps fooling the function saveplayer(), eg at if(actorscrptr[PN] == 0) where PN is sprite[i].picnum was beyong actorscrptr[] size) Must be after loading sectors, etc!  FIX_00009: Show map CRC and GRP file version of each player in case of Out Of Synchj = (i-64)*(i-64);CODE EXPLORATIONWritePaletteToFile(palette,"palette.tga",16, 16);CODE EXPLORATIONprintf("Num palettes lookup: %d.\n",numpalookups);Transluctent pallete is 65KB.kread(fil,transluc,65536); video driver specific.  Assume npoints=4 with polygon on &rx1,&ry1 FCS This is horrible to read: I hate you. Auto window size scaling  = scale(xdimen,yxaspect,320); 
             * If not clipping to startmosts, & auto-scaling on, as a
             *  hard-coded bonus, scale to full screen instead
              Don't aspect unscaled perms Taking care of the Y coordinates.Taking care of the X coordinates. back up these before clipping  Don't aspect unscaled perms  vlineasm4 has 256 high limit!  x,y1  x,y1  x,y2  x,y1  x2,y1  if  video driver specific.  if  Front  Front 
 FCS: Return true if the point (x,Y) is inside the sector sectnum.
 Note that a sector is closed (but can be concave) so the answer is always 0 or 1.

 Algorithm: This is an optimized raycasting inside polygon test:
 http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm
 The goal is to follow an ***horizontal*** ray passing by (x,y) and count how many
 wall are being crossed.
 If it is an odd number of time: (x,y) is inside the sector.
 If it is an even nymber of time:(x,y) is outside the sector.
 Quick check if the sector ID is valid. Compare the sign of y1 and y2. If (y1^y2) < 0 : y1 and y2 have different sign bit:  y is between wal->y and wall[wal->point2].y. The goal is to not take into consideration any wall that is totally above or totally under the point [x,y].If (x1^x2) >= 0 x1 and x2 have identic sign bit: x is on the left or the right of both wal->x and wall[wal->point2].x. If (x,y) is totally on the left or on the right, just count x1 (which indicate if we are on on the left or on the right. This is the most complicated case: X is between x1 and x2, we need a fine grained test. We need to know exactly if it is on the left or on the right in order to know if the ray is crossing the wall or not, The sign of the Cross-Product can answer this case :) !Just return the sign. If the position vector cut the sector walls an odd number of timeit is inside. Otherwise (even) it is outside.Retrive pvWall ID.Retrive world wall ID.Retrive sector IDRetrive sector.Retrive next sector. maskwall 
     * x = x1 + (x2-x1)t + (y1-y2)u  ³  x = 160v
     * y = y1 + (y2-y1)t + (x2-x1)u  ³  y = (scrx-160)v
     * z = z1 = z2                   ³  z = posz + (scry-horiz)v
      FIX_00088: crash on maps using a bad palette index (like the end of roch3.map) seem to crash when globalpal > 25 Watch out for divscale overflow  Odd xspans  Odd yspans  sprite  Odd yspans  If wall's NOT facing you  Fix for SIGNED divide  Fix for SIGNED divide  Odd yspans  INTERSECTION!  Fix for SIGNED divide  sprite  Rotate center point  Get top-left corner  Get other 3 corners  Put all points on same z  Calculate globals for hline texture mapping function  If ceilsprite is above you, reverse order of points  Clip polygon in 3-space  Clip edge 1  Clip edge 2  Clip edge 3  Clip edge 4  Project onto screen  Get uwall arrays  Get dwall arrays  Additional uwall/dwall clipping goes here  if (spritewallfront(tspr,thewall[j]) == 0)  sprite  Draw it! 
     FCS: Draw every transparent sprites in Back To Front Order. Also draw decals on the walls...
  int32_t zs, zp; Copy sprite address in a sprite proxy structure (pointers are easier to re-arrange than structs).Generate screenspace coordinate (X column and Y distance).Translate and rotate the sprite in Camera space coordinate. Delete face sprite if on wrong side! Move the sprite at the end of the array and decrease array length.FCS: Bubble sort ?! REally ?!?!? Sort sprite list  While BOTH > 0  Check to see if any sprites behind the masked wall...  remove holes in sprite list  finally safe to draw the masked wall  Init doubly-linked sprite sector lists  Init doubly-linked sprite status lists  list full  list full  p1 to p2 is a line segment  p1 towards p2 is a ray 
                 * These lines get the 2 points of the rotated sprite
                 * Given: (x1, y1) starts out as the center point
                  back side of 1-way sprite  search points CCW  search points CW if not searched all the way around  !!! ugh...move this var into clipmove as a parameter, and update build2.txt!  Extra walldist for sprites on sector lines  CLIPMASK0 = 0x00010001  CLIPMASK1 = 0x01000040  If wall's not facing you  Add 2 boxes at endpoints 
                     * These lines get the 2 points of the rotated sprite
                     * Given: (x1, y1) starts out as the center point
                      Front  Side blocker     int32_t dasprclipmask;    dasprclipmask = (cliptype>>16); Find closest point on wall (dax, day) to (*x, *y) 
 FCS:  x and y are the new position of the entity that has just moved:
 lastKnownSector is an hint (the last known sectorID of the entity).

 Thanks to the "hint", the algorithm check:
 1. Is (x,y) inside sectors[sectnum].
 2. Flood in sectnum portal and check again if (x,y) is inside.
 3. Do a linear search on sectors[sectnum] from 0 to numSectors.

 Note: Inside uses cross_product and return as soon as the point switch
 from one side to the other.
 First check the last sector where (old_x,old_y) was before being updated to (x,y)We found it and (x,y) is still in the same sector: nothing to update ! Seems (x,y) moved into an other sector....hopefully one connected via a portal. Let's flood in each portal.Damn that is a BIG move, still cannot find which sector (x,y) belongs to. Let's search via linear search. (x,y) is contained in NO sector. (x,y) is likely out of the map. tempint;            tempint = ((yp1*640+pageoffset)>>3)+(int32_t)_getVideoBase(); !!! Does this code ever get hit? Do something with this!  Draw white arrow 
 * This is ryan's change. SDL requires me to call SDL_UpdateRect() to force
 *  vid updates without a SDL_Flip() call, but there's no such thing in the
 *  DOS version of this program, so text won't show up sometimes without
 *  my update call in Linux.  However, to get a nice shadow effect on some
 *  text, Ken draws a string at an offset and darker, and then on top of it
 *  draws the actual string. Two SDL_UpdateRect() calls in over top of each
 *  other cause flicker, so I have this function here so the shadow can
 *  be drawn with _noupdate, and the actual string is draw with an update.
 For each character in the string. Extra walldist for sprites on sector lines  Collect sectors inside your square first  back  It actually got here, through all the continue's!  Render a sprite on screen. This is used by the Engine but also the Game module when drawing the HUD or the Weapon held by the player !!!If 2D target coordinate do not make sense (left > right)..Does the tile has negative dimensions ? Would be better to optimize out true bounding boxes  If non-masking write, checking for overlapping cases  Allocate palookup buffer Clamp bightness to [0-15]This is only used by drawmapview. They're pointers! - watch how you optimize this thing  maphline  maphline  Need to clip top or left  Need to clip bottom or right This seems to be dead code.clearbuf(visitedSectors,(int32_t)((numsectors+31)>>5),0L); Collect floor sprites to draw This seems to be dead code.visitedSectors[s>>3] |= pow2char[s&7]; Sort sprite list  relative alignment stuff  MUST USE RESTOREFORDRAWROOMS AFTER DRAWING  Can't reverse with uninitialized data  FIX_00085: Optimized Video driver. FPS increases by +20%.
 FCS:
 
 Output the ceiling and floor Z coordinate in the two last parameters for given:
 sectorNumber and worldspace (coordinate X,Y).
 
 If the sector is flat, this is jsut a lookup. But if either the floor/ceiling have
 a slope it requires more calculation
 
 If the sector has a slopped ceiling or a slopped floor then it needs more calculation.
 FCS:
 Search for ???
 Put correct loop at beginning  end of engine.c ... 
 * "Build Engine & Tools" Copyright (c) 1993-1997 Ken Silverman
 * Ken Silverman's official web site: "http://www.advsys.net/ken"
 * See the included license file "BUILDLIC.TXT" for license info.
 * This file has been modified from Ken Silverman's original release
  SUPERBUILD define is in engine.h ...  Warning: This depends on MAXYSAVES & MAXYDIM!  used to be static. --ryan.  used to be static. --ryan.  used to be static. --ryan.  Textured Map variables 
 * !!! used to be static. If we ever put the original setgamemode() back, this
 * !!! can be made static again.  --ryan.
  This is the structure emitted for each wall that is potentially visible. A stack of those is populated when the sectors are scanned.Camera space coordinates of the wall endpoints. Access with vector_index_e.The index of the sector this wall belongs to in the map database.The index of the wall in the map database.Screen space coordinate of the wall endpoints. Access with screenSpaceCoo_index_e. Potentially Visible walls are stored in this stack.xb1 and xb2 seems to be storing the column of the wall endpointyb1 and yb2 store the Y distance from the camera.static int32_t xb1[MAXWALLSB], yb1[MAXWALLSB], xb2[MAXWALLSB], yb2[MAXWALLSB];
//rx1,rx2,ry1,ry2 stores the cameraspace wall endpoints coordinates.
static int32_t rx1[MAXWALLSB], ry1[MAXWALLSB], rx2[MAXWALLSB], ry2[MAXWALLSB];
static short thesector[MAXWALLSB], thewall[MAXWALLSB];
 bunchWallsList contains the list of walls in a bunch.FCS: (up-most pixel on column x that can still be drawn to)FCS: (down-most pixel +1 on column x that can still be drawn to) used to be static. --ryan. FCS: Those two variables are using during portal flooding: sectorBorder is the stack and sectorbordercnt is the stack counter. There is no really point to have this on the heap. That would have been better on the stack.static short sectorborder[256], sectorbordercnt;FCS: Moved this on the stackFCS: Num walls to potentially render.FCS: Number of colums to draw. ALWAYS set to the screen dimension width. search input   search output  Ken did this Ken did this krecip
 FCS:
 Scan through sectors using portals (a portal is wall with a nextsector attribute >= 0).
 Flood is prevented if a portal does not face the POV.
 The stack storing sectors to visit.Add every script in the current sector as potentially visible.Mark the current sector bit as "visited" in the bitvector In camera space the center is the player. Tranform the 2 Wall endpoints (x,y) from worldspace to camera space. After that we have two vectors starting from the camera and going to the endpoints (x1,y1) and (x2,y2). If this is a portal...If this portal has not been visited yet.Cross product -> Z component Using cross product, determine if the portal is facing us or not. If it is: Add it to the stack and bump the stack counter. This line is equivalent to tempint < 0x40000 ??? What is this test ?? How acute the angle is ?(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) is the squared length of the wall ??? What is this test ?? How acute the angle is ? Rotate the wall endpoints vectors according to the player orientation. This is a regular rotation matrix using [29.3] fixed point.If this is the first endpoint of the bunch, rotate: This is a standard cos sin 2D rotation matrix projectionIf this is NOT the first endpoint, Save the coordinate for next loop. Rotate: This is a standard cos sin 2D rotation matrix projection Equivalent of a near plane clipping ? If wall's NOT facing you  The wall is still not eligible for rendition: Let's do some more Frustrum culling !!Project the point onto screen and see in which column it belongs. Fix for SIGNED divide  Fix for SIGNED divide  Made it all the way! Time to add this wall information to the stack of wall potentially visible.Save the camera space wall endpoints coordinate (camera origin at player location + rotated according to player orientation).FCS: TODO rename this p2[] to bunchList[] or something like that. This name is an abomination     DONE, p2 is now called "bunchWallsList".Break down the list of walls for this sector into bunchs. Since a bunch is a continuously visible list of wall: A sector can generate many bunches. Create an entry in the bunch listMark the end of the bunch wall list.For each bunch, find the last wall and cache it in bunchlast. do this until the stack of sectors to visit if empty.
 FCS:
    
 Goal : ????
 param 1: Z is the wallID in the list of potentially visible walls.
 param 2: Only used to lookup the xrepeat attribute of the wall.
 
 lwall calculation Let's use some of the camera space wall coordinate now.X screenspce column of point Z.If the wall is less than 4 column wide.If the wall is less than 2 columns wide.The wall is 1 column wide. renders non-parallaxed ceilings. --ryan. Check the tile dimension are valid. renders non-parallaxed floors. --ryan. Retrieve the sector objectRetrieve the floor palette.We are UNDER the floor: Do NOT render anything.Retrive the floor texture.Lock the floor textureThis tile has unvalid dimensions ( negative)If this is an animated texture: Animate it.If the texture is not in RAM: Load it !!Check where is the texture in RAMRetrieve the shade of the sector (illumination level).Setup the drawing routine paramters
 * renders walls and parallaxed skies/floors. Look at parascan() for the
 *  higher level of parallaxing.
 *
 *    x1 == offset of leftmost pixel of wall. 0 is left of surface.
 *    x2 == offset of rightmost pixel of wall. 0 is left of surface.
 *
 *  apparently, walls are always vertical; there are sloping functions
 *   (!!!) er...elsewhere. Only the sides need be vertical, as the top and
 *   bottom of the polygon will need to be angled as the camera perspective
 *   shifts (user spins in a circle, etc.)
 *
 *  uwal is an array of the upper most pixels, and dwal are the lower most.
 *   This must be a list, as the top and bottom of the polygon are not
 *   necessarily horizontal lines.
 *
 *   So, the screen coordinate of the top left of a wall is specified by
 *   uwal[x1], the bottom left by dwal[x1], the top right by uwal[x2], and
 *   the bottom right by dwal[x2]. Every physical point on the edge of the
 *   wall in between is specified by traversing those arrays, one pixel per
 *   element.
 *
 *  --ryan.
 Starting on the left column of the wall, check the occlusion arrays. this renders masking sprites. See wallscan(). --ryan.  renders parallaxed skies/floors  --ryan.  globalorientation = 0L; if (globalorientation&256) globalyscale = -globalyscale, globalzd = -globalzd; Don't forget to change this in A.ASM also!  Back-face culling  Back-face culling  Relative alignment  JBF: was 2044     16380 Avoid visibility overflow by crossing horizon  inty = intz / (globaluclip>>16)  inty = intz / (globaldclip>>16)  uplc/dplc calculation  draw ceilings  draw floors  DRAW WALLS SECTION!  ceiling  floor  wall Animated 1 for umost  wall  2 for dmost 
                     * If can't see sector beyond, then cancel smost array and just
                     *  store wall!
                      White/1-way wall 
  FCS: Geez one more horrible algorithm to decipher :| :/ :( cry smiley..... 
  Algorithm:

  1.
  Take wall 1 vector [point1,point2] and using two cross products determine if the two endpoints of wall 2 are on the same side of Wall 1 plan.
  If they are then we can determine according to globalposx and globalposy if  wall2 is before or after wall1's plan.
  
  2. Do the same thing again but this time with wall2's plan. Try to find if wall1 is in front of behind wall2's plan.

  Key concept: If a cross-product is equal to 0 this mean they are parallel.

  Return: pvWallID1 in the potentially visible wall list is in front of pvWallID2 (in the same potentially visible list)
It seems we are going to work in Worldspace coordinates.This is part 1Wall 1's vectorThis is a cross-product between Wall 1 vector and the [Wall 1 Point 1-> Wall 2 Point 1] vector  p1(l2) vs. l1 This is a cross-product between Wall 1 vector and the [Wall 1 Point 1-> Wall 2 Point 2] vector  p2(l2) vs. l1 If the vectors a parallel, then the cross-product is zero.wall2's point1 is on wall1's plan. Those two walls are on the same plan.Wall 2's point 2 is on wall1's plan.This XOR just determine if the cross-product have the same sign and hence if both points are on the same side of wall 1 plan.Test if both points of wall2 are on the same side of wall 1 (in front or behind).cross-product have the same sign: Both points of wall2 are on the same side of wall1 : An answer is possible !!Now is time to take into account the camera position and determine which of wall1 or wall2 is seen first. pos vs. l1 Test the cross product sign difference.If (t2^t1) >= 0 then  both cross product had different sign so wall1 is in front of wall2otherwise wall2 is in front of wall1This is part 2Do it again but this time will wall2's plan.Wall 2's vector p1(l1) vs. l2  p2(l1) vs. l2  pos vs. l2 FCS: No wall is in front of the other's plan: This means they are crossing.Return 1 if bunch firstBunchID is in from of bunch secondBunchID.Bunch 1 left side is completely on the right of bunch2's right in screenspace: They do not overlap.Bunch 2 left side is completely on the right of bunch 1 right side: They do not overlap.Get the last wall in the bunch2.Get the last wall in the bunch.#include "keyboard.h"void WriteLastPaletteToFile(void);void WriteTranslucToFile(void);  
      FCS: Draw every walls in Front to Back Order.
Ceiling and Floor height at the player position. When visualizing the rendering process, part of the screen are not updated: In order to avoid the "ghost effect", we clear the framebuffer to black.CODE EXPLORATION
    if( KB_KeyDown[0x39]){ // 0x39 = SPACE
        //CODE EXPLORATION
        WriteLastPaletteToFile();
        WriteTranslucToFile();
    }        
    pixelsAllowed = pixelRenderable;printf("%d\n",pixelsAllowed); FCS: What was the point of having those values as parameters of this function....if it is to overwrite the values with the gloval variables ?!?!?FCS: Mask and keep only 11 bits of angle value.Clear the bit vector that keep track of what sector has been flooded in.Clear the occlusion array.NumHits is the number of column to draw.Num walls to potentially render. Even if the player leaves the map, the engine will keep on rendering from the last visited sector. Save it.Seem the player has left the map since updatesector cannot locate him -> Restore to the last known sector.Update the ceiling and floor Z coordinate for the player's 2D position.Build the list of potentially visible wall in to "bunches". scansector has generated the bunches, it is now time to see which ones to render. numhits is the number of column of pixels to draw: (if the screen is 320x200 then numhits starts at 200). Due to rounding error, not all columns may be drawn so an additional stop condition is here: When every bunches have been tested for rendition. tempbuf is used to mark which bunches have been elected as "closest". if tempbug[x] == 1 then it should be skipped. Almost works, but not quite :(  Double-check Draw every solid walls with ceiling/floor in the bunch "closest"Since we just rendered a bunch, lower the current stack element so we can treat the next item...and move the bunch at the top of the stack so we won't iterate on it again...Tile dimensions are invalid FIX_00058: Save/load game crash in both single and multiplayer We have to reset those arrays since the same arrays are used as temporary space in the compilecons() function like "label = (uint8_t  *)&sprite[0];" to save memory space I guess. Not reseting the array will leave dumps fooling the function saveplayer(), eg at if(actorscrptr[PN] == 0) where PN is sprite[i].picnum was beyong actorscrptr[] size) Must be after loading sectors, etc!  FIX_00009: Show map CRC and GRP file version of each player in case of Out Of Synchj = (i-64)*(i-64);CODE EXPLORATIONWritePaletteToFile(palette,"palette.tga",16, 16);CODE EXPLORATIONprintf("Num palettes lookup: %d.\n",numpalookups);Transluctent pallete is 65KB.kread(fil,transluc,65536); video driver specific.  Assume npoints=4 with polygon on &rx1,&ry1 FCS This is horrible to read: I hate you. Auto window size scaling  = scale(xdimen,yxaspect,320); 
             * If not clipping to startmosts, & auto-scaling on, as a
             *  hard-coded bonus, scale to full screen instead
              Don't aspect unscaled perms Taking care of the Y coordinates.Taking care of the X coordinates. back up these before clipping  Don't aspect unscaled perms  vlineasm4 has 256 high limit!  x,y1  x,y1  x,y2  x,y1  x2,y1  if  video driver specific.  if  Front  Front 
 FCS: Return true if the point (x,Y) is inside the sector sectnum.
 Note that a sector is closed (but can be concave) so the answer is always 0 or 1.

 Algorithm: This is an optimized raycasting inside polygon test:
 http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm
 The goal is to follow an ***horizontal*** ray passing by (x,y) and count how many
 wall are being crossed.
 If it is an odd number of time: (x,y) is inside the sector.
 If it is an even nymber of time:(x,y) is outside the sector.
 Quick check if the sector ID is valid. Compare the sign of y1 and y2. If (y1^y2) < 0 : y1 and y2 have different sign bit:  y is between wal->y and wall[wal->point2].y. The goal is to not take into consideration any wall that is totally above or totally under the point [x,y].If (x1^x2) >= 0 x1 and x2 have identic sign bit: x is on the left or the right of both wal->x and wall[wal->point2].x. If (x,y) is totally on the left or on the right, just count x1 (which indicate if we are on on the left or on the right. This is the most complicated case: X is between x1 and x2, we need a fine grained test. We need to know exactly if it is on the left or on the right in order to know if the ray is crossing the wall or not, The sign of the Cross-Product can answer this case :) !Just return the sign. If the position vector cut the sector walls an odd number of timeit is inside. Otherwise (even) it is outside.Retrive pvWall ID.Retrive world wall ID.Retrive sector IDRetrive sector.Retrive next sector. maskwall 
     * x = x1 + (x2-x1)t + (y1-y2)u  ³  x = 160v
     * y = y1 + (y2-y1)t + (x2-x1)u  ³  y = (scrx-160)v
     * z = z1 = z2                   ³  z = posz + (scry-horiz)v
      FIX_00088: crash on maps using a bad palette index (like the end of roch3.map) seem to crash when globalpal > 25 Watch out for divscale overflow  Odd xspans  Odd yspans  sprite  Odd yspans  If wall's NOT facing you  Fix for SIGNED divide  Fix for SIGNED divide  Odd yspans  INTERSECTION!  Fix for SIGNED divide  sprite  Rotate center point  Get top-left corner  Get other 3 corners  Put all points on same z  Calculate globals for hline texture mapping function  If ceilsprite is above you, reverse order of points  Clip polygon in 3-space  Clip edge 1  Clip edge 2  Clip edge 3  Clip edge 4  Project onto screen  Get uwall arrays  Get dwall arrays  Additional uwall/dwall clipping goes here  if (spritewallfront(tspr,thewall[j]) == 0)  sprite  Draw it! 
     FCS: Draw every transparent sprites in Back To Front Order. Also draw decals on the walls...
  int32_t zs, zp; Copy sprite address in a sprite proxy structure (pointers are easier to re-arrange than structs).Generate screenspace coordinate (X column and Y distance).Translate and rotate the sprite in Camera space coordinate. Delete face sprite if on wrong side! Move the sprite at the end of the array and decrease array length.FCS: Bubble sort ?! REally ?!?!? Sort sprite list  While BOTH > 0  Check to see if any sprites behind the masked wall...  remove holes in sprite list  finally safe to draw the masked wall  Init doubly-linked sprite sector lists  Init doubly-linked sprite status lists  list full  list full  p1 to p2 is a line segment  p1 towards p2 is a ray 
                 * These lines get the 2 points of the rotated sprite
                 * Given: (x1, y1) starts out as the center point
                  back side of 1-way sprite  search points CCW  search points CW if not searched all the way around  !!! ugh...move this var into clipmove as a parameter, and update build2.txt!  Extra walldist for sprites on sector lines  CLIPMASK0 = 0x00010001  CLIPMASK1 = 0x01000040  If wall's not facing you  Add 2 boxes at endpoints 
                     * These lines get the 2 points of the rotated sprite
                     * Given: (x1, y1) starts out as the center point
                      Front  Side blocker     int32_t dasprclipmask;    dasprclipmask = (cliptype>>16); Find closest point on wall (dax, day) to (*x, *y) 
 FCS:  x and y are the new position of the entity that has just moved:
 lastKnownSector is an hint (the last known sectorID of the entity).

 Thanks to the "hint", the algorithm check:
 1. Is (x,y) inside sectors[sectnum].
 2. Flood in sectnum portal and check again if (x,y) is inside.
 3. Do a linear search on sectors[sectnum] from 0 to numSectors.

 Note: Inside uses cross_product and return as soon as the point switch
 from one side to the other.
 First check the last sector where (old_x,old_y) was before being updated to (x,y)We found it and (x,y) is still in the same sector: nothing to update ! Seems (x,y) moved into an other sector....hopefully one connected via a portal. Let's flood in each portal.Damn that is a BIG move, still cannot find which sector (x,y) belongs to. Let's search via linear search. (x,y) is contained in NO sector. (x,y) is likely out of the map. tempint;            tempint = ((yp1*640+pageoffset)>>3)+(int32_t)_getVideoBase(); !!! Does this code ever get hit? Do something with this!  Draw white arrow 
 * This is ryan's change. SDL requires me to call SDL_UpdateRect() to force
 *  vid updates without a SDL_Flip() call, but there's no such thing in the
 *  DOS version of this program, so text won't show up sometimes without
 *  my update call in Linux.  However, to get a nice shadow effect on some
 *  text, Ken draws a string at an offset and darker, and then on top of it
 *  draws the actual string. Two SDL_UpdateRect() calls in over top of each
 *  other cause flicker, so I have this function here so the shadow can
 *  be drawn with _noupdate, and the actual string is draw with an update.
 For each character in the string. Extra walldist for sprites on sector lines  Collect sectors inside your square first  back  It actually got here, through all the continue's!  Render a sprite on screen. This is used by the Engine but also the Game module when drawing the HUD or the Weapon held by the player !!!If 2D target coordinate do not make sense (left > right)..Does the tile has negative dimensions ? Would be better to optimize out true bounding boxes  If non-masking write, checking for overlapping cases  Allocate palookup buffer Clamp bightness to [0-15]This is only used by drawmapview. They're pointers! - watch how you optimize this thing  maphline  maphline  Need to clip top or left  Need to clip bottom or right This seems to be dead code.clearbuf(visitedSectors,(int32_t)((numsectors+31)>>5),0L); Collect floor sprites to draw This seems to be dead code.visitedSectors[s>>3] |= pow2char[s&7]; Sort sprite list  relative alignment stuff  MUST USE RESTOREFORDRAWROOMS AFTER DRAWING  Can't reverse with uninitialized data  FIX_00085: Optimized Video driver. FPS increases by +20%.
 FCS:
 
 Output the ceiling and floor Z coordinate in the two last parameters for given:
 sectorNumber and worldspace (coordinate X,Y).
 
 If the sector is flat, this is jsut a lookup. But if either the floor/ceiling have
 a slope it requires more calculation
 
 If the sector has a slopped ceiling or a slopped floor then it needs more calculation.
 FCS:
 Search for ???
 Put correct loop at beginning  end of engine.c ... 