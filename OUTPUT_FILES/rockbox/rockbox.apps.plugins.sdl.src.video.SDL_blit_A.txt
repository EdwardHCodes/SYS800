
    SDL - Simple DirectMedia Layer
    Copyright (C) 1997-2012 Sam Lantinga

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Sam Lantinga
    slouken@libsdl.org

  In Visual C, VC6 has mmintrin.h in the "Processor Pack" add-on.
   Checking if _mm_free is #defined in malloc.h is is the only way to
   determine if the Processor Pack is installed, as far as I can tell.
 forced MMX to 0...it breaks on most compilers now.  --ryan.  Visual Studio > VC6 always has mmintrin.h  SDL_ASSEMBLY_ROUTINES  Function to check the CPU flags  Functions to perform alpha blended blitting  N->1 blending with per-surface alpha  Pack RGB into 8bit pixel  N->1 blending with pixel alpha  FIXME: fix alpha bit field expansion here too?  Pack RGB into 8bit pixel  colorkeyed N->1 blending with per-surface alpha  Pack RGB into 8bit pixel  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  alpha128 mask  alpha128 mask -> mm4  !alpha128 mask  !alpha128 mask -> mm3  dst alpha mask  dst alpha mask | dst alpha mask -> mm7  2 x dst -> mm2(ARGBARGB)  2 x dst -> mm6(ARGBARGB)  2 x src -> mm1(ARGBARGB)  2 x src -> mm5(ARGBARGB)  dst & mask -> mm6  src & mask -> mm5  mm6 + mm5 -> mm5  src & dst -> mm2  mm5 >> 1 -> mm5  mm2 & !mask -> mm2  mm5 + mm2 -> mm2  mm7(full alpha) | mm2 -> mm2  mm2 -> 2 x dst pixels  fast RGB888->(A)RGB888 blending with surface alpha  only call a128 version when R,G,B occupy lower bits  0 -> mm5  form the alpha mult  0000000A -> mm4  00000A0A -> mm4  0A0A0A0A -> mm4  00000FFF -> mm0  00FFFFFF -> mm0  0A0A0A0A -> mm4, minus 1 chan  at this point mm4 can be 000A0A0A or 0A0A0A00 or another combo  dst alpha mask  dst alpha mask | dst alpha mask -> mm7  One Pixel Blend  src(ARGB) -> mm1 (0000ARGB) dst(ARGB) -> mm2 (0000ARGB) 0A0R0G0B -> mm1(src)  0A0R0G0B -> mm2(dst)  src - dst -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1  mm1 + mm2(dst) -> mm2  ARGBARGB -> mm2  mm7(full alpha) | mm2 -> mm2  mm2 -> pixel  Two Pixels Blend  2 x src -> mm0(ARGBARGB) 2 x dst -> mm2(ARGBARGB)  2 x src -> mm1(ARGBARGB)  2 x dst -> mm6(ARGBARGB)  low - 0A0R0G0B -> mm0(src1)  high - 0A0R0G0B -> mm1(src2)  low - 0A0R0G0B -> mm2(dst1)  high - 0A0R0G0B -> mm6(dst2)  src1 - dst1 -> mm0  mm0 * alpha -> mm0  mm0 >> 8 -> mm1  mm0 + mm2(dst1) -> mm2  src2 - dst2 -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1  mm1 + mm6(dst2) -> mm6  ARGBARGB -> mm2  mm7(dst alpha) | mm2 -> mm2  mm2 -> 2 x pixel  fast ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm6  form multiplication mask  0000F000 -> mm7  FF000000 -> mm7  FFFFFFFF -> mm0  FFFFFFFF -> mm3 (for later)  00FFFFFF -> mm7 (mult mask)  form channel masks  00FFFFFF -> mm0  00000FFF -> mm0 (channel mask)  0000FFFF -> mm3  0000F000 -> mm3 (~channel mask)  get alpha channel shift  Ashift -> mm5  FIXME: Here we special-case opaque alpha since the
			compositioning used (>>8 instead of /255) doesn't handle
			it correctly. Also special-case alpha=0 for speed?
			Benchmark this!  do nothing  opaque alpha -- copy RGB, keep dst alpha  using MMX here to free up regular registers for other things  src(ARGB) -> mm1 (0000ARGB) dst(ARGB) -> mm2 (0000ARGB) src & chanmask -> mm1  dst & ~chanmask -> mm2  src | dst -> mm2  mm2 -> dst  src(ARGB) -> mm1 (0000ARGB) 0A0R0G0B -> mm1  dst(ARGB) -> mm2 (0000ARGB) 0A0R0G0B -> mm2  0000A000 -> mm4  mm4 >> mm5 -> mm4 (0000000A)  00000A0A -> mm4  0A0A0A0A -> mm4  000A0A0A -> mm4, preserve dst alpha on add  blend  src - dst -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1(000R0G0B)  mm1 + mm2(dst) -> mm2  0000ARGB -> mm2  mm2 -> dst  End GCC_ASMBLIT  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  alpha128 mask -> hmask  !alpha128 mask -> lmask  dst alpha mask -> dsta  2 x dst -> dst1(ARGBARGB)  2 x dst -> dst2(ARGBARGB)  2 x src -> src1(ARGBARGB)  2 x src -> src2(ARGBARGB)  dst & mask -> dst2  src & mask -> src2  dst2 + src2 -> src2  src2 >> 1 -> src2  src & dst -> dst1  dst1 & !mask -> dst1  src2 + dst1 -> dst1  dsta(full alpha) | dst1 -> dst1  dst1 -> 2 x dst pixels  fast RGB888->(A)RGB888 blending with surface alpha  only call a128 version when R,G,B occupy lower bits  0 -> mm_zero  form the alpha mult  0000AAAA -> mm_alpha, minus 1 chan  0A0A0A0A -> mm_alpha, minus 1 chan  at this point mm_alpha can be 000A0A0A or 0A0A0A00 or another combo  dst alpha mask -> dsta  One Pixel Blend  src(ARGB) -> src2 (0000ARGB) 0A0R0G0B -> src2  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  src2 - dst2 -> src2  src2 * alpha -> src2  src2 >> 8 -> src2  src2 + dst1 -> dst1  0000ARGB -> dst1  dsta | dst1 -> dst1  dst1 -> pixel  Two Pixels Blend  2 x src -> src1(ARGBARGB) 2 x src -> src2(ARGBARGB)  low - 0A0R0G0B -> src1  high - 0A0R0G0B -> src2  2 x dst -> dst1(ARGBARGB)  2 x dst -> dst2(ARGBARGB)  low - 0A0R0G0B -> dst1  high - 0A0R0G0B -> dst2  src1 - dst1 -> src1  src1 * alpha -> src1  src1 >> 8 -> src1  src1 + dst1(dst1) -> dst1  src2 - dst2 -> src2  src2 * alpha -> src2  src2 >> 8 -> src2  src2 + dst2(dst2) -> dst2  0A0R0G0B(res1), 0A0R0G0B(res2) -> dst1(ARGBARGB)  dsta | dst1 -> dst1  dst1 -> 2 x pixel  fast ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm_zero  dst alpha mask -> dmask  do nothing  opaque alpha -- copy RGB, keep dst alpha  src(ARGB) -> src1 (0000ARGB) 0A0R0G0B -> src1  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  alpha -> mm_alpha (0000000A)  mm_alpha >> ashift -> mm_alpha(0000000A)  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  000A0A0A -> mm_alpha, preserve dst alpha on add  blend  src1 - dst1 -> src1  (src1 - dst1) * alpha -> src1  src1 >> 8 -> src1(000R0G0B)  src1 + dst1 -> dst1(0A0R0G0B)  0000ARGB -> dst1  dst1 -> pixel  End MSVC_ASMBLIT  GCC_ASMBLIT, MSVC_ASMBLIT  the permuation vector that takes the high bytes out of all the appropriate shorts 
    (vector unsigned char)(
        0x00, 0x10, 0x02, 0x12,
        0x04, 0x14, 0x06, 0x16,
        0x08, 0x18, 0x0A, 0x1A,
        0x0C, 0x1C, 0x0E, 0x1E );
 vtemp1 contains source AAGGAAGGAAGGAAGG  vtemp2 contains source RRBBRRBBRRBBRRBB  valpha2 is 255-alpha  vtemp3 contains dest AAGGAAGGAAGGAAGG  vtemp4 contains dest RRBBRRBBRRBBRRBB  add source and dest  vtemp1 = (vtemp1 + 1) + ((vtemp1 + 1) >> 8)  vtemp2 = (vtemp2 + 1) + ((vtemp2 + 1) >> 8)  (>>8) and get ARGBARGBARGBARGB  Calculate the permute vector used for 32->32 swizzling 
     * We have to assume that the bits that aren't used by other
     *  colors is alpha, and it's one complete byte, since some formats
     *  leave alpha with a zero mask, but we should still swizzle the bits.
      ARGB  Use zero for alpha if either surface doesn't have alpha  
        0x10 - 0x1f is the alpha
        0x00 - 0x0e evens are the red
        0x01 - 0x0f odds are zero
    
        0x00 - 0x0f is ARxx ARxx ARxx ARxx
        0x11 - 0x0f odds are blue
    
        0x00 - 0x0f is ARxB ARxB ARxB ARxB
        0x10 - 0x0e evens are green
     Load 8 pixels from src as ARGB  Load 8 pixels from dst as XRGB  Alpha blend 8 pixels as ARGB  Convert 8 pixels to 565  Store 8 pixels  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  vsel is set for items that match the key  permute to source format  d = *dstp  set the alpha channel to full on  mask out color key  permute to dest format  *dstp = res  vsrcPermute  vdstPermute  s = *srcp  d = *dstp  set the alpha to the dest alpha  *dstp = res  fast ARGB888->(A)RGB888 blending with pixel alpha  s = *srcp  d = *dstp  set the alpha to the dest alpha  *dstp = res  XXX : 6  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  d = *dstp  set the alpha channel to full on  *dstp = res  fast RGB888->(A)RGB888 blending  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  d = *dstp  set the alpha channel to full on  *dstp = res  SDL_ALTIVEC_BLITTERS  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  fast RGB888->(A)RGB888 blending with surface alpha  One Pixel Blend  Two Pixels Blend  fast ARGB888->(A)RGB888 blending with pixel alpha  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * take out the middle component (green), and process
		     * the other two in parallel. One multiply less.
		      fast (as in MMX with prefetch) ARGB888->(A)RGB888 blending with pixel alpha  make mm6 all zeros.  Make a mask to preserve the alpha.  0000F000 -> mm7  FF000000 -> mm7  FFFFFFFF -> mm4  FFFFFFFF -> mm3 (for later)  00FFFFFF -> mm7 (mult mask)  form channel masks  00FFFFFF -> mm4  00000FFF -> mm4 (channel mask)  0000FFFF -> mm3  0000F000 -> mm3 (~channel mask)  get alpha channel shift  Ashift -> mm5  nothing  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this!  do nothing  opaque alpha -- copy RGB, keep dst alpha  using MMX here to free up regular registers for other things  src(ARGB) -> mm0 (0000ARGB) dst(ARGB) -> mm1 (0000ARGB) src & chanmask -> mm0  dst & ~chanmask -> mm2  src | dst -> mm1  mm1 -> dst  load in the source, and dst.  mm0(s) = 0 0 0 0 | As Rs Gs Bs  mm1(d) = 0 0 0 0 | Ad Rd Gd Bd  Move the src alpha into mm2  if supporting pshufw "pshufw     $0x55, %%mm0, %%mm2\n"  mm2 = 0 As 0 As |  0 As  0  As "psrlw     $8, %%mm2\n"  else:  mm2 = 0 0 0 0 | 0  0  0  As  mm2 = 0 0 0 0 |  0 As  0  As  mm2 = 0 As 0 As |  0 As  0  As  to preserve dest alpha  move the colors into words.  mm0 = 0 As 0 Rs | 0 Gs 0 Bs  mm0 = 0 Ad 0 Rd | 0 Gd 0 Bd  src - dst  mm0 = As-Ad Rs-Rd | Gs-Gd  Bs-Bd  A * (src-dst)  mm0 = 0*As-d As*Rs-d | As*Gs-d  As*Bs-d  mm0 = 0>>8 Rc>>8 | Gc>>8  Bc>>8  mm0 = 0+Ad Rc+Rd | Gc+Gd  Bc+Bd  mm0 =             | Ac Rc Gc Bc  result in mm0  End GCC_ASMBLIT fast (as in MMX with prefetch) ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm_zero  dst alpha mask -> dmask  do nothing  copy RGB, keep dst alpha  src(ARGB) -> src1 (0000ARGB) 0A0R0G0B -> src1  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  alpha -> mm_alpha (0000000A)  mm_alpha >> ashift -> mm_alpha(0000000A)  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  000A0A0A -> mm_alpha, preserve dst alpha on add  blend  src - dst -> src1  (src - dst) * alpha -> src1  src1 >> 8 -> src1(000R0G0B)  src1 + dst1(dst) -> dst1(0A0R0G0B)  0000ARGB -> dst1  dst1 -> pixel  End MSVC_ASMBLIT  GCC_ASMBLIT, MSVC_ASMBLIT  16bpp special case for per-surface alpha=50%: blend 2 pixels in parallel  blend a single 16 bit pixel at 50%  blend two 16 bit pixels at 50% 
			 * Source and destination not aligned, pipeline it.
			 * This is mostly a win for big blits but no loss for
			 * small ones
			  handle odd destination  srcp is now 32-bit aligned  bootstrap pipeline with first halfword  final pixel if any  source and destination are aligned  first odd pixel?  srcp and dstp are now 32-bit aligned  last odd pixel?  fast RGB565->RGB565 blending with surface alpha  downscale alpha to 5 bits  cut alpha to get the exact same behaviour  downscale alpha to 5 bits  alpha(0000000A) -> mm0  00000A0A -> mm0  0A0A0A0A -> mm0  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 565 color channel masks  MASKGREEN -> mm4  MASKBLUE -> mm7 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> mm2  4 dst pixels -> mm3  red -- does not need a mask since the right shift clears
				   the uninteresting bits  src -> mm5  dst -> mm6  mm5 >> 11 -> mm5 [000r 000r 000r 000r]  mm6 >> 11 -> mm6 [000r 000r 000r 000r]  blend  src - dst -> mm5  mm5 * alpha -> mm5  alpha used is actually 11 bits
				   11 + 5 = 16 bits, so the sign bits are lost  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 << 11 -> mm6  save new reds in dsts  green -- process the bits in place  src -> mm5  dst -> mm6  src & MASKGREEN -> mm5  dst & MASKGREEN -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 11 - 16 = 6 bits, so all the lower uninteresting
				   bits are gone and the sign bits present  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  save new greens in dsts  blue  src -> mm5  dst -> mm6  src & MASKBLUE -> mm5[000b 000b 000b 000b]  dst & MASKBLUE -> mm6[000b 000b 000b 000b]  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 5 = 16 bits, so the sign bits are lost and
				   the interesting bits will need to be MASKed  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKBLUE -> mm6[000b 000b 000b 000b]  save new blues in dsts  mm1 -> 4 dst pixels  fast RGB555->RGB555 blending with surface alpha  downscale alpha to 5 bits  cut alpha to get the exact same behaviour  downscale alpha to 5 bits  alpha(0000000A) -> mm0  00000A0A -> mm0  0A0A0A0A -> mm0  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 555 color channel masks  MASKGREEN -> mm4  MASKBLUE -> mm7 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> mm2  4 dst pixels -> mm3  red -- process the bits in place  turn MASKGREEN into MASKRED  by reusing the GREEN mask we free up another mmx
					   register to accumulate the result  src -> mm5  dst -> mm6  src & MASKRED -> mm5  dst & MASKRED -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 15 - 16 = 10 bits, uninteresting bits will be
				   cleared by a MASK below  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKRED -> mm6  turn MASKRED back into MASKGREEN  save new reds in dsts  green -- process the bits in place  src -> mm5  dst -> mm6  src & MASKGREEN -> mm5  dst & MASKGREEN -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 10 - 16 = 5 bits,  so all the lower uninteresting
				   bits are gone and the sign bits present  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  save new greens in dsts  blue  src -> mm5  dst -> mm6  src & MASKBLUE -> mm5[000b 000b 000b 000b]  dst & MASKBLUE -> mm6[000b 000b 000b 000b]  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 5 = 16 bits, so the sign bits are lost and
				   the interesting bits will need to be MASKed  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKBLUE -> mm6[000b 000b 000b 000b]  save new blues in dsts  mm1 -> 4 dst pixels  End GCC_ASMBLIT  fast RGB565->RGB565 blending with surface alpha  cut alpha to get the exact same behaviour  0000000A -> mm_alpha  downscale alpha to 5 bits  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 565 color channel masks  MASKGREEN -> gmask  MASKBLUE -> bmask 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> src1  4 dst pixels -> dst1  red  src2 >> 11 -> src2 [000r 000r 000r 000r]  dst2 >> 11 -> dst2 [000r 000r 000r 000r]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 << 11 -> dst2  RED -> mm_res  green -- process the bits in place  src & MASKGREEN -> src2  dst & MASKGREEN -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  RED | GREEN -> mm_res  blue  src & MASKBLUE -> src2[000b 000b 000b 000b]  dst & MASKBLUE -> dst2[000b 000b 000b 000b]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 & MASKBLUE -> dst2  RED | GREEN | BLUE -> mm_res  mm_res -> 4 dst pixels  fast RGB555->RGB555 blending with surface alpha  cut alpha to get the exact same behaviour  0000000A -> mm_alpha  downscale alpha to 5 bits  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 555 color channel masks  MASKRED -> rmask  MASKGREEN -> gmask  MASKBLUE -> bmask 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> src1  4 dst pixels -> dst1  red -- process the bits in place  src & MASKRED -> src2  dst & MASKRED -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  dst2 & MASKRED -> dst2  RED -> mm_res  green -- process the bits in place  src & MASKGREEN -> src2  dst & MASKGREEN -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  RED | GREEN -> mm_res  blue  src -> src2  src & MASKBLUE -> src2[000b 000b 000b 000b]  dst -> dst2  dst & MASKBLUE -> dst2[000b 000b 000b 000b]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 & MASKBLUE -> dst2  RED | GREEN | BLUE -> mm_res  mm_res -> 4 dst pixels  GCC_ASMBLIT, MSVC_ASMBLIT  fast RGB565->RGB565 blending with surface alpha  downscale alpha to 5 bits 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  fast RGB555->RGB555 blending with surface alpha  downscale alpha to 5 bits  downscale alpha to 5 bits 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  fast ARGB8888->RGB565 blending with pixel alpha  downscale alpha to 5 bits  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * convert source and destination to G0RAB65565
		     * and blend all components at the same time
		      fast ARGB8888->RGB555 blending with pixel alpha  downscale alpha to 5 bits  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * convert source and destination to G0RAB65565
		     * and blend all components at the same time
		      General (slow) N->N blending with per-surface alpha  General (slow) colorkeyed N->N blending with per-surface alpha  General (slow) N->N blending with pixel alpha  Set up some basic variables  FIXME: for 8bpp source alpha, this doesn't get opaque values
	   quite right. for <8bpp source alpha, it gets them very wrong
	   (check all macros!)
	   It is unclear whether there is a good general solution that doesn't
	   need a branch (or a divide).  Per-surface alpha blits  Per-pixel alpha blits 
    SDL - Simple DirectMedia Layer
    Copyright (C) 1997-2012 Sam Lantinga

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Sam Lantinga
    slouken@libsdl.org

  In Visual C, VC6 has mmintrin.h in the "Processor Pack" add-on.
   Checking if _mm_free is #defined in malloc.h is is the only way to
   determine if the Processor Pack is installed, as far as I can tell.
 forced MMX to 0...it breaks on most compilers now.  --ryan.  Visual Studio > VC6 always has mmintrin.h  SDL_ASSEMBLY_ROUTINES  Function to check the CPU flags  Functions to perform alpha blended blitting  N->1 blending with per-surface alpha  Pack RGB into 8bit pixel  N->1 blending with pixel alpha  FIXME: fix alpha bit field expansion here too?  Pack RGB into 8bit pixel  colorkeyed N->1 blending with per-surface alpha  Pack RGB into 8bit pixel  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  alpha128 mask  alpha128 mask -> mm4  !alpha128 mask  !alpha128 mask -> mm3  dst alpha mask  dst alpha mask | dst alpha mask -> mm7  2 x dst -> mm2(ARGBARGB)  2 x dst -> mm6(ARGBARGB)  2 x src -> mm1(ARGBARGB)  2 x src -> mm5(ARGBARGB)  dst & mask -> mm6  src & mask -> mm5  mm6 + mm5 -> mm5  src & dst -> mm2  mm5 >> 1 -> mm5  mm2 & !mask -> mm2  mm5 + mm2 -> mm2  mm7(full alpha) | mm2 -> mm2  mm2 -> 2 x dst pixels  fast RGB888->(A)RGB888 blending with surface alpha  only call a128 version when R,G,B occupy lower bits  0 -> mm5  form the alpha mult  0000000A -> mm4  00000A0A -> mm4  0A0A0A0A -> mm4  00000FFF -> mm0  00FFFFFF -> mm0  0A0A0A0A -> mm4, minus 1 chan  at this point mm4 can be 000A0A0A or 0A0A0A00 or another combo  dst alpha mask  dst alpha mask | dst alpha mask -> mm7  One Pixel Blend  src(ARGB) -> mm1 (0000ARGB) dst(ARGB) -> mm2 (0000ARGB) 0A0R0G0B -> mm1(src)  0A0R0G0B -> mm2(dst)  src - dst -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1  mm1 + mm2(dst) -> mm2  ARGBARGB -> mm2  mm7(full alpha) | mm2 -> mm2  mm2 -> pixel  Two Pixels Blend  2 x src -> mm0(ARGBARGB) 2 x dst -> mm2(ARGBARGB)  2 x src -> mm1(ARGBARGB)  2 x dst -> mm6(ARGBARGB)  low - 0A0R0G0B -> mm0(src1)  high - 0A0R0G0B -> mm1(src2)  low - 0A0R0G0B -> mm2(dst1)  high - 0A0R0G0B -> mm6(dst2)  src1 - dst1 -> mm0  mm0 * alpha -> mm0  mm0 >> 8 -> mm1  mm0 + mm2(dst1) -> mm2  src2 - dst2 -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1  mm1 + mm6(dst2) -> mm6  ARGBARGB -> mm2  mm7(dst alpha) | mm2 -> mm2  mm2 -> 2 x pixel  fast ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm6  form multiplication mask  0000F000 -> mm7  FF000000 -> mm7  FFFFFFFF -> mm0  FFFFFFFF -> mm3 (for later)  00FFFFFF -> mm7 (mult mask)  form channel masks  00FFFFFF -> mm0  00000FFF -> mm0 (channel mask)  0000FFFF -> mm3  0000F000 -> mm3 (~channel mask)  get alpha channel shift  Ashift -> mm5  FIXME: Here we special-case opaque alpha since the
			compositioning used (>>8 instead of /255) doesn't handle
			it correctly. Also special-case alpha=0 for speed?
			Benchmark this!  do nothing  opaque alpha -- copy RGB, keep dst alpha  using MMX here to free up regular registers for other things  src(ARGB) -> mm1 (0000ARGB) dst(ARGB) -> mm2 (0000ARGB) src & chanmask -> mm1  dst & ~chanmask -> mm2  src | dst -> mm2  mm2 -> dst  src(ARGB) -> mm1 (0000ARGB) 0A0R0G0B -> mm1  dst(ARGB) -> mm2 (0000ARGB) 0A0R0G0B -> mm2  0000A000 -> mm4  mm4 >> mm5 -> mm4 (0000000A)  00000A0A -> mm4  0A0A0A0A -> mm4  000A0A0A -> mm4, preserve dst alpha on add  blend  src - dst -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1(000R0G0B)  mm1 + mm2(dst) -> mm2  0000ARGB -> mm2  mm2 -> dst  End GCC_ASMBLIT  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  alpha128 mask -> hmask  !alpha128 mask -> lmask  dst alpha mask -> dsta  2 x dst -> dst1(ARGBARGB)  2 x dst -> dst2(ARGBARGB)  2 x src -> src1(ARGBARGB)  2 x src -> src2(ARGBARGB)  dst & mask -> dst2  src & mask -> src2  dst2 + src2 -> src2  src2 >> 1 -> src2  src & dst -> dst1  dst1 & !mask -> dst1  src2 + dst1 -> dst1  dsta(full alpha) | dst1 -> dst1  dst1 -> 2 x dst pixels  fast RGB888->(A)RGB888 blending with surface alpha  only call a128 version when R,G,B occupy lower bits  0 -> mm_zero  form the alpha mult  0000AAAA -> mm_alpha, minus 1 chan  0A0A0A0A -> mm_alpha, minus 1 chan  at this point mm_alpha can be 000A0A0A or 0A0A0A00 or another combo  dst alpha mask -> dsta  One Pixel Blend  src(ARGB) -> src2 (0000ARGB) 0A0R0G0B -> src2  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  src2 - dst2 -> src2  src2 * alpha -> src2  src2 >> 8 -> src2  src2 + dst1 -> dst1  0000ARGB -> dst1  dsta | dst1 -> dst1  dst1 -> pixel  Two Pixels Blend  2 x src -> src1(ARGBARGB) 2 x src -> src2(ARGBARGB)  low - 0A0R0G0B -> src1  high - 0A0R0G0B -> src2  2 x dst -> dst1(ARGBARGB)  2 x dst -> dst2(ARGBARGB)  low - 0A0R0G0B -> dst1  high - 0A0R0G0B -> dst2  src1 - dst1 -> src1  src1 * alpha -> src1  src1 >> 8 -> src1  src1 + dst1(dst1) -> dst1  src2 - dst2 -> src2  src2 * alpha -> src2  src2 >> 8 -> src2  src2 + dst2(dst2) -> dst2  0A0R0G0B(res1), 0A0R0G0B(res2) -> dst1(ARGBARGB)  dsta | dst1 -> dst1  dst1 -> 2 x pixel  fast ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm_zero  dst alpha mask -> dmask  do nothing  opaque alpha -- copy RGB, keep dst alpha  src(ARGB) -> src1 (0000ARGB) 0A0R0G0B -> src1  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  alpha -> mm_alpha (0000000A)  mm_alpha >> ashift -> mm_alpha(0000000A)  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  000A0A0A -> mm_alpha, preserve dst alpha on add  blend  src1 - dst1 -> src1  (src1 - dst1) * alpha -> src1  src1 >> 8 -> src1(000R0G0B)  src1 + dst1 -> dst1(0A0R0G0B)  0000ARGB -> dst1  dst1 -> pixel  End MSVC_ASMBLIT  GCC_ASMBLIT, MSVC_ASMBLIT  the permuation vector that takes the high bytes out of all the appropriate shorts 
    (vector unsigned char)(
        0x00, 0x10, 0x02, 0x12,
        0x04, 0x14, 0x06, 0x16,
        0x08, 0x18, 0x0A, 0x1A,
        0x0C, 0x1C, 0x0E, 0x1E );
 vtemp1 contains source AAGGAAGGAAGGAAGG  vtemp2 contains source RRBBRRBBRRBBRRBB  valpha2 is 255-alpha  vtemp3 contains dest AAGGAAGGAAGGAAGG  vtemp4 contains dest RRBBRRBBRRBBRRBB  add source and dest  vtemp1 = (vtemp1 + 1) + ((vtemp1 + 1) >> 8)  vtemp2 = (vtemp2 + 1) + ((vtemp2 + 1) >> 8)  (>>8) and get ARGBARGBARGBARGB  Calculate the permute vector used for 32->32 swizzling 
     * We have to assume that the bits that aren't used by other
     *  colors is alpha, and it's one complete byte, since some formats
     *  leave alpha with a zero mask, but we should still swizzle the bits.
      ARGB  Use zero for alpha if either surface doesn't have alpha  
        0x10 - 0x1f is the alpha
        0x00 - 0x0e evens are the red
        0x01 - 0x0f odds are zero
    
        0x00 - 0x0f is ARxx ARxx ARxx ARxx
        0x11 - 0x0f odds are blue
    
        0x00 - 0x0f is ARxB ARxB ARxB ARxB
        0x10 - 0x0e evens are green
     Load 8 pixels from src as ARGB  Load 8 pixels from dst as XRGB  Alpha blend 8 pixels as ARGB  Convert 8 pixels to 565  Store 8 pixels  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  vsel is set for items that match the key  permute to source format  d = *dstp  set the alpha channel to full on  mask out color key  permute to dest format  *dstp = res  vsrcPermute  vdstPermute  s = *srcp  d = *dstp  set the alpha to the dest alpha  *dstp = res  fast ARGB888->(A)RGB888 blending with pixel alpha  s = *srcp  d = *dstp  set the alpha to the dest alpha  *dstp = res  XXX : 6  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  d = *dstp  set the alpha channel to full on  *dstp = res  fast RGB888->(A)RGB888 blending  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  d = *dstp  set the alpha channel to full on  *dstp = res  SDL_ALTIVEC_BLITTERS  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  fast RGB888->(A)RGB888 blending with surface alpha  One Pixel Blend  Two Pixels Blend  fast ARGB888->(A)RGB888 blending with pixel alpha  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * take out the middle component (green), and process
		     * the other two in parallel. One multiply less.
		      fast (as in MMX with prefetch) ARGB888->(A)RGB888 blending with pixel alpha  make mm6 all zeros.  Make a mask to preserve the alpha.  0000F000 -> mm7  FF000000 -> mm7  FFFFFFFF -> mm4  FFFFFFFF -> mm3 (for later)  00FFFFFF -> mm7 (mult mask)  form channel masks  00FFFFFF -> mm4  00000FFF -> mm4 (channel mask)  0000FFFF -> mm3  0000F000 -> mm3 (~channel mask)  get alpha channel shift  Ashift -> mm5  nothing  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this!  do nothing  opaque alpha -- copy RGB, keep dst alpha  using MMX here to free up regular registers for other things  src(ARGB) -> mm0 (0000ARGB) dst(ARGB) -> mm1 (0000ARGB) src & chanmask -> mm0  dst & ~chanmask -> mm2  src | dst -> mm1  mm1 -> dst  load in the source, and dst.  mm0(s) = 0 0 0 0 | As Rs Gs Bs  mm1(d) = 0 0 0 0 | Ad Rd Gd Bd  Move the src alpha into mm2  if supporting pshufw "pshufw     $0x55, %%mm0, %%mm2\n"  mm2 = 0 As 0 As |  0 As  0  As "psrlw     $8, %%mm2\n"  else:  mm2 = 0 0 0 0 | 0  0  0  As  mm2 = 0 0 0 0 |  0 As  0  As  mm2 = 0 As 0 As |  0 As  0  As  to preserve dest alpha  move the colors into words.  mm0 = 0 As 0 Rs | 0 Gs 0 Bs  mm0 = 0 Ad 0 Rd | 0 Gd 0 Bd  src - dst  mm0 = As-Ad Rs-Rd | Gs-Gd  Bs-Bd  A * (src-dst)  mm0 = 0*As-d As*Rs-d | As*Gs-d  As*Bs-d  mm0 = 0>>8 Rc>>8 | Gc>>8  Bc>>8  mm0 = 0+Ad Rc+Rd | Gc+Gd  Bc+Bd  mm0 =             | Ac Rc Gc Bc  result in mm0  End GCC_ASMBLIT fast (as in MMX with prefetch) ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm_zero  dst alpha mask -> dmask  do nothing  copy RGB, keep dst alpha  src(ARGB) -> src1 (0000ARGB) 0A0R0G0B -> src1  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  alpha -> mm_alpha (0000000A)  mm_alpha >> ashift -> mm_alpha(0000000A)  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  000A0A0A -> mm_alpha, preserve dst alpha on add  blend  src - dst -> src1  (src - dst) * alpha -> src1  src1 >> 8 -> src1(000R0G0B)  src1 + dst1(dst) -> dst1(0A0R0G0B)  0000ARGB -> dst1  dst1 -> pixel  End MSVC_ASMBLIT  GCC_ASMBLIT, MSVC_ASMBLIT  16bpp special case for per-surface alpha=50%: blend 2 pixels in parallel  blend a single 16 bit pixel at 50%  blend two 16 bit pixels at 50% 
			 * Source and destination not aligned, pipeline it.
			 * This is mostly a win for big blits but no loss for
			 * small ones
			  handle odd destination  srcp is now 32-bit aligned  bootstrap pipeline with first halfword  final pixel if any  source and destination are aligned  first odd pixel?  srcp and dstp are now 32-bit aligned  last odd pixel?  fast RGB565->RGB565 blending with surface alpha  downscale alpha to 5 bits  cut alpha to get the exact same behaviour  downscale alpha to 5 bits  alpha(0000000A) -> mm0  00000A0A -> mm0  0A0A0A0A -> mm0  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 565 color channel masks  MASKGREEN -> mm4  MASKBLUE -> mm7 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> mm2  4 dst pixels -> mm3  red -- does not need a mask since the right shift clears
				   the uninteresting bits  src -> mm5  dst -> mm6  mm5 >> 11 -> mm5 [000r 000r 000r 000r]  mm6 >> 11 -> mm6 [000r 000r 000r 000r]  blend  src - dst -> mm5  mm5 * alpha -> mm5  alpha used is actually 11 bits
				   11 + 5 = 16 bits, so the sign bits are lost  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 << 11 -> mm6  save new reds in dsts  green -- process the bits in place  src -> mm5  dst -> mm6  src & MASKGREEN -> mm5  dst & MASKGREEN -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 11 - 16 = 6 bits, so all the lower uninteresting
				   bits are gone and the sign bits present  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  save new greens in dsts  blue  src -> mm5  dst -> mm6  src & MASKBLUE -> mm5[000b 000b 000b 000b]  dst & MASKBLUE -> mm6[000b 000b 000b 000b]  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 5 = 16 bits, so the sign bits are lost and
				   the interesting bits will need to be MASKed  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKBLUE -> mm6[000b 000b 000b 000b]  save new blues in dsts  mm1 -> 4 dst pixels  fast RGB555->RGB555 blending with surface alpha  downscale alpha to 5 bits  cut alpha to get the exact same behaviour  downscale alpha to 5 bits  alpha(0000000A) -> mm0  00000A0A -> mm0  0A0A0A0A -> mm0  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 555 color channel masks  MASKGREEN -> mm4  MASKBLUE -> mm7 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> mm2  4 dst pixels -> mm3  red -- process the bits in place  turn MASKGREEN into MASKRED  by reusing the GREEN mask we free up another mmx
					   register to accumulate the result  src -> mm5  dst -> mm6  src & MASKRED -> mm5  dst & MASKRED -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 15 - 16 = 10 bits, uninteresting bits will be
				   cleared by a MASK below  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKRED -> mm6  turn MASKRED back into MASKGREEN  save new reds in dsts  green -- process the bits in place  src -> mm5  dst -> mm6  src & MASKGREEN -> mm5  dst & MASKGREEN -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 10 - 16 = 5 bits,  so all the lower uninteresting
				   bits are gone and the sign bits present  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  save new greens in dsts  blue  src -> mm5  dst -> mm6  src & MASKBLUE -> mm5[000b 000b 000b 000b]  dst & MASKBLUE -> mm6[000b 000b 000b 000b]  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 5 = 16 bits, so the sign bits are lost and
				   the interesting bits will need to be MASKed  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKBLUE -> mm6[000b 000b 000b 000b]  save new blues in dsts  mm1 -> 4 dst pixels  End GCC_ASMBLIT  fast RGB565->RGB565 blending with surface alpha  cut alpha to get the exact same behaviour  0000000A -> mm_alpha  downscale alpha to 5 bits  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 565 color channel masks  MASKGREEN -> gmask  MASKBLUE -> bmask 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> src1  4 dst pixels -> dst1  red  src2 >> 11 -> src2 [000r 000r 000r 000r]  dst2 >> 11 -> dst2 [000r 000r 000r 000r]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 << 11 -> dst2  RED -> mm_res  green -- process the bits in place  src & MASKGREEN -> src2  dst & MASKGREEN -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  RED | GREEN -> mm_res  blue  src & MASKBLUE -> src2[000b 000b 000b 000b]  dst & MASKBLUE -> dst2[000b 000b 000b 000b]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 & MASKBLUE -> dst2  RED | GREEN | BLUE -> mm_res  mm_res -> 4 dst pixels  fast RGB555->RGB555 blending with surface alpha  cut alpha to get the exact same behaviour  0000000A -> mm_alpha  downscale alpha to 5 bits  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 555 color channel masks  MASKRED -> rmask  MASKGREEN -> gmask  MASKBLUE -> bmask 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> src1  4 dst pixels -> dst1  red -- process the bits in place  src & MASKRED -> src2  dst & MASKRED -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  dst2 & MASKRED -> dst2  RED -> mm_res  green -- process the bits in place  src & MASKGREEN -> src2  dst & MASKGREEN -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  RED | GREEN -> mm_res  blue  src -> src2  src & MASKBLUE -> src2[000b 000b 000b 000b]  dst -> dst2  dst & MASKBLUE -> dst2[000b 000b 000b 000b]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 & MASKBLUE -> dst2  RED | GREEN | BLUE -> mm_res  mm_res -> 4 dst pixels  GCC_ASMBLIT, MSVC_ASMBLIT  fast RGB565->RGB565 blending with surface alpha  downscale alpha to 5 bits 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  fast RGB555->RGB555 blending with surface alpha  downscale alpha to 5 bits  downscale alpha to 5 bits 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  fast ARGB8888->RGB565 blending with pixel alpha  downscale alpha to 5 bits  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * convert source and destination to G0RAB65565
		     * and blend all components at the same time
		      fast ARGB8888->RGB555 blending with pixel alpha  downscale alpha to 5 bits  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * convert source and destination to G0RAB65565
		     * and blend all components at the same time
		      General (slow) N->N blending with per-surface alpha  General (slow) colorkeyed N->N blending with per-surface alpha  General (slow) N->N blending with pixel alpha  Set up some basic variables  FIXME: for 8bpp source alpha, this doesn't get opaque values
	   quite right. for <8bpp source alpha, it gets them very wrong
	   (check all macros!)
	   It is unclear whether there is a good general solution that doesn't
	   need a branch (or a divide).  Per-surface alpha blits  Per-pixel alpha blits 
    SDL - Simple DirectMedia Layer
    Copyright (C) 1997-2012 Sam Lantinga

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Sam Lantinga
    slouken@libsdl.org

  In Visual C, VC6 has mmintrin.h in the "Processor Pack" add-on.
   Checking if _mm_free is #defined in malloc.h is is the only way to
   determine if the Processor Pack is installed, as far as I can tell.
 forced MMX to 0...it breaks on most compilers now.  --ryan.  Visual Studio > VC6 always has mmintrin.h  SDL_ASSEMBLY_ROUTINES  Function to check the CPU flags  Functions to perform alpha blended blitting  N->1 blending with per-surface alpha  Pack RGB into 8bit pixel  N->1 blending with pixel alpha  FIXME: fix alpha bit field expansion here too?  Pack RGB into 8bit pixel  colorkeyed N->1 blending with per-surface alpha  Pack RGB into 8bit pixel  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  alpha128 mask  alpha128 mask -> mm4  !alpha128 mask  !alpha128 mask -> mm3  dst alpha mask  dst alpha mask | dst alpha mask -> mm7  2 x dst -> mm2(ARGBARGB)  2 x dst -> mm6(ARGBARGB)  2 x src -> mm1(ARGBARGB)  2 x src -> mm5(ARGBARGB)  dst & mask -> mm6  src & mask -> mm5  mm6 + mm5 -> mm5  src & dst -> mm2  mm5 >> 1 -> mm5  mm2 & !mask -> mm2  mm5 + mm2 -> mm2  mm7(full alpha) | mm2 -> mm2  mm2 -> 2 x dst pixels  fast RGB888->(A)RGB888 blending with surface alpha  only call a128 version when R,G,B occupy lower bits  0 -> mm5  form the alpha mult  0000000A -> mm4  00000A0A -> mm4  0A0A0A0A -> mm4  00000FFF -> mm0  00FFFFFF -> mm0  0A0A0A0A -> mm4, minus 1 chan  at this point mm4 can be 000A0A0A or 0A0A0A00 or another combo  dst alpha mask  dst alpha mask | dst alpha mask -> mm7  One Pixel Blend  src(ARGB) -> mm1 (0000ARGB) dst(ARGB) -> mm2 (0000ARGB) 0A0R0G0B -> mm1(src)  0A0R0G0B -> mm2(dst)  src - dst -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1  mm1 + mm2(dst) -> mm2  ARGBARGB -> mm2  mm7(full alpha) | mm2 -> mm2  mm2 -> pixel  Two Pixels Blend  2 x src -> mm0(ARGBARGB) 2 x dst -> mm2(ARGBARGB)  2 x src -> mm1(ARGBARGB)  2 x dst -> mm6(ARGBARGB)  low - 0A0R0G0B -> mm0(src1)  high - 0A0R0G0B -> mm1(src2)  low - 0A0R0G0B -> mm2(dst1)  high - 0A0R0G0B -> mm6(dst2)  src1 - dst1 -> mm0  mm0 * alpha -> mm0  mm0 >> 8 -> mm1  mm0 + mm2(dst1) -> mm2  src2 - dst2 -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1  mm1 + mm6(dst2) -> mm6  ARGBARGB -> mm2  mm7(dst alpha) | mm2 -> mm2  mm2 -> 2 x pixel  fast ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm6  form multiplication mask  0000F000 -> mm7  FF000000 -> mm7  FFFFFFFF -> mm0  FFFFFFFF -> mm3 (for later)  00FFFFFF -> mm7 (mult mask)  form channel masks  00FFFFFF -> mm0  00000FFF -> mm0 (channel mask)  0000FFFF -> mm3  0000F000 -> mm3 (~channel mask)  get alpha channel shift  Ashift -> mm5  FIXME: Here we special-case opaque alpha since the
			compositioning used (>>8 instead of /255) doesn't handle
			it correctly. Also special-case alpha=0 for speed?
			Benchmark this!  do nothing  opaque alpha -- copy RGB, keep dst alpha  using MMX here to free up regular registers for other things  src(ARGB) -> mm1 (0000ARGB) dst(ARGB) -> mm2 (0000ARGB) src & chanmask -> mm1  dst & ~chanmask -> mm2  src | dst -> mm2  mm2 -> dst  src(ARGB) -> mm1 (0000ARGB) 0A0R0G0B -> mm1  dst(ARGB) -> mm2 (0000ARGB) 0A0R0G0B -> mm2  0000A000 -> mm4  mm4 >> mm5 -> mm4 (0000000A)  00000A0A -> mm4  0A0A0A0A -> mm4  000A0A0A -> mm4, preserve dst alpha on add  blend  src - dst -> mm1  mm1 * alpha -> mm1  mm1 >> 8 -> mm1(000R0G0B)  mm1 + mm2(dst) -> mm2  0000ARGB -> mm2  mm2 -> dst  End GCC_ASMBLIT  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  alpha128 mask -> hmask  !alpha128 mask -> lmask  dst alpha mask -> dsta  2 x dst -> dst1(ARGBARGB)  2 x dst -> dst2(ARGBARGB)  2 x src -> src1(ARGBARGB)  2 x src -> src2(ARGBARGB)  dst & mask -> dst2  src & mask -> src2  dst2 + src2 -> src2  src2 >> 1 -> src2  src & dst -> dst1  dst1 & !mask -> dst1  src2 + dst1 -> dst1  dsta(full alpha) | dst1 -> dst1  dst1 -> 2 x dst pixels  fast RGB888->(A)RGB888 blending with surface alpha  only call a128 version when R,G,B occupy lower bits  0 -> mm_zero  form the alpha mult  0000AAAA -> mm_alpha, minus 1 chan  0A0A0A0A -> mm_alpha, minus 1 chan  at this point mm_alpha can be 000A0A0A or 0A0A0A00 or another combo  dst alpha mask -> dsta  One Pixel Blend  src(ARGB) -> src2 (0000ARGB) 0A0R0G0B -> src2  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  src2 - dst2 -> src2  src2 * alpha -> src2  src2 >> 8 -> src2  src2 + dst1 -> dst1  0000ARGB -> dst1  dsta | dst1 -> dst1  dst1 -> pixel  Two Pixels Blend  2 x src -> src1(ARGBARGB) 2 x src -> src2(ARGBARGB)  low - 0A0R0G0B -> src1  high - 0A0R0G0B -> src2  2 x dst -> dst1(ARGBARGB)  2 x dst -> dst2(ARGBARGB)  low - 0A0R0G0B -> dst1  high - 0A0R0G0B -> dst2  src1 - dst1 -> src1  src1 * alpha -> src1  src1 >> 8 -> src1  src1 + dst1(dst1) -> dst1  src2 - dst2 -> src2  src2 * alpha -> src2  src2 >> 8 -> src2  src2 + dst2(dst2) -> dst2  0A0R0G0B(res1), 0A0R0G0B(res2) -> dst1(ARGBARGB)  dsta | dst1 -> dst1  dst1 -> 2 x pixel  fast ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm_zero  dst alpha mask -> dmask  do nothing  opaque alpha -- copy RGB, keep dst alpha  src(ARGB) -> src1 (0000ARGB) 0A0R0G0B -> src1  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  alpha -> mm_alpha (0000000A)  mm_alpha >> ashift -> mm_alpha(0000000A)  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  000A0A0A -> mm_alpha, preserve dst alpha on add  blend  src1 - dst1 -> src1  (src1 - dst1) * alpha -> src1  src1 >> 8 -> src1(000R0G0B)  src1 + dst1 -> dst1(0A0R0G0B)  0000ARGB -> dst1  dst1 -> pixel  End MSVC_ASMBLIT  GCC_ASMBLIT, MSVC_ASMBLIT  the permuation vector that takes the high bytes out of all the appropriate shorts 
    (vector unsigned char)(
        0x00, 0x10, 0x02, 0x12,
        0x04, 0x14, 0x06, 0x16,
        0x08, 0x18, 0x0A, 0x1A,
        0x0C, 0x1C, 0x0E, 0x1E );
 vtemp1 contains source AAGGAAGGAAGGAAGG  vtemp2 contains source RRBBRRBBRRBBRRBB  valpha2 is 255-alpha  vtemp3 contains dest AAGGAAGGAAGGAAGG  vtemp4 contains dest RRBBRRBBRRBBRRBB  add source and dest  vtemp1 = (vtemp1 + 1) + ((vtemp1 + 1) >> 8)  vtemp2 = (vtemp2 + 1) + ((vtemp2 + 1) >> 8)  (>>8) and get ARGBARGBARGBARGB  Calculate the permute vector used for 32->32 swizzling 
     * We have to assume that the bits that aren't used by other
     *  colors is alpha, and it's one complete byte, since some formats
     *  leave alpha with a zero mask, but we should still swizzle the bits.
      ARGB  Use zero for alpha if either surface doesn't have alpha  
        0x10 - 0x1f is the alpha
        0x00 - 0x0e evens are the red
        0x01 - 0x0f odds are zero
    
        0x00 - 0x0f is ARxx ARxx ARxx ARxx
        0x11 - 0x0f odds are blue
    
        0x00 - 0x0f is ARxB ARxB ARxB ARxB
        0x10 - 0x0e evens are green
     Load 8 pixels from src as ARGB  Load 8 pixels from dst as XRGB  Alpha blend 8 pixels as ARGB  Convert 8 pixels to 565  Store 8 pixels  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  vsel is set for items that match the key  permute to source format  d = *dstp  set the alpha channel to full on  mask out color key  permute to dest format  *dstp = res  vsrcPermute  vdstPermute  s = *srcp  d = *dstp  set the alpha to the dest alpha  *dstp = res  fast ARGB888->(A)RGB888 blending with pixel alpha  s = *srcp  d = *dstp  set the alpha to the dest alpha  *dstp = res  XXX : 6  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  d = *dstp  set the alpha channel to full on  *dstp = res  fast RGB888->(A)RGB888 blending  set the alpha to 255 on the destination surf  set a vector full of alpha and 255-alpha  s = *srcp  d = *dstp  set the alpha channel to full on  *dstp = res  SDL_ALTIVEC_BLITTERS  fast RGB888->(A)RGB888 blending with surface alpha=128 special case  fast RGB888->(A)RGB888 blending with surface alpha  One Pixel Blend  Two Pixels Blend  fast ARGB888->(A)RGB888 blending with pixel alpha  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * take out the middle component (green), and process
		     * the other two in parallel. One multiply less.
		      fast (as in MMX with prefetch) ARGB888->(A)RGB888 blending with pixel alpha  make mm6 all zeros.  Make a mask to preserve the alpha.  0000F000 -> mm7  FF000000 -> mm7  FFFFFFFF -> mm4  FFFFFFFF -> mm3 (for later)  00FFFFFF -> mm7 (mult mask)  form channel masks  00FFFFFF -> mm4  00000FFF -> mm4 (channel mask)  0000FFFF -> mm3  0000F000 -> mm3 (~channel mask)  get alpha channel shift  Ashift -> mm5  nothing  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this!  do nothing  opaque alpha -- copy RGB, keep dst alpha  using MMX here to free up regular registers for other things  src(ARGB) -> mm0 (0000ARGB) dst(ARGB) -> mm1 (0000ARGB) src & chanmask -> mm0  dst & ~chanmask -> mm2  src | dst -> mm1  mm1 -> dst  load in the source, and dst.  mm0(s) = 0 0 0 0 | As Rs Gs Bs  mm1(d) = 0 0 0 0 | Ad Rd Gd Bd  Move the src alpha into mm2  if supporting pshufw "pshufw     $0x55, %%mm0, %%mm2\n"  mm2 = 0 As 0 As |  0 As  0  As "psrlw     $8, %%mm2\n"  else:  mm2 = 0 0 0 0 | 0  0  0  As  mm2 = 0 0 0 0 |  0 As  0  As  mm2 = 0 As 0 As |  0 As  0  As  to preserve dest alpha  move the colors into words.  mm0 = 0 As 0 Rs | 0 Gs 0 Bs  mm0 = 0 Ad 0 Rd | 0 Gd 0 Bd  src - dst  mm0 = As-Ad Rs-Rd | Gs-Gd  Bs-Bd  A * (src-dst)  mm0 = 0*As-d As*Rs-d | As*Gs-d  As*Bs-d  mm0 = 0>>8 Rc>>8 | Gc>>8  Bc>>8  mm0 = 0+Ad Rc+Rd | Gc+Gd  Bc+Bd  mm0 =             | Ac Rc Gc Bc  result in mm0  End GCC_ASMBLIT fast (as in MMX with prefetch) ARGB888->(A)RGB888 blending with pixel alpha  0 -> mm_zero  dst alpha mask -> dmask  do nothing  copy RGB, keep dst alpha  src(ARGB) -> src1 (0000ARGB) 0A0R0G0B -> src1  dst(ARGB) -> dst1 (0000ARGB) 0A0R0G0B -> dst1  alpha -> mm_alpha (0000000A)  mm_alpha >> ashift -> mm_alpha(0000000A)  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  000A0A0A -> mm_alpha, preserve dst alpha on add  blend  src - dst -> src1  (src - dst) * alpha -> src1  src1 >> 8 -> src1(000R0G0B)  src1 + dst1(dst) -> dst1(0A0R0G0B)  0000ARGB -> dst1  dst1 -> pixel  End MSVC_ASMBLIT  GCC_ASMBLIT, MSVC_ASMBLIT  16bpp special case for per-surface alpha=50%: blend 2 pixels in parallel  blend a single 16 bit pixel at 50%  blend two 16 bit pixels at 50% 
			 * Source and destination not aligned, pipeline it.
			 * This is mostly a win for big blits but no loss for
			 * small ones
			  handle odd destination  srcp is now 32-bit aligned  bootstrap pipeline with first halfword  final pixel if any  source and destination are aligned  first odd pixel?  srcp and dstp are now 32-bit aligned  last odd pixel?  fast RGB565->RGB565 blending with surface alpha  downscale alpha to 5 bits  cut alpha to get the exact same behaviour  downscale alpha to 5 bits  alpha(0000000A) -> mm0  00000A0A -> mm0  0A0A0A0A -> mm0  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 565 color channel masks  MASKGREEN -> mm4  MASKBLUE -> mm7 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> mm2  4 dst pixels -> mm3  red -- does not need a mask since the right shift clears
				   the uninteresting bits  src -> mm5  dst -> mm6  mm5 >> 11 -> mm5 [000r 000r 000r 000r]  mm6 >> 11 -> mm6 [000r 000r 000r 000r]  blend  src - dst -> mm5  mm5 * alpha -> mm5  alpha used is actually 11 bits
				   11 + 5 = 16 bits, so the sign bits are lost  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 << 11 -> mm6  save new reds in dsts  green -- process the bits in place  src -> mm5  dst -> mm6  src & MASKGREEN -> mm5  dst & MASKGREEN -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 11 - 16 = 6 bits, so all the lower uninteresting
				   bits are gone and the sign bits present  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  save new greens in dsts  blue  src -> mm5  dst -> mm6  src & MASKBLUE -> mm5[000b 000b 000b 000b]  dst & MASKBLUE -> mm6[000b 000b 000b 000b]  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 5 = 16 bits, so the sign bits are lost and
				   the interesting bits will need to be MASKed  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKBLUE -> mm6[000b 000b 000b 000b]  save new blues in dsts  mm1 -> 4 dst pixels  fast RGB555->RGB555 blending with surface alpha  downscale alpha to 5 bits  cut alpha to get the exact same behaviour  downscale alpha to 5 bits  alpha(0000000A) -> mm0  00000A0A -> mm0  0A0A0A0A -> mm0  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 555 color channel masks  MASKGREEN -> mm4  MASKBLUE -> mm7 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> mm2  4 dst pixels -> mm3  red -- process the bits in place  turn MASKGREEN into MASKRED  by reusing the GREEN mask we free up another mmx
					   register to accumulate the result  src -> mm5  dst -> mm6  src & MASKRED -> mm5  dst & MASKRED -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 15 - 16 = 10 bits, uninteresting bits will be
				   cleared by a MASK below  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKRED -> mm6  turn MASKRED back into MASKGREEN  save new reds in dsts  green -- process the bits in place  src -> mm5  dst -> mm6  src & MASKGREEN -> mm5  dst & MASKGREEN -> mm6  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 10 - 16 = 5 bits,  so all the lower uninteresting
				   bits are gone and the sign bits present  mm5 << 5 -> mm5  mm5 + mm6(dst) -> mm6  save new greens in dsts  blue  src -> mm5  dst -> mm6  src & MASKBLUE -> mm5[000b 000b 000b 000b]  dst & MASKBLUE -> mm6[000b 000b 000b 000b]  blend  src - dst -> mm5  mm5 * alpha -> mm5  11 + 5 = 16 bits, so the sign bits are lost and
				   the interesting bits will need to be MASKed  mm5 >> 11 -> mm5  mm5 + mm6(dst) -> mm6  mm6 & MASKBLUE -> mm6[000b 000b 000b 000b]  save new blues in dsts  mm1 -> 4 dst pixels  End GCC_ASMBLIT  fast RGB565->RGB565 blending with surface alpha  cut alpha to get the exact same behaviour  0000000A -> mm_alpha  downscale alpha to 5 bits  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 565 color channel masks  MASKGREEN -> gmask  MASKBLUE -> bmask 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> src1  4 dst pixels -> dst1  red  src2 >> 11 -> src2 [000r 000r 000r 000r]  dst2 >> 11 -> dst2 [000r 000r 000r 000r]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 << 11 -> dst2  RED -> mm_res  green -- process the bits in place  src & MASKGREEN -> src2  dst & MASKGREEN -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  RED | GREEN -> mm_res  blue  src & MASKBLUE -> src2[000b 000b 000b 000b]  dst & MASKBLUE -> dst2[000b 000b 000b 000b]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 & MASKBLUE -> dst2  RED | GREEN | BLUE -> mm_res  mm_res -> 4 dst pixels  fast RGB555->RGB555 blending with surface alpha  cut alpha to get the exact same behaviour  0000000A -> mm_alpha  downscale alpha to 5 bits  00000A0A -> mm_alpha  0A0A0A0A -> mm_alpha  position alpha to allow for mullo and mulhi on diff channels
		   to reduce the number of operations  Setup the 555 color channel masks  MASKRED -> rmask  MASKGREEN -> gmask  MASKBLUE -> bmask 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  4 src pixels -> src1  4 dst pixels -> dst1  red -- process the bits in place  src & MASKRED -> src2  dst & MASKRED -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  dst2 & MASKRED -> dst2  RED -> mm_res  green -- process the bits in place  src & MASKGREEN -> src2  dst & MASKGREEN -> dst2  blend  src - dst -> src2  src2 * alpha -> src2  src2 << 5 -> src2  src2 + dst2 -> dst2  RED | GREEN -> mm_res  blue  src -> src2  src & MASKBLUE -> src2[000b 000b 000b 000b]  dst -> dst2  dst & MASKBLUE -> dst2[000b 000b 000b 000b]  blend  src - dst -> src2  src2 * alpha -> src2  src2 >> 11 -> src2  src2 + dst2 -> dst2  dst2 & MASKBLUE -> dst2  RED | GREEN | BLUE -> mm_res  mm_res -> 4 dst pixels  GCC_ASMBLIT, MSVC_ASMBLIT  fast RGB565->RGB565 blending with surface alpha  downscale alpha to 5 bits 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  fast RGB555->RGB555 blending with surface alpha  downscale alpha to 5 bits  downscale alpha to 5 bits 
				 * shift out the middle component (green) to
				 * the high 16 bits, and process all three RGB
				 * components at the same time.
				  fast ARGB8888->RGB565 blending with pixel alpha  downscale alpha to 5 bits  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * convert source and destination to G0RAB65565
		     * and blend all components at the same time
		      fast ARGB8888->RGB555 blending with pixel alpha  downscale alpha to 5 bits  FIXME: Here we special-case opaque alpha since the
		   compositioning used (>>8 instead of /255) doesn't handle
		   it correctly. Also special-case alpha=0 for speed?
		   Benchmark this! 
		     * convert source and destination to G0RAB65565
		     * and blend all components at the same time
		      General (slow) N->N blending with per-surface alpha  General (slow) colorkeyed N->N blending with per-surface alpha  General (slow) N->N blending with pixel alpha  Set up some basic variables  FIXME: for 8bpp source alpha, this doesn't get opaque values
	   quite right. for <8bpp source alpha, it gets them very wrong
	   (check all macros!)
	   It is unclear whether there is a good general solution that doesn't
	   need a branch (or a divide).  Per-surface alpha blits  Per-pixel alpha blits 